/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_NUMERIC_HPP
#define INT128_NUMERIC_HPP

#include "int128_t.hpp"
#include <algorithm>
#include <cstdint>

/**
 * @brief Funciones numéricas de C++20 especializadas para int128_t
 *
 * Este archivo implementa funciones numéricas estándar de C++20 que no están
 * automáticamente disponibles para int128_t, como std::midpoint, std::clamp,
 * std::abs, y funciones de manipulación de bits.
 */

namespace std
{

// ===============================================================================
// FUNCIONES ARITMÉTICAS SEGURAS
// ===============================================================================

/**
 * @brief Calcula el punto medio entre dos valores int128_t sin overflow
 *
 * @param a Primer valor
 * @param b Segundo valor
 * @return Punto medio entre a y b
 *
 * La implementación evita overflow usando una fórmula que mantiene
 * la precisión y maneja correctamente los números negativos.
 */
constexpr int128_t midpoint(int128_t a, int128_t b) noexcept
{
    // Usar la fórmula segura: a + (b - a) / 2
    // Esto evita overflow en la suma intermedia
    return a + (b - a) / int128_t(2);
}

/**
 * @brief Restringe un valor a un rango específico
 *
 * @param v Valor a restringir
 * @param lo Valor mínimo del rango
 * @param hi Valor máximo del rango
 * @return v restringido al rango [lo, hi]
 *
 * Precondición: lo <= hi
 */
constexpr int128_t clamp(const int128_t& v, const int128_t& lo, const int128_t& hi)
{
    return (v < lo) ? lo : (hi < v) ? hi : v;
}

/**
 * @brief Valor absoluto de int128_t
 *
 * @param x Valor del cual obtener el valor absoluto
 * @return |x|
 *
 * Nota: abs(INT128_MIN) == INT128_MIN debido a overflow en complemento a 2
 */
constexpr int128_t abs(int128_t x) noexcept
{
    return x.abs();
}

// ===============================================================================
// FUNCIONES DE MANIPULACIÓN DE BITS
// ===============================================================================

/**
 * @brief Cuenta el número de bits establecidos (población de bits)
 *
 * @param x Valor a examinar
 * @return Número de bits establecidos en x
 *
 * Para números negativos, cuenta los bits en la representación de complemento a 2.
 */
constexpr int popcount(int128_t x) noexcept
{
    // Trabajar con la representación binaria directa
    int count = 0;
    if (x.high() != 0) {
        count += __builtin_popcountll(x.high());
    }
    if (x.low() != 0) {
        count += __builtin_popcountll(x.low());
    }
    return count;
}

/**
 * @brief Cuenta los ceros a la izquierda (leading zeros)
 *
 * @param x Valor a examinar
 * @return Número de ceros a la izquierda
 *
 * Para números negativos, cuenta los ceros en la representación de complemento a 2.
 * Típicamente será 0 para números negativos (ya que el MSB es 1).
 */
constexpr int countl_zero(int128_t x) noexcept
{
    if (x == int128_t(0)) {
        return 128;
    }

    if (x.high() != 0) {
        return __builtin_clzll(x.high());
    } else {
        return 64 + __builtin_clzll(x.low());
    }
}

/**
 * @brief Cuenta los unos a la izquierda (leading ones)
 *
 * @param x Valor a examinar
 * @return Número de unos a la izquierda
 */
constexpr int countl_one(int128_t x) noexcept
{
    return countl_zero(~x);
}

/**
 * @brief Cuenta los ceros a la derecha (trailing zeros)
 *
 * @param x Valor a examinar
 * @return Número de ceros a la derecha
 */
constexpr int countr_zero(int128_t x) noexcept
{
    if (x == int128_t(0)) {
        return 128;
    }

    if (x.low() != 0) {
        return __builtin_ctzll(x.low());
    } else {
        return 64 + __builtin_ctzll(x.high());
    }
}

/**
 * @brief Cuenta los unos a la derecha (trailing ones)
 *
 * @param x Valor a examinar
 * @return Número de unos a la derecha
 */
constexpr int countr_one(int128_t x) noexcept
{
    return countr_zero(~x);
}

/**
 * @brief Calcula el ancho en bits del valor (número de bits necesarios para representar x)
 *
 * @param x Valor a examinar
 * @return Número de bits necesarios para representar x
 *
 * Para números negativos, devuelve 128 ya que se necesitan todos los bits
 * para la representación de complemento a 2.
 */
constexpr int bit_width(int128_t x) noexcept
{
    if (x < int128_t(0)) {
        return 128; // Números negativos usan todos los bits
    }
    if (x == int128_t(0)) {
        return 0;
    }
    return 128 - countl_zero(x);
}

// ===============================================================================
// FUNCIONES DE POTENCIAS DE 2 (para valores no negativos)
// ===============================================================================

/**
 * @brief Verifica si x es una potencia de 2
 *
 * @param x Valor a examinar (debe ser >= 0)
 * @return true si x es una potencia de 2, false en caso contrario
 */
constexpr bool has_single_bit(int128_t x) noexcept
{
    return x > int128_t(0) && popcount(x) == 1;
}

/**
 * @brief Encuentra la potencia de 2 mayor o igual a x
 *
 * @param x Valor a examinar (debe ser > 0)
 * @return Menor potencia de 2 >= x
 */
constexpr int128_t bit_ceil(int128_t x)
{
    if (x <= int128_t(1)) {
        return int128_t(1);
    }

    // Si x es negativo, lanzar excepción o comportamiento indefinido
    if (x < int128_t(0)) {
        throw std::domain_error("bit_ceil: argument must be positive");
    }

    int width = bit_width(x - int128_t(1));
    if (width >= 127) {
        throw std::overflow_error("bit_ceil: result would overflow");
    }

    return int128_t(1) << width;
}

/**
 * @brief Encuentra la potencia de 2 menor o igual a x
 *
 * @param x Valor a examinar (debe ser > 0)
 * @return Mayor potencia de 2 <= x
 */
constexpr int128_t bit_floor(int128_t x) noexcept
{
    if (x <= int128_t(0)) {
        return int128_t(0);
    }

    int width = bit_width(x);
    if (width == 0) {
        return int128_t(0);
    }

    return int128_t(1) << (width - 1);
}

// ===============================================================================
// FUNCIONES AUXILIARES MATEMÁTICAS
// ===============================================================================

/**
 * @brief Calcula el máximo común divisor usando el algoritmo de Euclides
 *
 * @param a Primer número
 * @param b Segundo número
 * @return gcd(|a|, |b|)
 */
constexpr int128_t gcd(int128_t a, int128_t b) noexcept
{
    // Trabajar con valores absolutos
    a = abs(a);
    b = abs(b);

    while (b != int128_t(0)) {
        int128_t temp = b;
        b = a % b;
        a = temp;
    }

    return a;
}

/**
 * @brief Calcula el mínimo común múltiplo
 *
 * @param a Primer número
 * @param b Segundo número
 * @return lcm(|a|, |b|)
 */
constexpr int128_t lcm(int128_t a, int128_t b)
{
    if (a == int128_t(0) || b == int128_t(0)) {
        return int128_t(0);
    }

    a = abs(a);
    b = abs(b);

    // lcm(a,b) = |a*b| / gcd(a,b)
    // Calculamos de forma que evite overflow
    int128_t g = gcd(a, b);
    return (a / g) * b;
}

} // namespace std

#endif // INT128_NUMERIC_HPP