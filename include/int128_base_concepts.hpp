/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_BASE_CONCEPTS_HPP
#define INT128_BASE_CONCEPTS_HPP

/**
 * @file int128_base_concepts.hpp
 * @brief Conceptos C++20 unificados para int128_base_t<S>
 * @author Julián Calderón Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-05
 * @copyright Boost Software License 1.0
 *
 * Este archivo define conceptos C++20 que funcionan con el template
 * unificado int128_base_t<signedness S>, incluyendo:
 * - Conceptos de detección de tipo (is_int128, is_uint128, is_128bit_type)
 * - Conceptos de conversión y compatibilidad
 * - Conceptos para operaciones bitwise y shift
 * - Conceptos para algoritmos y contenedores
 * - Verificaciones estáticas de conformidad STL
 */

#include "int128_base_tt.hpp"
#include <concepts>
#include <type_traits>

namespace nstd
{

// =============================================================================
// HELPER TRAITS PARA DETECCIÓN DE TIPO
// =============================================================================

namespace detail
{

/**
 * @brief Detecta si un tipo es una instancia de int128_base_t
 */
template <typename T> struct is_int128_base_impl : std::false_type {
};

template <signedness S> struct is_int128_base_impl<int128_base_t<S>> : std::true_type {
};

/**
 * @brief Detecta si un tipo es exactamente uint128_t
 */
template <typename T>
struct is_uint128_impl : std::bool_constant<std::is_same_v<std::remove_cv_t<T>, uint128_t>> {
};

/**
 * @brief Detecta si un tipo es exactamente int128_t
 */
template <typename T>
struct is_int128_impl : std::bool_constant<std::is_same_v<std::remove_cv_t<T>, int128_t>> {
};

} // namespace detail

// =============================================================================
// TYPE TRAITS PÚBLICOS
// =============================================================================

/**
 * @brief Verdadero si T es cualquier instancia de int128_base_t<S>
 */
template <typename T>
inline constexpr bool is_128bit_type_v = detail::is_int128_base_impl<std::remove_cv_t<T>>::value;

/**
 * @brief Verdadero si T es exactamente uint128_t
 */
template <typename T> inline constexpr bool is_uint128_v = detail::is_uint128_impl<T>::value;

/**
 * @brief Verdadero si T es exactamente int128_t
 */
template <typename T> inline constexpr bool is_int128_v = detail::is_int128_impl<T>::value;

// =============================================================================
// CONCEPTOS BÁSICOS
// =============================================================================

/**
 * @brief Concept para tipos que son instancias de int128_base_t
 */
template <typename T>
concept int128_type = is_128bit_type_v<T>;

/**
 * @brief Concept para tipos que son uint128_t específicamente
 */
template <typename T>
concept uint128_type = is_uint128_v<T>;

/**
 * @brief Concept para tipos que son int128_t específicamente
 */
template <typename T>
concept signed_int128_type = is_int128_v<T>;

/**
 * @brief Concept para tipos que pueden convertirse a int128_base_t<S>
 *
 * @tparam T Tipo a verificar
 *
 * Un tipo satisface este concepto si es un tipo integral estándar
 * o es una instancia de int128_base_t<S>.
 */
template <typename T>
concept int128_convertible = std::integral<T> || int128_type<T>;

/**
 * @brief Concept para tipos integrales incluyendo int128_base_t
 *
 * @tparam T Tipo a verificar
 *
 * Extiende std::integral para incluir uint128_t e int128_t.
 * Usar en lugar de std::integral cuando se necesita soporte 128-bit.
 */
template <typename T>
concept integral = std::integral<T> || int128_type<T>;

/**
 * @brief Concept para tipos que son compatibles con operaciones de int128_base_t
 *
 * @tparam T Tipo a verificar
 *
 * Incluye todos los tipos convertibles y también tipos de punto flotante
 * para operaciones mixtas.
 */
template <typename T>
concept int128_compatible = int128_convertible<T> || std::floating_point<T>;

/**
 * @brief Concept para tipos que pueden usarse con operaciones bitwise
 *
 * @tparam T Tipo a verificar
 *
 * Solo tipos integrales pueden realizar operaciones bitwise seguras.
 */
template <typename T>
concept int128_bitwise_compatible = std::integral<T> || int128_type<T>;

/**
 * @brief Concept para tipos integrales signados compatibles
 *
 * @tparam T Tipo a verificar
 *
 * Verifica que el tipo sea un entero signado estándar o int128_t.
 */
template <typename T>
concept int128_signed_compatible = std::signed_integral<T> || is_int128_v<T>;

/**
 * @brief Concept para tipos integrales sin signo compatibles
 *
 * @tparam T Tipo a verificar
 *
 * Verifica que el tipo sea un entero sin signo estándar o uint128_t.
 */
template <typename T>
concept int128_unsigned_compatible = std::unsigned_integral<T> || is_uint128_v<T>;

// =============================================================================
// CONCEPTOS PARA OPERACIONES ESPECÍFICAS
// =============================================================================

/**
 * @brief Concept para tipos válidos en operaciones de desplazamiento
 *
 * @tparam T Tipo del operando de desplazamiento
 *
 * Los operandos de desplazamiento deben ser tipos integrales pequeños
 * para evitar comportamiento indefinido.
 */
template <typename T>
concept valid_shift_type = std::integral<T> && sizeof(T) <= 8;

/**
 * @brief Concept para tipos que pueden usarse como índices de bit
 *
 * @tparam T Tipo del índice
 *
 * Los índices de bit deben ser tipos enteros no negativos.
 * Para int128_base_t, se refiere a posiciones 0-127.
 */
template <typename T>
concept bit_index_type = std::unsigned_integral<T> && sizeof(T) <= 8;

/**
 * @brief Concept para tipos que pueden usarse en comparaciones con int128_base_t
 *
 * @tparam T Tipo a comparar
 *
 * Las comparaciones son seguras con tipos integrales e int128_base_t.
 */
template <typename T>
concept int128_comparable = std::integral<T> || int128_type<T>;

// =============================================================================
// CONCEPTOS PARA METAPROGRAMACIÓN
// =============================================================================

/**
 * @brief Concept que verifica si un tipo puede ser promovido a int128_base_t
 *
 * @tparam T Tipo a verificar
 *
 * Un tipo puede ser promovido si es un tipo integral estándar.
 */
template <typename T>
concept promotable_to_int128 = std::integral<T> && sizeof(T) <= 16 && !int128_type<T>;

/**
 * @brief Concept para funciones que pueden operar sobre int128_base_t
 *
 * @tparam F Tipo de función
 * @tparam T Tipo int128_base_t<S>
 * @tparam Args Tipos de argumentos adicionales
 */
template <typename F, typename T, typename... Args>
concept int128_function = int128_type<T> && requires(F f, T val, Args... args) { f(val, args...); };

/**
 * @brief Concept para contenedores de int128_base_t
 *
 * @tparam Container Tipo de contenedor
 * @tparam T Tipo int128_base_t<S>
 */
template <typename Container, typename T>
concept int128_container = int128_type<T> && requires(Container c) {
    typename Container::value_type;
    requires std::same_as<typename Container::value_type, T>;
    c.begin();
    c.end();
    c.size();
};

// =============================================================================
// CONCEPTOS PARA ALGORITMOS
// =============================================================================

/**
 * @brief Concept para predicados que operan sobre int128_base_t
 *
 * @tparam Pred Tipo del predicado
 * @tparam T Tipo int128_base_t<S>
 */
template <typename Pred, typename T>
concept int128_predicate = int128_type<T> && requires(Pred p, T val) {
    { p(val) } -> std::convertible_to<bool>;
};

/**
 * @brief Concept para operaciones binarias sobre int128_base_t
 *
 * @tparam BinaryOp Tipo de la operación binaria
 * @tparam T Tipo int128_base_t<S>
 */
template <typename BinaryOp, typename T>
concept int128_binary_operation = int128_type<T> && requires(BinaryOp op, T a, T b) { op(a, b); };

/**
 * @brief Concept para operaciones de reducción sobre int128_base_t
 *
 * @tparam ReduceOp Tipo de la operación de reducción
 * @tparam T Tipo int128_base_t<S>
 * @tparam Acc Tipo del acumulador
 */
template <typename ReduceOp, typename T, typename Acc>
concept int128_reduce_operation = int128_type<T> && requires(ReduceOp op, Acc acc, T val) {
    { op(acc, val) } -> std::convertible_to<Acc>;
};

/**
 * @brief Concept para operaciones matemáticas seguras
 *
 * @tparam MathOp Tipo de la operación matemática
 * @tparam T Tipo int128_base_t<S>
 */
template <typename MathOp, typename T>
concept int128_safe_operation = int128_type<T> && requires(MathOp op, T a, T b) {
    { op(a, b) } -> std::same_as<T>;
};

// =============================================================================
// NAMESPACE ESPECÍFICOS POR TIPO (COMPATIBILIDAD)
// =============================================================================

/**
 * @brief Conceptos específicos para uint128_t (compatibilidad con código legacy)
 */
namespace uint128_concepts
{

using nstd::int128_t;
using nstd::uint128_t;

template <typename T>
concept uint128_convertible = std::integral<T> || std::same_as<T, uint128_t>;

template <typename T>
concept uint128_compatible = uint128_convertible<T> || std::floating_point<T>;

template <typename T>
concept uint128_bitwise_compatible = std::integral<T> || std::same_as<T, uint128_t>;

template <typename T>
concept uint128_comparable = std::integral<T> || std::same_as<T, uint128_t>;

template <typename T>
concept promotable_to_uint128 = std::integral<T> && sizeof(T) <= 16 && !std::same_as<T, uint128_t>;

template <typename Pred>
concept uint128_predicate = requires(Pred p, uint128_t u) {
    { p(u) } -> std::convertible_to<bool>;
};

template <typename BinaryOp>
concept uint128_binary_operation = requires(BinaryOp op, uint128_t a, uint128_t b) { op(a, b); };

template <typename Container>
concept uint128_container = requires(Container c) {
    typename Container::value_type;
    requires std::same_as<typename Container::value_type, uint128_t>;
    c.begin();
    c.end();
    c.size();
};

} // namespace uint128_concepts

/**
 * @brief Conceptos específicos para int128_t (compatibilidad con código legacy)
 */
namespace int128_concepts
{

using nstd::int128_t;
using nstd::uint128_t;

template <typename T>
concept int128_convertible = std::integral<T> || std::same_as<T, int128_t>;

template <typename T>
concept int128_compatible = int128_convertible<T> || std::floating_point<T>;

template <typename T>
concept int128_bitwise_compatible = std::integral<T> || std::same_as<T, int128_t>;

template <typename T>
concept int128_signed_compatible = std::signed_integral<T> || std::same_as<T, int128_t>;

template <typename T>
concept int128_comparable = std::integral<T> || std::same_as<T, int128_t>;

template <typename T>
concept promotable_to_int128 = std::integral<T> && sizeof(T) <= 16 && !std::same_as<T, int128_t>;

template <typename Pred>
concept int128_predicate = requires(Pred p, int128_t i) {
    { p(i) } -> std::convertible_to<bool>;
};

template <typename BinaryOp>
concept int128_binary_operation = requires(BinaryOp op, int128_t a, int128_t b) { op(a, b); };

template <typename Container>
concept int128_container = requires(Container c) {
    typename Container::value_type;
    requires std::same_as<typename Container::value_type, int128_t>;
    c.begin();
    c.end();
    c.size();
};

} // namespace int128_concepts

// =============================================================================
// VERIFICACIONES ESTÁTICAS DE CONFORMIDAD STL
// =============================================================================

namespace int128_concept_checks
{

// --- Verificaciones para uint128_t ---
static_assert(std::regular<uint128_t>, "uint128_t debe satisfacer std::regular");
static_assert(std::totally_ordered<uint128_t>, "uint128_t debe satisfacer std::totally_ordered");
static_assert(std::equality_comparable<uint128_t>, "uint128_t debe ser comparable por igualdad");
static_assert(std::default_initializable<uint128_t>, "uint128_t debe ser default-constructible");
static_assert(std::copy_constructible<uint128_t>, "uint128_t debe ser copy-constructible");
static_assert(std::move_constructible<uint128_t>, "uint128_t debe ser move-constructible");
static_assert(std::assignable_from<uint128_t&, const uint128_t&>,
              "uint128_t debe soportar asignación");

// --- Verificaciones para int128_t ---
static_assert(std::regular<int128_t>, "int128_t debe satisfacer std::regular");
static_assert(std::totally_ordered<int128_t>, "int128_t debe satisfacer std::totally_ordered");
static_assert(std::equality_comparable<int128_t>, "int128_t debe ser comparable por igualdad");
static_assert(std::default_initializable<int128_t>, "int128_t debe ser default-constructible");
static_assert(std::copy_constructible<int128_t>, "int128_t debe ser copy-constructible");
static_assert(std::move_constructible<int128_t>, "int128_t debe ser move-constructible");
static_assert(std::assignable_from<int128_t&, const int128_t&>,
              "int128_t debe soportar asignación");

// --- Verificaciones de tamaño ---
static_assert(sizeof(uint128_t) == 16, "uint128_t debe tener 128 bits");
static_assert(sizeof(int128_t) == 16, "int128_t debe tener 128 bits");

// --- Verificaciones de signedness ---
static_assert(int128_t(-1) < int128_t(0), "int128_t debe manejar valores negativos");
static_assert(int128_t(1) > int128_t(0), "int128_t debe manejar valores positivos");

// --- Verificaciones de nuestros type traits ---
static_assert(is_128bit_type_v<uint128_t>, "uint128_t debe ser detectado como tipo 128-bit");
static_assert(is_128bit_type_v<int128_t>, "int128_t debe ser detectado como tipo 128-bit");
static_assert(is_uint128_v<uint128_t>, "uint128_t debe ser detectado como uint128");
static_assert(!is_uint128_v<int128_t>, "int128_t no debe ser detectado como uint128");
static_assert(is_int128_v<int128_t>, "int128_t debe ser detectado como int128");
static_assert(!is_int128_v<uint128_t>, "uint128_t no debe ser detectado como int128");

// --- Verificaciones de nuestros concepts ---
static_assert(int128_type<uint128_t>, "uint128_t debe satisfacer int128_type");
static_assert(int128_type<int128_t>, "int128_t debe satisfacer int128_type");
static_assert(uint128_type<uint128_t>, "uint128_t debe satisfacer uint128_type");
static_assert(!uint128_type<int128_t>, "int128_t no debe satisfacer uint128_type");
static_assert(signed_int128_type<int128_t>, "int128_t debe satisfacer signed_int128_type");
static_assert(!signed_int128_type<uint128_t>, "uint128_t no debe satisfacer signed_int128_type");

} // namespace int128_concept_checks

} // namespace nstd

#endif // INT128_BASE_CONCEPTS_HPP
