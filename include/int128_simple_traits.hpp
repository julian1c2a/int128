/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once
#ifndef INT128_SIMPLE_TRAITS_HPP
#define INT128_SIMPLE_TRAITS_HPP

/**
 * @brief Header de conveniencia que incluye todas las especializaciones de traits
 *
 * Este archivo incluye todos los módulos de traits necesarios para que int128_t
 * sea completamente compatible con la biblioteca estándar de C++.
 *
 * Para usar las funcionalidades completas de int128_t, simplemente incluir:
 * #include "int128_simple_traits.hpp"
 */

// Incluir módulos en orden correcto de dependencia

// 1. Módulos fundamentales primero
#include "int128_limits.hpp" // std::numeric_limits<int128_t>
#include "int128_t.hpp"      // Implementación core de int128_t

// 2. Type traits y sistema de tipos
#include "int128_traits.hpp" // std::is_integral, is_signed, make_unsigned, etc.

// 3. Funciones numéricas y matemáticas
#include "int128_cmath.hpp"   // std::pow, sqrt, sign, divmod, etc.
#include "int128_numeric.hpp" // std::midpoint, abs, clamp, popcount, gcd, lcm

// 4. Manipulación de bits
#include "int128_bits.hpp" // std::popcount, bit_width, int128_bits:: funciones

// 5. Algoritmos y rangos especializados
#include "int128_ranges.hpp" // std::iota, accumulate, partial_sum especializadas

// 6. Formateo e iostream
#include "int128_format.hpp"    // Funciones de formateo avanzado
#include "int128_iostreams.hpp" // Operadores << >> con soporte completo iomanip

/**
 * @brief Verificaciones de compilación
 *
 * Estas verificaciones se ejecutan en tiempo de compilación para
 * asegurar que todas las especializaciones están correctamente definidas
 * para int128_t.
 */
namespace int128_simple_traits_checks
{

// ===== VERIFICACIONES BÁSICAS =====

// Verificar que los límites están disponibles
static_assert(std::numeric_limits<int128_t>::is_specialized,
              "std::numeric_limits<int128_t> debe estar especializado");

// Verificar traits básicos
static_assert(std::is_integral_v<int128_t>, "int128_t debe ser reconocido como integral");
static_assert(std::is_signed_v<int128_t>, "int128_t debe ser reconocido como signed");
static_assert(std::is_arithmetic_v<int128_t>, "int128_t debe ser reconocido como arithmetic");

// Verificar conversiones de tipo
static_assert(std::is_same_v<std::make_signed_t<int128_t>, int128_t>,
              "make_signed<int128_t> debe ser int128_t");
static_assert(std::is_same_v<std::make_unsigned_t<int128_t>, uint128_t>,
              "make_unsigned<int128_t> debe ser uint128_t");

// ===== VERIFICACIONES DE LÍMITES =====

// Verificar que los límites son correctos para entero con signo de 128 bits
static_assert(std::numeric_limits<int128_t>::digits == 127,
              "int128_t debe tener 127 bits significativos (sin contar signo)");
static_assert(std::numeric_limits<int128_t>::is_signed == true,
              "int128_t debe estar marcado como signed");
static_assert(std::numeric_limits<int128_t>::is_modulo == false,
              "int128_t no debe ser modulo (overflow es undefined behavior)");

// ===== VERIFICACIONES C++20 CONCEPTS =====

#if __cpp_concepts >= 201907L
// Verificar conceptos C++20 si están disponibles
static_assert(std::integral<int128_t>, "int128_t debe satisfacer std::integral");
static_assert(std::signed_integral<int128_t>, "int128_t debe satisfacer std::signed_integral");
static_assert(std::regular<int128_t>, "int128_t debe satisfacer std::regular");
static_assert(std::totally_ordered<int128_t>, "int128_t debe satisfacer std::totally_ordered");
#endif

// ===== VERIFICACIONES DE INTEROPERABILIDAD =====

// Verificar que puede trabajar con uint128_t
static_assert(std::is_same_v<std::common_type_t<int128_t, uint128_t>, uint128_t>,
              "common_type entre int128_t y uint128_t debe ser uint128_t");

// Verificar conversiones con tipos estándar
static_assert(std::is_same_v<std::common_type_t<int128_t, int64_t>, int128_t>,
              "common_type entre int128_t e int64_t debe ser int128_t");
static_assert(std::is_same_v<std::common_type_t<int128_t, uint64_t>, int128_t>,
              "common_type entre int128_t y uint64_t debe ser int128_t");

// ===== VERIFICACIONES DE FUNCIONALIDAD =====

// Verificar que se puede usar con algoritmos STL básicos
// Estas son verificaciones implícitas - si compilan, los traits están bien

// Para std::sort necesitamos comparison operators
static_assert(std::three_way_comparable<int128_t> || (requires(int128_t a, int128_t b) {
                  { a < b } -> std::convertible_to<bool>;
                  { a == b } -> std::convertible_to<bool>;
              }), "int128_t debe tener operadores de comparación para std::sort");

// Para std::accumulate necesitamos operator+
static_assert(
    requires(int128_t a, int128_t b) {
        { a + b } -> std::convertible_to<int128_t>;
    }, "int128_t debe tener operator+ para std::accumulate");

} // namespace int128_simple_traits_checks

/**
 * @brief Namespace de conveniencia para usar literales y funciones
 */
namespace int128_convenience
{
// Exponer los literales de usuario de int128_t
using int128_literals::operator""_i128;
using int128_literals::operator""_I128;

// Exponer funciones de formateo comunes
using int128_format::dec;
using int128_format::dec_signed;
using int128_format::hex;
using int128_format::oct;

// Exponer funciones de rango útiles
using int128_ranges::calculate_stats;
using int128_ranges::generate_arithmetic_sequence;
using int128_ranges::generate_geometric_sequence;
} // namespace int128_convenience

// ===== CONFIRMACIÓN FINAL =====

/**
 * @brief Compiletime confirmation que todo está configurado correctamente
 */
constexpr bool int128_traits_complete = true;

/**
 * @brief Función de verificación que se puede llamar en tiempo de ejecución
 */
inline bool verify_int128_traits_at_runtime()
{
    // Test básico de funcionalidad
    int128_t test_val = int128_t(42);

    // Verificar que las operaciones básicas funcionan
    bool basic_ops = (test_val + test_val == int128_t(84)) &&
                     (test_val * int128_t(2) == int128_t(84)) && (test_val < int128_t(100)) &&
                     (!test_val.is_zero());

    // Verificar que los límites son accesibles
    bool limits_ok = (std::numeric_limits<int128_t>::max() > int128_t(0)) &&
                     (std::numeric_limits<int128_t>::min() < int128_t(0));

    // Verificar que las funciones matemáticas funcionan
    bool math_ok = (std::abs(int128_t(-42)) == int128_t(42)) &&
                   (std::gcd(int128_t(48), int128_t(18)) == int128_t(6));

    return basic_ops && limits_ok && math_ok;
}

#endif // INT128_SIMPLE_TRAITS_HPP