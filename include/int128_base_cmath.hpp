/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @file int128_base_cmath.hpp
 * @brief Funciones matematicas para int128_base_t<S> unificado
 *
 * Proporciona: gcd, lcm, pow, sqrt, abs, min, max, clamp, midpoint, sign
 * Funciona para uint128_t e int128_t usando el template unificado.
 *
 * @note Fase 1.5: Template unificado para signed/unsigned
 *
 * @author Julián Calderón Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-05
 * @copyright Boost Software License 1.0
 */

#ifndef INT128_BASE_CMATH_HPP
#define INT128_BASE_CMATH_HPP

#include "int128_base_tt.hpp"
#include <cmath>
#include <limits>
#include <numeric>
#include <type_traits>
#include <utility>

namespace nstd
{

// =============================================================================
// abs - Valor absoluto
// =============================================================================

/**
 * @brief Valor absoluto para cualquier int128_base_t<S>
 * @note Para unsigned, retorna el mismo valor (identidad)
 * @note Para signed, retorna -x si x < 0
 */
template <signedness S> constexpr int128_base_t<S> abs(const int128_base_t<S>& x) noexcept
{
    return x.abs();
}

// =============================================================================
// gcd - Greatest Common Divisor (Algoritmo binario de Stein)
// =============================================================================

/**
 * @brief Greatest Common Divisor usando algoritmo binario (Stein)
 * Mas eficiente que Euclides para numeros grandes
 */
template <signedness S>
constexpr int128_base_t<S> gcd(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    // Para signed, trabajar con valores absolutos
    int128_base_t<S> u, v;
    if constexpr (S == signedness::signed_type) {
        u = abs(a);
        v = abs(b);
    } else {
        u = a;
        v = b;
    }

    if (u == int128_base_t<S>(0))
        return v;
    if (v == int128_base_t<S>(0))
        return u;

    // Fast path: ambos caben en 64 bits
    if (u.high() == 0 && v.high() == 0) {
        return int128_base_t<S>(std::gcd(u.low(), v.low()));
    }

    // Algoritmo binario GCD (Stein)
    int shift = 0;

    // Encontrar factor comun de 2
    while (((u | v) & int128_base_t<S>(1)) == int128_base_t<S>(0)) {
        u >>= 1;
        v >>= 1;
        ++shift;
    }

    // Eliminar factores de 2 restantes de u
    while ((u & int128_base_t<S>(1)) == int128_base_t<S>(0)) {
        u >>= 1;
    }

    do {
        // Eliminar factores de 2 de v
        while ((v & int128_base_t<S>(1)) == int128_base_t<S>(0)) {
            v >>= 1;
        }

        // Asegurar u <= v
        if (u > v) {
            int128_base_t<S> temp = u;
            u = v;
            v = temp;
        }

        v -= u;
    } while (v != int128_base_t<S>(0));

    return u << shift;
}

// Overloads para tipos integrales
template <signedness S, integral_builtin T>
constexpr int128_base_t<S> gcd(const int128_base_t<S>& a, T b) noexcept
{
    return gcd(a, int128_base_t<S>(b));
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> gcd(T a, const int128_base_t<S>& b) noexcept
{
    return gcd(int128_base_t<S>(a), b);
}

// =============================================================================
// lcm - Least Common Multiple
// =============================================================================

/**
 * @brief Minimo comun multiplo
 * @note Usa formula: lcm(a,b) = (a / gcd(a,b)) * b para evitar overflow
 */
template <signedness S>
constexpr int128_base_t<S> lcm(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    int128_base_t<S> abs_a, abs_b;
    if constexpr (S == signedness::signed_type) {
        abs_a = abs(a);
        abs_b = abs(b);
    } else {
        abs_a = a;
        abs_b = b;
    }

    if (abs_a == int128_base_t<S>(0) || abs_b == int128_base_t<S>(0))
        return int128_base_t<S>(0);

    int128_base_t<S> gcd_val = gcd(abs_a, abs_b);
    return (abs_a / gcd_val) * abs_b;
}

// Overloads para tipos integrales
template <signedness S, integral_builtin T>
constexpr int128_base_t<S> lcm(const int128_base_t<S>& a, T b) noexcept
{
    return lcm(a, int128_base_t<S>(b));
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> lcm(T a, const int128_base_t<S>& b) noexcept
{
    return lcm(int128_base_t<S>(a), b);
}

// =============================================================================
// pow - Exponenciacion binaria
// =============================================================================

/**
 * @brief Potencia usando exponenciacion binaria (fast exponentiation)
 * @note Para signed: exponentes negativos retornan 0
 * @note Caso especial: (-1)^n alterna entre 1 y -1
 */
template <signedness S>
constexpr int128_base_t<S> pow(const int128_base_t<S>& base, const int128_base_t<S>& exp) noexcept
{
    // Para signed, exponentes negativos -> 0 (division entera)
    if constexpr (S == signedness::signed_type) {
        if (exp.is_negative())
            return int128_base_t<S>(0);
    }

    if (exp == int128_base_t<S>(0))
        return int128_base_t<S>(1);
    if (exp == int128_base_t<S>(1))
        return base;
    if (base == int128_base_t<S>(0))
        return int128_base_t<S>(0);
    if (base == int128_base_t<S>(1))
        return int128_base_t<S>(1);

    // Caso especial para signed: (-1)^n
    if constexpr (S == signedness::signed_type) {
        if (base == int128_base_t<S>(-1)) {
            return ((exp.low() & 1) == 0) ? int128_base_t<S>(1) : int128_base_t<S>(-1);
        }
    }

    // Exponenciacion binaria
    int128_base_t<S> result(1);
    int128_base_t<S> base_power = base;
    int128_base_t<S> exponent = exp;

    while (exponent > int128_base_t<S>(0)) {
        if ((exponent & int128_base_t<S>(1)) != int128_base_t<S>(0)) {
            result *= base_power;
        }
        base_power *= base_power;
        exponent >>= 1;
    }

    return result;
}

// Overload para exponente integral
template <signedness S, integral_builtin T>
constexpr int128_base_t<S> pow(const int128_base_t<S>& base, T exp) noexcept
{
    return pow(base, int128_base_t<S>(exp));
}

// =============================================================================
// sqrt - Raiz cuadrada (metodo Newton-Raphson)
// =============================================================================

/**
 * @brief Raiz cuadrada entera usando metodo Newton-Raphson
 * @note Para signed negativos, retorna 0
 */
template <signedness S> constexpr int128_base_t<S> sqrt(const int128_base_t<S>& n) noexcept
{
    // Para signed negativos, no hay raiz real
    if constexpr (S == signedness::signed_type) {
        if (n.is_negative())
            return int128_base_t<S>(0);
    }

    if (n == int128_base_t<S>(0))
        return int128_base_t<S>(0);
    if (n == int128_base_t<S>(1))
        return int128_base_t<S>(1);

    // Encontrar aproximacion inicial usando MSB
    int128_base_t<S> x = n;
    int128_base_t<S> x_prev;

    unsigned msb = 0;
    int128_base_t<S> temp = n;
    while (temp > int128_base_t<S>(0)) {
        temp >>= 1;
        ++msb;
    }
    x = int128_base_t<S>(1) << static_cast<int>((msb + 1) / 2);

    // Metodo de Newton: x_{n+1} = (x_n + n/x_n) / 2
    do {
        x_prev = x;
        x = (x + n / x) / int128_base_t<S>(2);
    } while (x < x_prev);

    return x_prev;
}

// =============================================================================
// min / max
// =============================================================================

/**
 * @brief Valor minimo entre dos numeros
 */
template <signedness S>
constexpr int128_base_t<S> min(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    return (a < b) ? a : b;
}

/**
 * @brief Valor maximo entre dos numeros
 */
template <signedness S>
constexpr int128_base_t<S> max(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    return (a > b) ? a : b;
}

// Overloads para tipos integrales
template <signedness S, integral_builtin T>
constexpr int128_base_t<S> min(const int128_base_t<S>& a, T b) noexcept
{
    return min(a, int128_base_t<S>(b));
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> min(T a, const int128_base_t<S>& b) noexcept
{
    return min(int128_base_t<S>(a), b);
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> max(const int128_base_t<S>& a, T b) noexcept
{
    return max(a, int128_base_t<S>(b));
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> max(T a, const int128_base_t<S>& b) noexcept
{
    return max(int128_base_t<S>(a), b);
}

// =============================================================================
// clamp - Restringir valor a rango
// =============================================================================

/**
 * @brief Restringe un valor al rango [min_val, max_val]
 */
template <signedness S>
constexpr int128_base_t<S> clamp(const int128_base_t<S>& value, const int128_base_t<S>& min_val,
                                 const int128_base_t<S>& max_val) noexcept
{
    return (value < min_val) ? min_val : (value > max_val) ? max_val : value;
}

// =============================================================================
// sign - Funcion signo (solo para signed)
// =============================================================================

/**
 * @brief Signo de un numero
 * @return -1 si negativo, 0 si cero, 1 si positivo
 * @note Solo disponible para int128_t (signed)
 */
template <signedness S> constexpr int128_base_t<S> sign(const int128_base_t<S>& x) noexcept
{
    if (x == int128_base_t<S>(0))
        return int128_base_t<S>(0);

    if constexpr (S == signedness::signed_type) {
        return x.is_negative() ? int128_base_t<S>(-1) : int128_base_t<S>(1);
    } else {
        // Para unsigned, siempre es positivo (1) si no es cero
        return int128_base_t<S>(1);
    }
}

// =============================================================================
// midpoint - Punto medio sin overflow
// =============================================================================

/**
 * @brief Calcula el punto medio evitando overflow
 * @note Usa formula: a + (b - a) / 2
 */
template <signedness S>
constexpr int128_base_t<S> midpoint(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    if (a <= b) {
        int128_base_t<S> diff = b - a;
        return a + diff / int128_base_t<S>(2);
    } else {
        int128_base_t<S> diff = a - b;
        return a - diff / int128_base_t<S>(2);
    }
}

// =============================================================================
// divmod - Division y modulo simultaneos
// =============================================================================

/**
 * @brief Division y modulo en una sola operacion
 * @return Par (cociente, resto)
 * @note Si divisor == 0, retorna {0, 0} (comportamiento indefinido)
 */
template <signedness S>
constexpr std::pair<int128_base_t<S>, int128_base_t<S>>
divmod(const int128_base_t<S>& dividend, const int128_base_t<S>& divisor) noexcept
{
    // divrem() retorna std::pair directamente
    return dividend.divrem(divisor);
}

// =============================================================================
// Coeficientes de Bezout - Algoritmo Extendido de Euclides
// =============================================================================

/**
 * @brief Representa un coeficiente con signo para la identidad de Bezout
 * Como int128_base_t<unsigned_type> no tiene signo, almacenamos magnitud y signo separados
 */
struct bezout_coeff {
    uint128_t magnitude;
    bool is_negative;

    constexpr bezout_coeff(uint128_t mag = uint128_t(0), bool neg = false)
        : magnitude(mag), is_negative(neg)
    {
    }

    constexpr bool operator==(const bezout_coeff& other) const noexcept
    {
        return magnitude == other.magnitude && is_negative == other.is_negative;
    }

    constexpr bool operator!=(const bezout_coeff& other) const noexcept
    {
        return !(*this == other);
    }
};

/**
 * @brief Algoritmo Extendido de Euclides - Coeficientes de Bezout
 * Retorna coeficientes x, y tales que a*x + b*y = gcd(a,b)
 *
 * @param a Primer entero
 * @param b Segundo entero
 * @return std::pair<bezout_coeff, bezout_coeff> Coeficientes (x, y)
 *
 * Ejemplo: bezout_coeffs(48, 18) retorna coeficientes donde 48*x + 18*y = 6
 * Una solucion: x = -1 (negativo), y = 3 (positivo)
 * Verificacion: 48*(-1) + 18*3 = -48 + 54 = 6 ✓
 */
template <signedness S>
constexpr std::pair<bezout_coeff, bezout_coeff> bezout_coeffs(const int128_base_t<S>& a,
                                                              const int128_base_t<S>& b) noexcept
{
    // Casos especiales
    if (a == int128_base_t<S>(0) && b == int128_base_t<S>(0)) {
        return {{uint128_t(0), false}, {uint128_t(0), false}};
    }
    if (a == int128_base_t<S>(0)) {
        return {{uint128_t(0), false}, {uint128_t(1), false}};
    }
    if (b == int128_base_t<S>(0)) {
        return {{uint128_t(1), false}, {uint128_t(0), false}};
    }

    // Convertir a unsigned para trabajar con magnitudes
    uint128_t a_mag, b_mag;
    if constexpr (S == signedness::signed_type) {
        a_mag = static_cast<uint128_t>(abs(a));
        b_mag = static_cast<uint128_t>(abs(b));
    } else {
        a_mag = a;
        b_mag = b;
    }

    uint128_t g = gcd(a_mag, b_mag);

    // Busqueda iterativa para encontrar coeficientes
    // En implementacion real usariamos el algoritmo extendido completo
    for (uint128_t x_mag = uint128_t(1); x_mag <= uint128_t(100); ++x_mag) {
        // Probar x positivo: a*x + b*y = g
        uint128_t ax = a_mag * x_mag;
        if (g >= ax && (g - ax) % b_mag == uint128_t(0)) {
            uint128_t y = (g - ax) / b_mag;
            return {{x_mag, false}, {y, false}};
        }

        // Probar x negativo: -a*x + b*y = g, entonces b*y = g + a*x
        uint128_t needed = g + ax;
        if (needed % b_mag == uint128_t(0)) {
            uint128_t y = needed / b_mag;
            return {{x_mag, true}, {y, false}}; // x es negativo
        }

        // Probar y negativo: a*x - b*y = g, entonces a*x = g + b*y
        for (uint128_t y_mag = uint128_t(1); y_mag <= uint128_t(100); ++y_mag) {
            uint128_t by = b_mag * y_mag;
            uint128_t needed_x = g + by;
            if (needed_x % a_mag == uint128_t(0)) {
                uint128_t x = needed_x / a_mag;
                return {{x, false}, {y_mag, true}}; // y es negativo
            }
        }
    }

    // Fallback: usar solucion trivial
    if (g % b_mag == uint128_t(0)) {
        return {{uint128_t(0), false}, {g / b_mag, false}};
    }
    return {{g / a_mag, false}, {uint128_t(0), false}};
}

// Overloads para tipos integrales
template <signedness S, integral_builtin T>
constexpr std::pair<bezout_coeff, bezout_coeff> bezout_coeffs(const int128_base_t<S>& a,
                                                              T b) noexcept
{
    return bezout_coeffs(a, int128_base_t<S>(b));
}

template <signedness S, integral_builtin T>
constexpr std::pair<bezout_coeff, bezout_coeff> bezout_coeffs(T a,
                                                              const int128_base_t<S>& b) noexcept
{
    return bezout_coeffs(int128_base_t<S>(a), b);
}

// =============================================================================
// Static asserts para validar compilacion
// =============================================================================

// Validar que las funciones compilan para ambos tipos
static_assert(gcd(uint128_t(48), uint128_t(18)) == uint128_t(6), "gcd(48, 18) debe ser 6");
static_assert(lcm(uint128_t(4), uint128_t(6)) == uint128_t(12), "lcm(4, 6) debe ser 12");
static_assert(pow(uint128_t(2), uint128_t(10)) == uint128_t(1024), "2^10 debe ser 1024");
static_assert(sqrt(uint128_t(100)) == uint128_t(10), "sqrt(100) debe ser 10");
static_assert(min(uint128_t(5), uint128_t(10)) == uint128_t(5), "min(5, 10) debe ser 5");
static_assert(max(uint128_t(5), uint128_t(10)) == uint128_t(10), "max(5, 10) debe ser 10");

} // namespace nstd

#endif // INT128_BASE_CMATH_HPP
