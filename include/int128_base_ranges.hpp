/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_BASE_RANGES_HPP
#define INT128_BASE_RANGES_HPP

/**
 * @file int128_base_ranges.hpp
 * @brief Funciones auxiliares para operaciones con rangos sobre int128_base_t<S>
 *
 * @note std::ranges:: ya funciona con int128_base_t<S> gracias a los conceptos.
 *       Este archivo proporciona funciones auxiliares adicionales específicas
 *       para trabajar con secuencias de enteros de 128 bits.
 *
 * @author Julián Calderón Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-08
 * @copyright Boost Software License 1.0
 */

#include "int128_base_tt.hpp"
#include <cstddef>
#include <iterator>
#include <optional>

namespace nstd
{

namespace int128_ranges
{

// =============================================================================
// GENERADORES DE SECUENCIAS
// =============================================================================

/**
 * @brief Genera una secuencia aritmética de int128_base_t<S>
 *
 * Llena el rango [first, last) con valores: start, start+step, start+2*step, ...
 *
 * @tparam S signedness del tipo
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param start Valor inicial de la secuencia
 * @param step Incremento entre elementos consecutivos
 */
template <signedness S, typename OutputIt>
constexpr void generate_arithmetic_sequence(OutputIt first, OutputIt last,
                                            const int128_base_t<S>& start,
                                            const int128_base_t<S>& step)
{
    int128_base_t<S> current = start;
    while (first != last) {
        *first++ = current;
        current += step;
    }
}

/**
 * @brief Genera una secuencia aritmética con paso unitario (equivalente a std::iota)
 *
 * @tparam S signedness del tipo
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param start Valor inicial de la secuencia
 */
template <signedness S, typename OutputIt>
constexpr void iota(OutputIt first, OutputIt last, const int128_base_t<S>& start)
{
    generate_arithmetic_sequence<S>(first, last, start, int128_base_t<S>(1));
}

/**
 * @brief Genera una secuencia geométrica de int128_base_t<S>
 *
 * Llena el rango [first, last) con valores: start, start*ratio, start*ratio^2, ...
 *
 * @tparam S signedness del tipo
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param start Valor inicial de la secuencia
 * @param ratio Factor multiplicativo entre elementos consecutivos
 *
 * @warning Puede producir overflow silencioso si los valores crecen demasiado
 */
template <signedness S, typename OutputIt>
constexpr void generate_geometric_sequence(OutputIt first, OutputIt last,
                                           const int128_base_t<S>& start,
                                           const int128_base_t<S>& ratio)
{
    int128_base_t<S> current = start;
    while (first != last) {
        *first++ = current;
        current *= ratio;
    }
}

/**
 * @brief Genera una secuencia de potencias de 2
 *
 * Llena el rango [first, last) con: 2^start_exp, 2^(start_exp+1), ...
 *
 * @tparam S signedness del tipo
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param start_exp Exponente inicial (default: 0)
 */
template <signedness S, typename OutputIt>
constexpr void generate_powers_of_2(OutputIt first, OutputIt last, int start_exp = 0)
{
    int128_base_t<S> current = int128_base_t<S>(1) << start_exp;
    while (first != last) {
        *first++ = current;
        current <<= 1;
    }
}

// =============================================================================
// ESTADÍSTICAS DE RANGOS
// =============================================================================

/**
 * @brief Estructura para almacenar estadísticas de un rango
 * @tparam S signedness del tipo
 */
template <signedness S> struct range_stats {
    int128_base_t<S> sum{};
    int128_base_t<S> min_val{};
    int128_base_t<S> max_val{};
    std::size_t count = 0;
    bool valid = false;

    /// @brief Calcula el promedio (truncado a entero)
    constexpr int128_base_t<S> average() const noexcept
    {
        if (count == 0)
            return int128_base_t<S>(0);
        return sum / int128_base_t<S>(static_cast<uint64_t>(count));
    }

    /// @brief Calcula el rango (max - min)
    constexpr int128_base_t<S> range() const noexcept
    {
        return max_val - min_val;
    }
};

/**
 * @brief Calcula estadísticas básicas de un rango
 *
 * @tparam S signedness del tipo
 * @tparam InputIt Tipo de iterador de entrada
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return range_stats<S> con suma, min, max y count
 */
template <signedness S, typename InputIt>
constexpr range_stats<S> calculate_stats(InputIt first, InputIt last)
{
    range_stats<S> stats;

    if (first == last) {
        return stats; // invalid (count=0, valid=false)
    }

    stats.min_val = *first;
    stats.max_val = *first;
    stats.sum = *first;
    stats.count = 1;
    stats.valid = true;

    while (++first != last) {
        const auto& val = *first;
        stats.sum += val;

        if (val < stats.min_val) {
            stats.min_val = val;
        }
        if (val > stats.max_val) {
            stats.max_val = val;
        }
        ++stats.count;
    }

    return stats;
}

// =============================================================================
// FUNCIONES DE BÚSQUEDA ESPECIALIZADAS
// =============================================================================

/**
 * @brief Encuentra el primer valor que cumple un predicado
 *
 * @tparam S signedness del tipo
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam Pred Tipo del predicado
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado unario que retorna bool
 * @return std::optional con el valor encontrado, o std::nullopt si no existe
 */
template <signedness S, typename InputIt, typename Pred>
constexpr std::optional<int128_base_t<S>> find_first_if(InputIt first, InputIt last, Pred pred)
{
    while (first != last) {
        if (pred(*first)) {
            return *first;
        }
        ++first;
    }
    return std::nullopt;
}

/**
 * @brief Cuenta elementos que cumplen un predicado
 *
 * @tparam S signedness del tipo
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam Pred Tipo del predicado
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado unario que retorna bool
 * @return Número de elementos que cumplen el predicado
 */
template <signedness S, typename InputIt, typename Pred>
constexpr std::size_t count_if(InputIt first, InputIt last, Pred pred)
{
    std::size_t count = 0;
    while (first != last) {
        if (pred(*first)) {
            ++count;
        }
        ++first;
    }
    return count;
}

// =============================================================================
// TRANSFORMACIONES
// =============================================================================

/**
 * @brief Aplica una función a cada elemento y almacena el resultado
 *
 * @tparam S signedness del tipo
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam OutputIt Tipo de iterador de salida
 * @tparam UnaryOp Tipo de la operación unaria
 * @param first Iterador al inicio del rango de entrada
 * @param last Iterador al final del rango de entrada
 * @param d_first Iterador al inicio del rango de salida
 * @param op Operación unaria a aplicar
 * @return Iterador al final del rango de salida
 */
template <signedness S, typename InputIt, typename OutputIt, typename UnaryOp>
constexpr OutputIt transform(InputIt first, InputIt last, OutputIt d_first, UnaryOp op)
{
    while (first != last) {
        *d_first++ = op(*first++);
    }
    return d_first;
}

/**
 * @brief Filtra elementos que cumplen un predicado
 *
 * @tparam S signedness del tipo
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam OutputIt Tipo de iterador de salida
 * @tparam Pred Tipo del predicado
 * @param first Iterador al inicio del rango de entrada
 * @param last Iterador al final del rango de entrada
 * @param d_first Iterador al inicio del rango de salida
 * @param pred Predicado que determina qué elementos copiar
 * @return Iterador al final del rango de salida
 */
template <signedness S, typename InputIt, typename OutputIt, typename Pred>
constexpr OutputIt copy_if(InputIt first, InputIt last, OutputIt d_first, Pred pred)
{
    while (first != last) {
        if (pred(*first)) {
            *d_first++ = *first;
        }
        ++first;
    }
    return d_first;
}

// =============================================================================
// REDUCCIONES
// =============================================================================

/**
 * @brief Reduce un rango usando una operación binaria
 *
 * @tparam S signedness del tipo
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam BinaryOp Tipo de la operación binaria
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param init Valor inicial del acumulador
 * @param op Operación binaria (default: suma)
 * @return Resultado de la reducción
 */
template <signedness S, typename InputIt, typename BinaryOp>
constexpr int128_base_t<S> reduce(InputIt first, InputIt last, int128_base_t<S> init, BinaryOp op)
{
    while (first != last) {
        init = op(init, *first++);
    }
    return init;
}

/**
 * @brief Suma todos los elementos de un rango
 *
 * @tparam S signedness del tipo
 * @tparam InputIt Tipo de iterador de entrada
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Suma de todos los elementos
 */
template <signedness S, typename InputIt>
constexpr int128_base_t<S> sum(InputIt first, InputIt last)
{
    return reduce<S>(first, last, int128_base_t<S>(0),
                     [](const int128_base_t<S>& a, const int128_base_t<S>& b) { return a + b; });
}

/**
 * @brief Calcula el producto de todos los elementos de un rango
 *
 * @tparam S signedness del tipo
 * @tparam InputIt Tipo de iterador de entrada
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Producto de todos los elementos
 */
template <signedness S, typename InputIt>
constexpr int128_base_t<S> product(InputIt first, InputIt last)
{
    return reduce<S>(first, last, int128_base_t<S>(1),
                     [](const int128_base_t<S>& a, const int128_base_t<S>& b) { return a * b; });
}

} // namespace int128_ranges

} // namespace nstd

#endif // INT128_BASE_RANGES_HPP
