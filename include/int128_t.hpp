/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_T_HPP
#define INT128_T_HPP

#include "uint128_t.hpp"
#include <cstdint>
#include <istream>
#include <limits>
#include <ostream>
#include <string>
#include <type_traits>

/**
 * @brief Entero con signo de 128 bits
 *
 * Implementación de int128_t usando complemento a 2.
 * Rango: -2^127 a 2^127-1
 *
 * Usa la misma representación interna que uint128_t:
 * - data[0]: 64 bits bajos
 * - data[1]: 64 bits altos (MSB es bit de signo)
 */
class int128_t
{
  private:
    uint64_t data[2]; // [0] = low, [1] = high (MSB de [1] es signo)

  public:
    // ===============================================================================
    // CONSTRUCTORES
    // ===============================================================================

    /**
     * @brief Constructor por defecto (valor 0)
     */
    constexpr int128_t() noexcept : data{0, 0} {}

    /**
     * @brief Constructor desde enteros (cualquier tipo entero)
     */
    template <typename T>
    constexpr int128_t(T value) noexcept
        requires(std::is_integral_v<T> && !std::is_same_v<T, bool>)
        : data{0, 0}
    {
        if constexpr (std::is_signed_v<T>) {
            int64_t val = static_cast<int64_t>(value);
            data[0] = static_cast<uint64_t>(val);
            data[1] = val < 0 ? UINT64_MAX : 0;
        } else {
            uint64_t val = static_cast<uint64_t>(value);
            data[0] = val;
            data[1] = 0;
        }
    }

    /**
     * @brief Constructor desde dos uint64_t (high, low)
     */
    constexpr int128_t(uint64_t high, uint64_t low) noexcept : data{low, high} {}

    /**
     * @brief Constructor desde uint128_t (interpretación directa)
     */
    constexpr explicit int128_t(const uint128_t& value) noexcept : data{value.low(), value.high()}
    {
    }

    // ===============================================================================
    // ACCESSORS
    // ===============================================================================

    constexpr uint64_t low() const noexcept
    {
        return data[0];
    }
    constexpr uint64_t high() const noexcept
    {
        return data[1];
    }

    /**
     * @brief Verifica si el número es negativo
     */
    constexpr bool is_negative() const noexcept
    {
        return (data[1] & 0x8000000000000000ULL) != 0;
    }

    /**
     * @brief Verifica si el número es positivo (> 0)
     */
    constexpr bool is_positive() const noexcept
    {
        return !is_negative() && (*this != int128_t(0));
    }

    /**
     * @brief Verifica si el número es cero
     */
    constexpr bool is_zero() const noexcept
    {
        return data[0] == 0 && data[1] == 0;
    }

    // ===============================================================================
    // CONVERSIONES
    // ===============================================================================

    /**
     * @brief Convierte a uint128_t (interpretación directa de bits)
     */
    constexpr uint128_t to_uint128() const noexcept
    {
        return uint128_t(data[1], data[0]);
    }

    /**
     * @brief Valor absoluto
     */
    int128_t abs() const noexcept
    {
        if (is_negative()) {
            return -*this;
        }
        return *this;
    }

    /**
     * @brief Conversión a enteros (con overflow check)
     */
    template <typename T> constexpr T to() const
    {
        static_assert(std::is_integral<T>::value, "T must be an integral type");

        if constexpr (std::is_signed<T>::value) {
            // Para tipos con signo
            if constexpr (sizeof(T) >= 8) {
                // int64_t o mayor
                if (data[1] == 0 && (data[0] & 0x8000000000000000ULL) == 0) {
                    return static_cast<T>(data[0]);
                } else if (data[1] == UINT64_MAX && (data[0] & 0x8000000000000000ULL) != 0) {
                    return static_cast<T>(static_cast<int64_t>(data[0]));
                }
                // Overflow - devolver valor saturado
                return is_negative() ? std::numeric_limits<T>::min()
                                     : std::numeric_limits<T>::max();
            } else {
                // int32_t, int16_t, int8_t
                int64_t val64 = to<int64_t>();
                if (val64 > std::numeric_limits<T>::max())
                    return std::numeric_limits<T>::max();
                if (val64 < std::numeric_limits<T>::min())
                    return std::numeric_limits<T>::min();
                return static_cast<T>(val64);
            }
        } else {
            // Para tipos sin signo
            if (is_negative())
                return 0; // Negativo se convierte a 0
            return static_cast<T>(to_uint128());
        }
    }

    // ===============================================================================
    // OPERADORES ARITMÉTICOS UNARIOS
    // ===============================================================================

    /**
     * @brief Negación unaria (cambio de signo)
     */
    constexpr int128_t operator-() const noexcept
    {
        // Complemento a 2: ~x + 1
        uint64_t low_comp = ~data[0] + 1;
        uint64_t high_comp = ~data[1];
        if (low_comp == 0) { // carry
            high_comp++;
        }
        return int128_t(high_comp, low_comp);
    }

    /**
     * @brief Operador unario +
     */
    constexpr int128_t operator+() const noexcept
    {
        return *this;
    }

    // ===============================================================================
    // OPERADORES DE INCREMENTO/DECREMENTO
    // ===============================================================================

    /**
     * @brief Pre-incremento
     */
    int128_t& operator++() noexcept
    {
        if (++data[0] == 0) { // overflow en low
            ++data[1];
        }
        return *this;
    }

    /**
     * @brief Post-incremento
     */
    int128_t operator++(int) noexcept
    {
        int128_t temp = *this;
        ++(*this);
        return temp;
    }

    /**
     * @brief Pre-decremento
     */
    int128_t& operator--() noexcept
    {
        if (data[0]-- == 0) { // borrow
            --data[1];
        }
        return *this;
    }

    /**
     * @brief Post-decremento
     */
    int128_t operator--(int) noexcept
    {
        int128_t temp = *this;
        --(*this);
        return temp;
    }

    // ===============================================================================
    // OPERADORES ARITMÉTICOS BINARIOS
    // ===============================================================================

    /**
     * @brief Suma
     */
    constexpr int128_t operator+(const int128_t& other) const noexcept
    {
        uint64_t low_sum = data[0] + other.data[0];
        uint64_t high_sum = data[1] + other.data[1];
        if (low_sum < data[0]) { // carry
            high_sum++;
        }
        return int128_t(high_sum, low_sum);
    }

    /**
     * @brief Resta
     */
    constexpr int128_t operator-(const int128_t& other) const noexcept
    {
        return *this + (-other);
    }

    /**
     * @brief Multiplicación
     */
    int128_t operator*(const int128_t& other) const noexcept
    {
        // Determinar signos
        bool result_negative = is_negative() != other.is_negative();

        // Trabajar con valores absolutos
        uint128_t a = is_negative() ? (-*this).to_uint128() : to_uint128();
        uint128_t b = other.is_negative() ? (-other).to_uint128() : other.to_uint128();

        uint128_t result = a * b;

        // Aplicar signo
        if (result_negative) {
            return -int128_t(result);
        }
        return int128_t(result);
    }

    /**
     * @brief División
     */
    int128_t operator/(const int128_t& other) const
    {
        if (other.is_zero()) {
            throw std::domain_error("Division by zero");
        }

        // Casos especiales
        if (is_zero())
            return int128_t(0);
        if (other == int128_t(1))
            return *this;
        if (other == int128_t(-1))
            return -*this;

        // Determinar signo del resultado
        bool result_negative = is_negative() != other.is_negative();

        // Trabajar con valores absolutos
        uint128_t a = is_negative() ? (-*this).to_uint128() : to_uint128();
        uint128_t b = other.is_negative() ? (-other).to_uint128() : other.to_uint128();

        uint128_t result = a / b;

        // Aplicar signo
        if (result_negative) {
            return -int128_t(result);
        }
        return int128_t(result);
    }

    /**
     * @brief Módulo
     */
    int128_t operator%(const int128_t& other) const
    {
        if (other.is_zero()) {
            throw std::domain_error("Modulo by zero");
        }

        // El signo del resultado sigue al dividendo (estilo C++)
        bool result_negative = is_negative();

        // Trabajar con valores absolutos
        uint128_t a = is_negative() ? (-*this).to_uint128() : to_uint128();
        uint128_t b = other.is_negative() ? (-other).to_uint128() : other.to_uint128();

        uint128_t result = a % b;

        // Aplicar signo del dividendo
        if (result_negative && result != uint128_t(0)) {
            return -int128_t(result);
        }
        return int128_t(result);
    }

    // ===============================================================================
    // OPERADORES DE ASIGNACIÓN
    // ===============================================================================

    int128_t& operator+=(const int128_t& other) noexcept
    {
        return *this = *this + other;
    }
    int128_t& operator-=(const int128_t& other) noexcept
    {
        return *this = *this - other;
    }
    int128_t& operator*=(const int128_t& other) noexcept
    {
        return *this = *this * other;
    }
    int128_t& operator/=(const int128_t& other)
    {
        return *this = *this / other;
    }
    int128_t& operator%=(const int128_t& other)
    {
        return *this = *this % other;
    }

    // ===============================================================================
    // OPERADORES DE COMPARACIÓN
    // ===============================================================================

    /**
     * @brief Igualdad
     */
    constexpr bool operator==(const int128_t& other) const noexcept
    {
        return data[0] == other.data[0] && data[1] == other.data[1];
    }

    /**
     * @brief Desigualdad
     */
    constexpr bool operator!=(const int128_t& other) const noexcept
    {
        return !(*this == other);
    }

    /**
     * @brief Menor que (comparación con signo)
     */
    constexpr bool operator<(const int128_t& other) const noexcept
    {
        // Comparar signos primero
        bool this_neg = is_negative();
        bool other_neg = other.is_negative();

        if (this_neg && !other_neg)
            return true; // negativo < positivo
        if (!this_neg && other_neg)
            return false; // positivo >= negativo

        // Mismo signo - comparar como enteros con signo
        // Para complemento a 2, podemos comparar directamente high parts como signed
        int64_t this_high_signed = static_cast<int64_t>(data[1]);
        int64_t other_high_signed = static_cast<int64_t>(other.data[1]);

        if (this_high_signed != other_high_signed) {
            return this_high_signed < other_high_signed;
        }

        // High parts iguales, comparar low parts como unsigned
        return data[0] < other.data[0];
    }

    constexpr bool operator<=(const int128_t& other) const noexcept
    {
        return *this < other || *this == other;
    }
    constexpr bool operator>(const int128_t& other) const noexcept
    {
        return !(*this <= other);
    }
    constexpr bool operator>=(const int128_t& other) const noexcept
    {
        return !(*this < other);
    }

    // ===============================================================================
    // OPERADORES BIT A BIT
    // ===============================================================================

    constexpr int128_t operator&(const int128_t& other) const noexcept
    {
        return int128_t(data[1] & other.data[1], data[0] & other.data[0]);
    }

    constexpr int128_t operator|(const int128_t& other) const noexcept
    {
        return int128_t(data[1] | other.data[1], data[0] | other.data[0]);
    }

    constexpr int128_t operator^(const int128_t& other) const noexcept
    {
        return int128_t(data[1] ^ other.data[1], data[0] ^ other.data[0]);
    }

    constexpr int128_t operator~() const noexcept
    {
        return int128_t(~data[1], ~data[0]);
    }

    // ===============================================================================
    // SHIFTS (CON EXTENSIÓN DE SIGNO)
    // ===============================================================================

    /**
     * @brief Shift left (igual que uint128_t)
     */
    constexpr int128_t operator<<(int shift) const noexcept
    {
        if (shift <= 0)
            return *this;
        if (shift >= 128)
            return int128_t(0);

        if (shift >= 64) {
            return int128_t(data[0] << (shift - 64), 0);
        } else {
            uint64_t high_shifted = (data[1] << shift) | (data[0] >> (64 - shift));
            uint64_t low_shifted = data[0] << shift;
            return int128_t(high_shifted, low_shifted);
        }
    }

    /**
     * @brief Shift right aritmético (con extensión de signo)
     */
    constexpr int128_t operator>>(int shift) const noexcept
    {
        if (shift <= 0)
            return *this;
        if (shift >= 128) {
            // Extensión de signo completa
            return is_negative() ? int128_t(-1) : int128_t(0);
        }

        uint64_t sign_extension = is_negative() ? UINT64_MAX : 0;

        if (shift >= 64) {
            uint64_t low_shifted =
                static_cast<uint64_t>(static_cast<int64_t>(data[1]) >> (shift - 64));
            return int128_t(sign_extension, low_shifted);
        } else {
            uint64_t low_shifted = (data[0] >> shift) | (data[1] << (64 - shift));
            uint64_t high_shifted = static_cast<uint64_t>(static_cast<int64_t>(data[1]) >> shift);
            return int128_t(high_shifted, low_shifted);
        }
    }

    int128_t& operator<<=(int shift) noexcept
    {
        return *this = *this << shift;
    }
    int128_t& operator>>=(int shift) noexcept
    {
        return *this = *this >> shift;
    }

    int128_t& operator&=(const int128_t& other) noexcept
    {
        return *this = *this & other;
    }
    int128_t& operator|=(const int128_t& other) noexcept
    {
        return *this = *this | other;
    }
    int128_t& operator^=(const int128_t& other) noexcept
    {
        return *this = *this ^ other;
    }

    // ===============================================================================
    // CONVERSIONES A STRING
    // ===============================================================================

    /**
     * @brief Convierte a string decimal
     */
    std::string to_string() const
    {
        if (is_zero())
            return "0";

        if (is_negative()) {
            return "-" + (-*this).to_uint128().to_string();
        }

        return to_uint128().to_string();
    }

    /**
     * @brief Convierte a string en base específica
     */
    std::string to_string_base(int base) const
    {
        if (is_zero())
            return "0";

        if (is_negative()) {
            return "-" + (-*this).to_uint128().to_string_base(base);
        }

        return to_uint128().to_string_base(base);
    }

    // ===============================================================================
    // PARSING DESDE STRING
    // ===============================================================================

    /**
     * @brief Crea int128_t desde string decimal
     */
    static int128_t from_string(const std::string& str)
    {
        if (str.empty())
            throw std::invalid_argument("Empty string");

        bool negative = false;
        std::string digits = str;

        if (str[0] == '-') {
            negative = true;
            digits = str.substr(1);
        } else if (str[0] == '+') {
            digits = str.substr(1);
        }

        uint128_t magnitude = uint128_t::from_string(digits);
        int128_t result(magnitude);

        if (negative) {
            result = -result;
        }

        return result;
    }

    /**
     * @brief Crea int128_t desde string en base específica
     */
    static int128_t from_string_base(const std::string& str, int base)
    {
        if (str.empty())
            throw std::invalid_argument("Empty string");

        bool negative = false;
        std::string digits = str;

        if (str[0] == '-') {
            negative = true;
            digits = str.substr(1);
        } else if (str[0] == '+') {
            digits = str.substr(1);
        }

        uint128_t magnitude = uint128_t::from_string_base(digits, base);
        int128_t result(magnitude);

        if (negative) {
            result = -result;
        }

        return result;
    }
};

// ===============================================================================
// OPERADORES DE FLUJO
// ===============================================================================

inline std::ostream& operator<<(std::ostream& os, const int128_t& value)
{
    return os << value.to_string();
}

inline std::istream& operator>>(std::istream& is, int128_t& value)
{
    std::string str;
    is >> str;
    if (is.good() || is.eof()) {
        value = int128_t::from_string(str);
    }
    return is;
}

// ===============================================================================
// CONSTANTES
// ===============================================================================

constexpr int128_t int128_t_MAX = int128_t(0x7FFFFFFFFFFFFFFFULL, UINT64_MAX);
constexpr int128_t int128_t_MIN = int128_t(0x8000000000000000ULL, 0);

// ===============================================================================
// LITERALES DEFINIDOS POR EL USUARIO
// ===============================================================================

namespace int128_literals
{

constexpr int128_t operator""_i128(unsigned long long value) noexcept
{
    return int128_t(static_cast<int64_t>(value));
}

int128_t operator""_i128(const char* str, std::size_t len)
{
    return int128_t::from_string(std::string(str, len));
}

} // namespace int128_literals

#endif // INT128_T_HPP
