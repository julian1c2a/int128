/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_BASE_FORMAT_HPP
#define INT128_BASE_FORMAT_HPP

/**
 * @file int128_base_format.hpp
 * @brief Funciones de formateo avanzado para int128_base_t<S>
 *
 * Este header proporciona funciones de formateo avanzado que complementan
 * los operadores iostream basicos definidos en int128_base_tt.hpp.
 *
 * Diferencia con int128_base_iostreams.hpp:
 * - iostreams: Funciones de conveniencia simples usando ostringstream
 * - format: Formateo avanzado con control total de flags, alineacion, etc.
 *
 * Namespaces:
 * - int128_format::format() - Funcion principal con todos los parametros
 * - int128_format::hex() - Formateo hexadecimal
 * - int128_format::oct() - Formateo octal
 * - int128_format::dec() - Formateo decimal
 * - int128_format::dec_signed() - Decimal con signo siempre visible
 * - int128_format::format_like_iostream() - Imita flags de iostream
 *
 * @note Fase 1.5: Template unificado para signed/unsigned
 *
 * @author Julian Calderon Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-08
 * @copyright Boost Software License 1.0
 */

// Feature test macro
#define INT128_BASE_FORMAT_AVAILABLE 1

#include "int128_base_tt.hpp"
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

namespace nstd
{

namespace int128_format
{

// =============================================================================
// format_like_iostream - Imita el comportamiento de iostream con manipuladores
// =============================================================================

/**
 * @brief Formatea int128_base_t<S> imitando iostream con flags
 * @tparam S signedness del tipo
 * @param value Valor a formatear
 * @param flags Flags de formato (basefield, showbase, uppercase, adjustfield)
 * @param width Ancho minimo del campo
 * @param fill Caracter de relleno
 * @return String formateado
 */
template <signedness S>
inline std::string format_like_iostream(const int128_base_t<S>& value,
                                        std::ios_base::fmtflags flags, std::streamsize width = 0,
                                        char fill = ' ')
{
    const int base_flags = (flags & std::ios_base::basefield);
    const bool show_base = (flags & std::ios_base::showbase);
    const bool show_pos = (flags & std::ios_base::showpos);
    const bool uppercase = (flags & std::ios_base::uppercase);
    const auto alignment = (flags & std::ios_base::adjustfield);

    std::string result;
    bool is_negative = false;

    // Solo para tipos signed, verificar si es negativo
    if constexpr (S == signedness::signed_type) {
        is_negative = value.is_negative();
    }

    // Determinar la base numerica y generar el string base
    switch (base_flags) {
    case std::ios_base::hex: {
        // Para hex, usar to_string(16)
        if constexpr (S == signedness::signed_type) {
            if (is_negative) {
                // Complemento a 2 para negativos
                auto unsigned_val = static_cast<uint128_t>(value);
                result = unsigned_val.to_string(16);
            } else {
                result = value.to_string(16);
            }
        } else {
            result = value.to_string(16);
        }

        if (show_base) {
            result = (uppercase ? "0X" : "0x") + result;
        }

        if (uppercase) {
            for (char& c : result) {
                if (c >= 'a' && c <= 'f') {
                    c = static_cast<char>(c - 'a' + 'A');
                }
            }
        }
        break;
    }

    case std::ios_base::oct: {
        // Para oct, usar to_string(8)
        if constexpr (S == signedness::signed_type) {
            if (is_negative) {
                // Complemento a 2 para negativos
                auto unsigned_val = static_cast<uint128_t>(value);
                result = unsigned_val.to_string(8);
            } else {
                result = value.to_string(8);
            }
        } else {
            result = value.to_string(8);
        }

        if (show_base && result[0] != '0') {
            result = "0" + result;
        }
        break;
    }

    default: // std::ios_base::dec o sin especificar
        result = value.to_string();
        // Para decimales positivos con showpos
        if (!is_negative && show_pos) {
            result = "+" + result;
        }
        break;
    }

    // Aplicar ancho de campo y alineacion
    if (width > 0 && static_cast<std::streamsize>(result.length()) < width) {
        const size_t padding = static_cast<size_t>(width) - result.length();

        switch (alignment) {
        case std::ios_base::left:
            result += std::string(padding, fill);
            break;

        case std::ios_base::internal: {
            // El relleno va despues del prefijo/signo pero antes del numero
            size_t prefix_len = 0;

            // Detectar prefijo/signo
            if (result.length() >= 2 &&
                (result.substr(0, 2) == "0x" || result.substr(0, 2) == "0X")) {
                prefix_len = 2;
            } else if (result.length() >= 1 && (result[0] == '-' || result[0] == '+')) {
                prefix_len = 1;
            } else if (base_flags == std::ios_base::oct && show_base && result.length() >= 1 &&
                       result[0] == '0') {
                prefix_len = 1;
            }

            if (prefix_len > 0) {
                result = result.substr(0, prefix_len) + std::string(padding, fill) +
                         result.substr(prefix_len);
            } else {
                // Sin prefijo, actua como right
                result = std::string(padding, fill) + result;
            }
            break;
        }

        default: // std::ios_base::right o sin especificar
            result = std::string(padding, fill) + result;
            break;
        }
    }

    return result;
}

// =============================================================================
// format - Funcion principal con todos los parametros
// =============================================================================

/**
 * @brief Formatea int128_base_t<S> con especificaciones completas
 * @tparam S signedness del tipo
 * @param value Valor a formatear
 * @param base Base numerica (10, 16, 8)
 * @param width Ancho minimo del campo
 * @param fill Caracter de relleno
 * @param show_base Mostrar prefijo de base (0x, 0)
 * @param show_pos Mostrar signo + para positivos (solo decimal)
 * @param uppercase Usar mayusculas para hex
 * @param left_align Alinear a la izquierda
 * @param internal_align Relleno interno (despues de prefijo/signo)
 * @return String formateado
 */
template <signedness S>
inline std::string format(const int128_base_t<S>& value, int base = 10, int width = 0,
                          char fill = ' ', bool show_base = false, bool show_pos = false,
                          bool uppercase = false, bool left_align = false,
                          bool internal_align = false)
{
    std::ios_base::fmtflags flags = std::ios_base::dec;

    // Configurar base
    switch (base) {
    case 16:
        flags = std::ios_base::hex;
        break;
    case 8:
        flags = std::ios_base::oct;
        break;
    default:
        flags = std::ios_base::dec;
        break;
    }

    // Configurar opciones
    if (show_base)
        flags |= std::ios_base::showbase;
    if (show_pos)
        flags |= std::ios_base::showpos;
    if (uppercase)
        flags |= std::ios_base::uppercase;

    // Configurar alineacion
    if (left_align) {
        flags |= std::ios_base::left;
    } else if (internal_align) {
        flags |= std::ios_base::internal;
    } else {
        flags |= std::ios_base::right;
    }

    return format_like_iostream(value, flags, width, fill);
}

// =============================================================================
// Funciones de conveniencia por base
// =============================================================================

/**
 * @brief Formateo hexadecimal
 * @param value Valor a formatear
 * @param width Ancho minimo (default 0)
 * @param show_base Mostrar prefijo 0x (default false)
 * @param uppercase Usar mayusculas A-F (default false)
 * @param fill Caracter de relleno (default '0')
 * @return String formateado
 */
template <signedness S>
inline std::string hex(const int128_base_t<S>& value, int width = 0, bool show_base = false,
                       bool uppercase = false, char fill = '0')
{
    return format(value, 16, width, fill, show_base, false, uppercase, false, width > 0);
}

/**
 * @brief Formateo octal
 * @param value Valor a formatear
 * @param width Ancho minimo (default 0)
 * @param show_base Mostrar prefijo 0 (default false)
 * @param fill Caracter de relleno (default '0')
 * @return String formateado
 */
template <signedness S>
inline std::string oct(const int128_base_t<S>& value, int width = 0, bool show_base = false,
                       char fill = '0')
{
    return format(value, 8, width, fill, show_base, false, false, false, width > 0);
}

/**
 * @brief Formateo decimal
 * @param value Valor a formatear
 * @param width Ancho minimo (default 0)
 * @param fill Caracter de relleno (default ' ')
 * @param left_align Alinear a la izquierda (default false)
 * @return String formateado
 */
template <signedness S>
inline std::string dec(const int128_base_t<S>& value, int width = 0, char fill = ' ',
                       bool left_align = false)
{
    return format(value, 10, width, fill, false, false, false, left_align, false);
}

/**
 * @brief Formateo decimal con signo siempre visible
 * @param value Valor a formatear
 * @param width Ancho minimo (default 0)
 * @param fill Caracter de relleno (default ' ')
 * @param left_align Alinear a la izquierda (default false)
 * @return String formateado (incluye + para positivos)
 */
template <signedness S>
inline std::string dec_signed(const int128_base_t<S>& value, int width = 0, char fill = ' ',
                              bool left_align = false)
{
    return format(value, 10, width, fill, false, true, false, left_align, false);
}

// =============================================================================
// Formateo de rangos binarios (para debugging)
// =============================================================================

/**
 * @brief Formateo binario (base 2)
 * @param value Valor a formatear
 * @param width Ancho minimo (default 0)
 * @param show_prefix Mostrar prefijo 0b (default false)
 * @param fill Caracter de relleno (default '0')
 * @return String formateado en binario
 */
template <signedness S>
inline std::string bin(const int128_base_t<S>& value, int width = 0, bool show_prefix = false,
                       char fill = '0')
{
    std::string result = value.to_string(2);

    if (show_prefix) {
        result = "0b" + result;
    }

    // Aplicar padding
    if (width > 0 && static_cast<int>(result.length()) < width) {
        size_t padding = static_cast<size_t>(width) - result.length();
        if (show_prefix && result.length() >= 2) {
            // Insertar padding despues de 0b
            result = "0b" + std::string(padding, fill) + result.substr(2);
        } else {
            result = std::string(padding, fill) + result;
        }
    }

    return result;
}

/**
 * @brief Formateo con separadores de miles
 * @param value Valor a formatear
 * @param separator Caracter separador (default ',')
 * @param group_size Digitos por grupo (default 3)
 * @return String formateado con separadores
 */
template <signedness S>
inline std::string with_separators(const int128_base_t<S>& value, char separator = ',',
                                   int group_size = 3)
{
    std::string result = value.to_string();
    bool is_negative = (result[0] == '-');
    size_t start = is_negative ? 1 : 0;

    // Insertar separadores de derecha a izquierda
    int count = 0;
    for (size_t i = result.length(); i > start; --i) {
        if (count > 0 && count % group_size == 0) {
            result.insert(i, 1, separator);
        }
        ++count;
    }

    return result;
}

} // namespace int128_format

// =============================================================================
// Funciones helper para uso directo con streams
// =============================================================================

/**
 * @brief Aplica formateo usando el estado actual del stream (para uint128_t)
 */
inline std::string format_for_stream(const uint128_t& value, const std::ostream& os)
{
    return int128_format::format_like_iostream(value, os.flags(), os.width(), os.fill());
}

/**
 * @brief Aplica formateo usando el estado actual del stream (para int128_t)
 */
inline std::string format_for_stream(const int128_t& value, const std::ostream& os)
{
    return int128_format::format_like_iostream(value, os.flags(), os.width(), os.fill());
}

} // namespace nstd

#endif // INT128_BASE_FORMAT_HPP
