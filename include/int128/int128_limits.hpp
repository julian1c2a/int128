/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_LIMITS_HPP
#define INT128_LIMITS_HPP

#include "int128_t.hpp"
#include <limits>

namespace std
{

/**
 * @brief Especialización de std::numeric_limits para int128_t
 *
 * Proporciona información sobre las propiedades numéricas del tipo int128_t,
 * incluyendo rangos de valores, precisión y características especiales.
 */
template <> class numeric_limits<int128_t>
{
  public:
    static constexpr bool is_specialized = true;
    static constexpr bool is_signed = true; // ¡CON SIGNO!
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr bool has_denorm_loss = false;
    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = false; // Los tipos con signo no son modulo
    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;

    static constexpr int digits = 127;     // Bits significativos (128 - 1 bit de signo)
    static constexpr int digits10 = 38;    // floor(127 * log10(2)) ≈ 38
    static constexpr int max_digits10 = 0; // No aplicable para enteros
    static constexpr int radix = 2;        // Base binaria

    static constexpr int min_exponent = 0;   // No aplicable para enteros
    static constexpr int min_exponent10 = 0; // No aplicable para enteros
    static constexpr int max_exponent = 0;   // No aplicable para enteros
    static constexpr int max_exponent10 = 0; // No aplicable para enteros

    static constexpr float_denorm_style has_denorm = denorm_absent;
    static constexpr float_round_style round_style = round_toward_zero;

    // ===== MÉTODOS DE VALORES ESPECIALES =====

    /**
     * @brief Valor mínimo representable (valor más negativo)
     * @return -2^127
     */
    static constexpr int128_t min() noexcept
    {
        return int128_t(0x8000000000000000ULL, 0x0000000000000000ULL); // -2^127
    }

    /**
     * @brief Valor más bajo representable (igual a min para enteros con signo)
     * @return -2^127
     */
    static constexpr int128_t lowest() noexcept
    {
        return min();
    }

    /**
     * @brief Valor máximo representable
     * @return 2^127 - 1
     */
    static constexpr int128_t max() noexcept
    {
        return int128_t(0x7FFFFFFFFFFFFFFFULL, 0xFFFFFFFFFFFFFFFFULL); // 2^127 - 1
    }

    /**
     * @brief Error de precisión de máquina (no aplicable para enteros)
     * @return int128_t(0)
     */
    static constexpr int128_t epsilon() noexcept
    {
        return int128_t(0, 0);
    }

    /**
     * @brief Error de redondeo (no aplicable para enteros)
     * @return int128_t(0)
     */
    static constexpr int128_t round_error() noexcept
    {
        return int128_t(0, 0);
    }

    /**
     * @brief Representación de infinito (no aplicable para enteros)
     * @return int128_t(0)
     */
    static constexpr int128_t infinity() noexcept
    {
        return int128_t(0, 0);
    }

    /**
     * @brief Representación de NaN silencioso (no aplicable para enteros)
     * @return int128_t(0)
     */
    static constexpr int128_t quiet_NaN() noexcept
    {
        return int128_t(0, 0);
    }

    /**
     * @brief Representación de NaN señalizante (no aplicable para enteros)
     * @return int128_t(0)
     */
    static constexpr int128_t signaling_NaN() noexcept
    {
        return int128_t(0, 0);
    }

    /**
     * @brief Valor desnormalizado mínimo (igual a min para enteros)
     * @return -2^127
     */
    static constexpr int128_t denorm_min() noexcept
    {
        return min();
    }
};

} // namespace std

#endif // INT128_LIMITS_HPP