/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once
#ifndef INT128_FORMAT_HPP
#define INT128_FORMAT_HPP

#include "int128_t.hpp"
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

/**
 * @brief Funciones de formateo avanzado para int128_t
 *
 * Este archivo proporciona funciones que simulan el comportamiento
 * de los manipuladores iostream para int128_t, ya que el operador<<
 * básico no los respeta automáticamente. Incluye manejo especializado
 * para números negativos y signo.
 */

namespace int128_format
{

using uint128_t = nstd::uint128_t;
using int128_t = nstd::int128_t;

/**
 * @brief Formatea int128_t imitando iostream con manipuladores
 */
inline std::string format_like_iostream(const int128_t& value, std::ios_base::fmtflags flags,
                                        std::streamsize width = 0, char fill = ' ')
{

    const int base_flags = (flags & std::ios_base::basefield);
    const bool show_base = (flags & std::ios_base::showbase);
    const bool show_pos = (flags & std::ios_base::showpos);
    const bool uppercase = (flags & std::ios_base::uppercase);
    const auto alignment = (flags & std::ios_base::adjustfield);

    std::string result;
    bool is_negative = value.is_negative();

    // Para valores negativos en bases no decimales, usamos el valor absoluto con signo
    int128_t abs_value = is_negative ? -value : value;

    // Determinar la base numérica
    switch (base_flags) {
    case std::ios_base::hex:
        if (is_negative) {
            // Para negativos en hex, usar complemento a 2
            result = value.to_uint128().to_string_base(16);
            if (show_base) {
                result = "0x" + result;
            }
        } else {
            result = abs_value.to_string_base(16);
            if (show_base) {
                result = "0x" + result;
            }
        }
        if (uppercase) {
            // Convertir a mayúsculas
            for (char& c : result) {
                if (c >= 'a' && c <= 'f') {
                    c = c - 'a' + 'A';
                }
            }
        }
        break;

    case std::ios_base::oct:
        if (is_negative) {
            // Para negativos en octal, usar complemento a 2
            result = value.to_uint128().to_string_base(8);
            if (show_base) {
                result = "0" + result;
            }
        } else {
            result = abs_value.to_string_base(8);
            if (show_base) {
                result = "0" + result;
            }
        }
        break;

    default: // std::ios_base::dec o sin especificar
        result = value.to_string();
        // Para decimales positivos con showpos
        if (!is_negative && show_pos) {
            result = "+" + result;
        }
        break;
    }

    // Aplicar ancho de campo y alineación
    if (width > 0 && static_cast<int>(result.length()) < width) {
        const int padding = width - static_cast<int>(result.length());

        switch (alignment) {
        case std::ios_base::left:
            result += std::string(padding, fill);
            break;

        case std::ios_base::internal:
            // Para internal, el relleno va después del prefijo/signo pero antes del número
            if ((show_base && !is_negative &&
                 (base_flags == std::ios_base::hex || base_flags == std::ios_base::oct))) {
                if (base_flags == std::ios_base::hex && result.substr(0, 2) == "0x") {
                    result = "0x" + std::string(padding, fill) + result.substr(2);
                } else if (base_flags == std::ios_base::hex && result.substr(0, 2) == "0X") {
                    result = "0X" + std::string(padding, fill) + result.substr(2);
                } else if (base_flags == std::ios_base::oct && result.substr(0, 1) == "0" &&
                           result.length() > 1) {
                    result = "0" + std::string(padding, fill) + result.substr(1);
                } else {
                    result = std::string(padding, fill) + result; // fallback a right
                }
            } else if ((is_negative || show_pos) && base_flags == std::ios_base::dec) {
                // Para números con signo, poner el relleno después del signo
                if (result[0] == '-' || result[0] == '+') {
                    result = result[0] + std::string(padding, fill) + result.substr(1);
                } else {
                    result = std::string(padding, fill) + result; // fallback a right
                }
            } else {
                result = std::string(padding, fill) + result; // Sin prefijo, actúa como right
            }
            break;

        default: // std::ios_base::right o sin especificar
            result = std::string(padding, fill) + result;
            break;
        }
    }

    return result;
}

/**
 * @brief Formatea int128_t con especificaciones completas
 */
inline std::string format(const int128_t& value, int base = 10, int width = 0, char fill = ' ',
                          bool show_base = false, bool show_pos = false, bool uppercase = false,
                          bool left_align = false, bool internal_align = false)
{

    std::ios_base::fmtflags flags = std::ios_base::dec;

    // Configurar base
    switch (base) {
    case 16:
        flags = std::ios_base::hex;
        break;
    case 8:
        flags = std::ios_base::oct;
        break;
    default:
        flags = std::ios_base::dec;
        break;
    }

    // Configurar opciones
    if (show_base)
        flags |= std::ios_base::showbase;
    if (show_pos)
        flags |= std::ios_base::showpos;
    if (uppercase)
        flags |= std::ios_base::uppercase;

    // Configurar alineación
    if (left_align) {
        flags |= std::ios_base::left;
    } else if (internal_align) {
        flags |= std::ios_base::internal;
    } else {
        flags |= std::ios_base::right;
    }

    return format_like_iostream(value, flags, width, fill);
}

/**
 * @brief Formateo hexadecimal con opciones
 */
inline std::string hex(const int128_t& value, int width = 0, bool show_base = false,
                       bool uppercase = false, char fill = '0')
{
    return format(value, 16, width, fill, show_base, false, uppercase, false, width > 0);
}

/**
 * @brief Formateo octal con opciones
 */
inline std::string oct(const int128_t& value, int width = 0, bool show_base = false,
                       char fill = '0')
{
    return format(value, 8, width, fill, show_base, false, false, false, width > 0);
}

/**
 * @brief Formateo decimal con opciones
 */
inline std::string dec(const int128_t& value, int width = 0, char fill = ' ', bool show_pos = false,
                       bool left_align = false)
{
    return format(value, 10, width, fill, false, show_pos, false, left_align, false);
}

/**
 * @brief Formateo decimal con signo siempre visible
 */
inline std::string dec_signed(const int128_t& value, int width = 0, char fill = ' ',
                              bool left_align = false)
{
    return format(value, 10, width, fill, false, true, false, left_align, false);
}

} // namespace int128_format

// ===============================================================================
// FUNCIONES DE CONVENIENCIA PARA USO DIRECTO CON IOSTREAM
// ===============================================================================

/**
 * @brief Función helper que aplica formateo usando el estado actual del stream
 */
inline std::string format_int128_for_stream(const nstd::int128_t& value, const std::ostream& os)
{
    return int128_format::format_like_iostream(value, os.flags(), os.width(), os.fill());
}

#endif // INT128_FORMAT_HPP