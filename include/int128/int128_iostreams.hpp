/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#pragma once
#ifndef INT128_IOSTREAMS_HPP
#define INT128_IOSTREAMS_HPP

#include "int128_format.hpp"
#include "int128_t.hpp"
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

/**
 * @brief Soporte completo de iostreams con iomanip para int128_t
 *
 * Este header proporciona operadores iostream completos que soportan todos los
 * manipuladores estándar de iomanip:
 * - Bases: std::hex, std::oct, std::dec
 * - Ancho: std::setw()
 * - Relleno: std::setfill()
 * - Alineación: std::left, std::right, std::internal
 * - Prefijos: std::showbase, std::noshowbase
 * - Signo: std::showpos, std::noshowpos
 * - Mayúsculas: std::uppercase, std::nouppercase
 */

namespace nstd
{

/**
 * @brief Operador de salida mejorado que respeta iomanip
 */
inline std::ostream& operator<<(std::ostream& os, const int128_t& value)
{
    // Guardar el estado de formateo actual
    const auto flags = os.flags();
    const int base = (flags & std::ios_base::basefield);
    const bool show_base = (flags & std::ios_base::showbase);
    const bool show_pos = (flags & std::ios_base::showpos);
    const bool uppercase = (flags & std::ios_base::uppercase);
    const auto width = os.width();
    const auto fill_char = os.fill();
    const auto alignment = (flags & std::ios_base::adjustfield);

    std::string result;
    bool is_negative = value < int128_t(0);

    // Determinar la base numérica
    switch (base) {
    case std::ios_base::hex:
        if (is_negative) {
            // Para hex, mostrar representación two's complement (sin signo)
            uint128_t uval(value);
            result = uval.to_string_hex(show_base);
        } else {
            // Convertir a uint128_t para usar to_string_hex
            uint128_t uval(value);
            result = uval.to_string_hex(show_base);
        }
        if (uppercase) {
            // Ya está en mayúsculas por defecto
            // No hacer nada
        } else {
            // Convertir a minúsculas
            for (char& c : result) {
                if (c >= 'A' && c <= 'F') {
                    c = c - 'A' + 'a';
                }
            }
        }
        break;

    case std::ios_base::oct:
        if (is_negative) {
            uint128_t uval(value);
            result = uval.to_string_oct(show_base);
        } else {
            // Convertir a uint128_t para usar to_string_oct
            uint128_t uval(value);
            result = uval.to_string_oct(show_base);
        }
        break;

    default: // std::ios_base::dec
        result = value.to_string();
        if (show_pos && !is_negative) {
            result = "+" + result;
        }
        break;
    }

    // Aplicar ancho de campo y alineación
    if (width > 0 && static_cast<int>(result.length()) < width) {
        const int padding = width - static_cast<int>(result.length());

        switch (alignment) {
        case std::ios_base::left:
            result += std::string(padding, fill_char);
            break;

        case std::ios_base::internal:
            // Para internal, el relleno va después del prefijo/signo pero antes del número
            if (is_negative && result[0] == '-') {
                result = "-" + std::string(padding, fill_char) + result.substr(1);
            } else if (show_pos && !is_negative && result[0] == '+') {
                result = "+" + std::string(padding, fill_char) + result.substr(1);
            } else if (show_base && (base == std::ios_base::hex || base == std::ios_base::oct)) {
                if (base == std::ios_base::hex && result.length() >= 2 &&
                    (result.substr(0, 2) == "0x" || result.substr(0, 2) == "0X")) {
                    result =
                        result.substr(0, 2) + std::string(padding, fill_char) + result.substr(2);
                } else if (base == std::ios_base::oct && result[0] == '0') {
                    result = "0" + std::string(padding, fill_char) + result.substr(1);
                } else {
                    result = std::string(padding, fill_char) + result;
                }
            } else {
                result = std::string(padding, fill_char) + result;
            }
            break;

        default: // std::ios_base::right
            result = std::string(padding, fill_char) + result;
            break;
        }
    }

    // Resetear width (comportamiento estándar)
    os.width(0);

    return os << result;
}

/**
 * @brief Operador de entrada mejorado que respeta la base
 */
inline std::istream& operator>>(std::istream& is, int128_t& value)
{
    const auto flags = is.flags();
    const int base_flags = (flags & std::ios_base::basefield);

    std::string str;
    is >> str;

    if (is.good() || is.eof()) {
        int input_base = 10;

        switch (base_flags) {
        case std::ios_base::hex:
            input_base = 16;
            break;
        case std::ios_base::oct:
            input_base = 8;
            break;
        default:
            // Auto-detectar
            if (str.length() >= 2 && str.substr(0, 2) == "0x") {
                input_base = 16;
            } else if (str.length() >= 1 && str[0] == '0' && str.length() > 1) {
                input_base = 8;
            } else {
                input_base = 10;
            }
            break;
        }

        try {
            value = int128_t::from_string_base(str, input_base);
        } catch (const std::exception&) {
            is.setstate(std::ios_base::failbit);
        }
    }

    return is;
}

} // namespace nstd
// ===============================================================================
// FUNCIONES DE CONVENIENCIA PARA FORMATEO ESPECÍFICO CON IOSTREAM
// ===============================================================================

namespace int128_iostream
{

/**
 * @brief Aplica formateo usando el estado actual del stream
 */
inline std::string format_for_stream(const int128_t& value, const std::ostream& os)
{
    return int128_format::format_like_iostream(value, os.flags(), os.width(), os.fill());
}

/**
 * @brief Operador de salida que aplica formato avanzado (usar con cuidado)
 * Esta función aplica el formateo del stream actual, pero puede ser más lenta.
 */
inline std::ostream& formatted_output(std::ostream& os, const int128_t& value)
{
    std::string formatted = format_for_stream(value, os);
    os.width(0); // Reset width como hacen los streams estándar
    return os << formatted;
}

/**
 * @brief Operador de entrada que respeta la base del stream
 */
inline std::istream& formatted_input(std::istream& is, int128_t& value)
{
    const auto flags = is.flags();
    const int base_flags = (flags & std::ios_base::basefield);

    std::string str;
    is >> str;

    if (is.good() || is.eof()) {
        // Determinar la base para la entrada
        int input_base = 10; // Por defecto decimal

        switch (base_flags) {
        case std::ios_base::hex:
            input_base = 16;
            break;
        case std::ios_base::oct:
            input_base = 8;
            break;
        default:
            // Auto-detectar la base si no está especificada
            if (str.length() >= 2 && (str.substr(0, 2) == "0x" || str.substr(0, 2) == "0X")) {
                input_base = 16;
            } else if (str.length() >= 1 && str[0] == '0' && str.length() > 1 &&
                       str.find_first_not_of("01234567", 1) == std::string::npos) {
                input_base = 8;
            } else {
                input_base = 10;
            }
            break;
        }

        try {
            // Manejar signo para bases no decimales
            if (input_base != 10 && str[0] == '-') {
                // Para hex/octal con signo negativo, parsear sin signo y luego negar
                uint128_t uval = uint128_t::from_string_base(str.substr(1), input_base);
                value = -int128_t(uval);
            } else if (input_base != 10 && str[0] == '+') {
                uint128_t uval = uint128_t::from_string_base(str.substr(1), input_base);
                value = int128_t(uval);
            } else {
                value = int128_t::from_string_base(str, input_base);
            }
        } catch (const std::exception&) {
            is.setstate(std::ios_base::failbit);
        }
    }

    return is;
}

} // namespace int128_iostream

// ===============================================================================
// EXTENSIONES PARA FORMATEO AVANZADO
// ===============================================================================

namespace int128_format
{

/**
 * @brief Formatea int128_t usando ostringstream con manipuladores
 */
inline std::string stream_format(const int128_t& value, int base = 10, int width = 0,
                                 char fill = ' ', bool show_base = false, bool show_pos = false,
                                 bool uppercase = false, bool left_align = false,
                                 bool internal_align = false)
{
    std::ostringstream oss;

    // Configurar base
    switch (base) {
    case 16:
        oss << std::hex;
        break;
    case 8:
        oss << std::oct;
        break;
    default:
        oss << std::dec;
        break;
    }

    // Configurar opciones
    if (show_base)
        oss << std::showbase;
    if (show_pos)
        oss << std::showpos;
    if (uppercase)
        oss << std::uppercase;
    if (width > 0)
        oss << std::setw(width);
    if (fill != ' ')
        oss << std::setfill(fill);

    // Configurar alineación
    if (left_align) {
        oss << std::left;
    } else if (internal_align) {
        oss << std::internal;
    } else {
        oss << std::right; // Por defecto
    }

    // Generar resultado usando el operador básico
    oss << value;
    return oss.str();
}

/**
 * @brief Formateo hexadecimal mejorado
 */
inline std::string hex_advanced(const int128_t& value, int width = 0, bool show_base = false,
                                bool uppercase = false, char fill = '0')
{
    return stream_format(value, 16, width, fill, show_base, false, uppercase, false, false);
}

/**
 * @brief Formateo octal mejorado
 */
inline std::string oct_advanced(const int128_t& value, int width = 0, bool show_base = false,
                                char fill = '0')
{
    return stream_format(value, 8, width, fill, show_base, false, false, false, false);
}

/**
 * @brief Formateo decimal mejorado
 */
inline std::string dec_advanced(const int128_t& value, int width = 0, char fill = ' ',
                                bool show_pos = false, bool left_align = false)
{
    return stream_format(value, 10, width, fill, false, show_pos, false, left_align, false);
}

/**
 * @brief Formateo decimal con signo siempre visible (avanzado)
 */
inline std::string dec_signed_advanced(const int128_t& value, int width = 0, char fill = ' ',
                                       bool left_align = false)
{
    return stream_format(value, 10, width, fill, false, true, false, left_align, false);
}

} // namespace int128_format

#endif // INT128_IOSTREAMS_HPP