/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_CONCEPTS_HPP
#define INT128_CONCEPTS_HPP

#include "int128_t.hpp"
#include <concepts>
#include <type_traits>

/**
 * @brief Conceptos personalizados para int128_t
 *
 * Este archivo define conceptos C++20 específicos para trabajar con int128_t
 * y proporciona herramientas de metaprogramación avanzadas para enteros signados de 128 bits.
 */

namespace int128_concepts
{

using uint128_t = nstd::uint128_t;
using int128_t = nstd::int128_t;

// ===============================================================================
// CONCEPTOS BÁSICOS
// ===============================================================================

/**
 * @brief Concept para tipos que pueden convertirse a int128_t
 *
 * @tparam T Tipo a verificar
 *
 * Un tipo satisface este concepto si es un tipo integral estándar
 * o es el mismo int128_t.
 */
template <typename T>
concept int128_convertible = std::integral<T> || std::same_as<T, int128_t>;

/**
 * @brief Concept para tipos que son compatibles con operaciones de int128_t
 *
 * @tparam T Tipo a verificar
 *
 * Incluye todos los tipos convertibles a int128_t y también tipos
 * de punto flotante para operaciones mixtas.
 */
template <typename T>
concept int128_compatible = int128_convertible<T> || std::floating_point<T>;

/**
 * @brief Concept para tipos que pueden usar con operaciones bitwise
 *
 * @tparam T Tipo a verificar
 *
 * Solo tipos integrales pueden realizar operaciones bitwise seguras.
 * Para int128_t, las operaciones bitwise usan representación complemento a 2.
 */
template <typename T>
concept int128_bitwise_compatible = std::integral<T> || std::same_as<T, int128_t>;

/**
 * @brief Concept para tipos que son enteros signados compatibles
 *
 * @tparam T Tipo a verificar
 *
 * Verifica que el tipo sea un entero signado o int128_t para
 * operaciones que requieren aritmética signada.
 */
template <typename T>
concept int128_signed_compatible = std::signed_integral<T> || std::same_as<T, int128_t>;

// ===============================================================================
// CONCEPTOS PARA OPERACIONES ESPECÍFICAS
// ===============================================================================

/**
 * @brief Concept para tipos válidos en operaciones de desplazamiento
 *
 * @tparam T Tipo del operando de desplazamiento
 *
 * Los operandos de desplazamiento deben ser tipos integrales pequeños
 * para evitar comportamiento indefinido. Para int128_t, el desplazamiento
 * mantiene el bit de signo apropiadamente.
 */
template <typename T>
concept valid_shift_type = std::integral<T> && sizeof(T) <= 8;

/**
 * @brief Concept para tipos que pueden usarse como índices de bit
 *
 * @tparam T Tipo del índice
 *
 * Los índices de bit deben ser tipos enteros no negativos.
 * Para int128_t, se refiere a posiciones 0-127.
 */
template <typename T>
concept bit_index_type = std::unsigned_integral<T> && sizeof(T) <= 8;

/**
 * @brief Concept para tipos que pueden usarse en comparaciones con int128_t
 *
 * @tparam T Tipo a comparar
 *
 * Las comparaciones son seguras con tipos integrales y int128_t mismo.
 * Las comparaciones con int128_t respetan la semántica de signos.
 */
template <typename T>
concept int128_comparable = std::integral<T> || std::same_as<T, int128_t>;

// ===============================================================================
// CONCEPTOS PARA METAPROGRAMACIÓN
// ===============================================================================

/**
 * @brief Concept que verifica si un tipo puede ser promovido a int128_t
 *
 * @tparam T Tipo a verificar
 *
 * Un tipo puede ser promovido si es un tipo integral más pequeño que int128_t.
 * La promoción preserva el valor y el signo apropiadamente.
 */
template <typename T>
concept promotable_to_int128 = std::integral<T> && sizeof(T) <= 16 && !std::same_as<T, int128_t>;

/**
 * @brief Concept para funciones que pueden operar sobre int128_t
 *
 * @tparam F Tipo de función
 * @tparam Args Tipos de argumentos
 *
 * Verifica que una función pueda ser llamada con int128_t como primer argumento.
 */
template <typename F, typename... Args>
concept int128_function = requires(F f, int128_t i, Args... args) { f(i, args...); };

/**
 * @brief Concept para tipos que pueden actuar como contenedores de int128_t
 *
 * @tparam Container Tipo de contenedor
 *
 * Verifica que el contenedor tenga las operaciones básicas necesarias.
 */
template <typename Container>
concept int128_container = requires(Container c) {
    typename Container::value_type;
    requires std::same_as<typename Container::value_type, int128_t>;
    c.begin();
    c.end();
    c.size();
};

/**
 * @brief Concept para rangos numéricos válidos para int128_t
 *
 * @tparam T Tipo del rango
 *
 * Verifica que el tipo pueda representar el rango completo de int128_t
 * o un subconjunto válido sin pérdida de precisión.
 */
template <typename T>
concept int128_range_type =
    std::integral<T> && (sizeof(T) >= 16 || (std::signed_integral<T> && sizeof(T) >= 8));

// ===============================================================================
// CONCEPTOS PARA ALGORITMOS
// ===============================================================================

/**
 * @brief Concept para predicados que operan sobre int128_t
 *
 * @tparam Pred Tipo del predicado
 *
 * Un predicado debe retornar un tipo convertible a bool cuando
 * se aplica a int128_t.
 */
template <typename Pred>
concept int128_predicate = requires(Pred p, int128_t i) {
    { p(i) } -> std::convertible_to<bool>;
};

/**
 * @brief Concept para operaciones binarias sobre int128_t
 *
 * @tparam BinaryOp Tipo de la operación binaria
 *
 * La operación debe poder tomar dos int128_t y retornar un resultado.
 */
template <typename BinaryOp>
concept int128_binary_operation = requires(BinaryOp op, int128_t a, int128_t b) { op(a, b); };

/**
 * @brief Concept para operaciones de reducción sobre int128_t
 *
 * @tparam ReduceOp Tipo de la operación de reducción
 * @tparam T Tipo del valor inicial/acumulado
 *
 * La operación debe poder combinar un acumulador con un int128_t.
 */
template <typename ReduceOp, typename T>
concept int128_reduce_operation = requires(ReduceOp op, T acc, int128_t i) {
    { op(acc, i) } -> std::convertible_to<T>;
};

/**
 * @brief Concept para operaciones matemáticas seguras sobre int128_t
 *
 * @tparam MathOp Tipo de la operación matemática
 *
 * Verifica que la operación pueda detectar overflow y manejar casos especiales
 * como operaciones cerca de los límites de int128_t.
 */
template <typename MathOp>
concept int128_safe_operation = requires(MathOp op, int128_t a, int128_t b) {
    { op(a, b) } -> std::same_as<int128_t>;
    // La operación debe poder manejar casos límite apropiadamente
};

} // namespace int128_concepts

// ===============================================================================
// CONCEPTS EN NAMESPACE GLOBAL PARA COMPATIBILIDAD STL
// ===============================================================================

/**
 * @brief Verifica que int128_t satisfaga los conceptos estándar de C++20
 *
 * Estas verificaciones se ejecutan en tiempo de compilación para
 * asegurar compatibilidad con la biblioteca estándar y semántica correcta
 * de enteros signados de 128 bits.
 */
namespace int128_concept_checks
{

using uint128_t = nstd::uint128_t;
using int128_t = nstd::int128_t;

// Verificaciones básicas de conceptos
// NOTA: std::integral requiere especialización de std::is_integral<int128_t>
// static_assert(std::integral<int128_t>, "int128_t debe satisfacer std::integral");
// static_assert(std::signed_integral<int128_t>, "int128_t debe satisfacer std::signed_integral");
// static_assert(!std::unsigned_integral<int128_t>,
//               "int128_t no debe satisfacer std::unsigned_integral");
static_assert(std::regular<int128_t>, "int128_t debe satisfacer std::regular");
static_assert(std::totally_ordered<int128_t>, "int128_t debe satisfacer std::totally_ordered");

// Verificaciones de operaciones
static_assert(std::equality_comparable<int128_t>, "int128_t debe ser comparable por igualdad");
// NOTA: three_way_comparable requiere operador <=>
// static_assert(std::three_way_comparable<int128_t>,
//               "int128_t debe soportar comparación a tres vías");

// Verificaciones de construcción y asignación
static_assert(std::default_initializable<int128_t>, "int128_t debe ser default-constructible");
static_assert(std::copy_constructible<int128_t>, "int128_t debe ser copy-constructible");
static_assert(std::move_constructible<int128_t>, "int128_t debe ser move-constructible");
static_assert(std::assignable_from<int128_t&, const int128_t&>,
              "int128_t debe soportar asignación");

// Verificaciones específicas para enteros signados
// NOTA: Estas verificaciones requieren especialización de std::numeric_limits<int128_t>
// static_assert(std::numeric_limits<int128_t>::is_signed,
//               "int128_t debe ser reconocido como tipo signado");
// static_assert(std::numeric_limits<int128_t>::min() < int128_t{0},
//               "int128_t debe tener valores negativos válidos");
// static_assert(std::numeric_limits<int128_t>::max() > int128_t{0},
//               "int128_t debe tener valores positivos válidos");

// Verificaciones manuales que sí funcionan
static_assert(sizeof(int128_t) == 16, "int128_t debe tener 128 bits");
static_assert(int128_t(-1) < int128_t(0), "int128_t debe manejar valores negativos");
static_assert(int128_t(1) > int128_t(0), "int128_t debe manejar valores positivos");
} // namespace int128_concept_checks

#endif // INT128_CONCEPTS_HPP