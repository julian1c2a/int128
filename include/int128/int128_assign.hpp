/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_ASSIGN_HPP
#define INT128_ASSIGN_HPP

#include "../uint128/uint128_t.hpp"
#include "int128_t.hpp"
#include <cstdint>
#include <string>
#include <type_traits>

// =============================================================================
// FUNCIONES DE ASIGNACIÓN PARA UINT128_T (REEMPLAZAN CONSTRUCTORES/ASIGNACIONES)
// =============================================================================

/**
 * @brief Asigna un valor desde dos uint64_t
 * @param target Referencia al uint128_t a modificar
 * @param high Parte alta (64 bits superiores)
 * @param low Parte baja (64 bits inferiores)
 */
inline void assign_uint128(uint128_t& target, uint64_t high, uint64_t low) noexcept
{
    target.set_high(high);
    target.set_low(low);
}

/**
 * @brief Asigna un valor desde un tipo integral básico
 * @param target Referencia al uint128_t a modificar
 * @param value Valor integral a asignar
 */
template <typename T>
inline void assign_uint128(uint128_t& target, T value) noexcept
    requires(std::is_integral_v<T> && !std::is_same_v<T, bool> && sizeof(T) <= 8)
{
    if constexpr (std::is_signed_v<T>) {
        if (value < 0) {
            // Para negativos en tipo unsigned, mantenemos solo la parte baja
            target.set_low(static_cast<uint64_t>(value));
            target.set_high(0);
        } else {
            target.set_low(static_cast<uint64_t>(value));
            target.set_high(0);
        }
    } else {
        target.set_low(static_cast<uint64_t>(value));
        target.set_high(0);
    }
}

/**
 * @brief Asigna un valor desde un string
 * @param target Referencia al uint128_t a modificar
 * @param str String a convertir
 */
inline void assign_uint128(uint128_t& target, const std::string& str)
{
    target = uint128_t::from_string(str);
}

/**
 * @brief Asigna cero (reset)
 * @param target Referencia al uint128_t a modificar
 */
inline void assign_uint128_zero(uint128_t& target) noexcept
{
    target.set_high(0);
    target.set_low(0);
}

// =============================================================================
// FUNCIONES DE ASIGNACIÓN PARA INT128_T (REEMPLAZAN CONSTRUCTORES/ASIGNACIONES)
// =============================================================================

/**
 * @brief Asigna un valor desde dos uint64_t
 * @param target Referencia al int128_t a modificar
 * @param high Parte alta (64 bits superiores)
 * @param low Parte baja (64 bits inferiores)
 */
inline void assign_int128(int128_t& target, uint64_t high, uint64_t low) noexcept
{
    target.set_high(high);
    target.set_low(low);
}

/**
 * @brief Asigna un valor desde un tipo integral básico
 * @param target Referencia al int128_t a modificar
 * @param value Valor integral a asignar
 */
template <typename T>
inline void assign_int128(int128_t& target, T value) noexcept
    requires(std::is_integral_v<T> && !std::is_same_v<T, bool> && sizeof(T) <= 8)
{
    if constexpr (std::is_signed_v<T>) {
        if (value < 0) {
            // Extensión de signo: propagar el bit de signo
            target.set_low(static_cast<uint64_t>(value));
            target.set_high(UINT64_MAX); // Todos los bits en 1 para negativo
        } else {
            target.set_low(static_cast<uint64_t>(value));
            target.set_high(0);
        }
    } else {
        target.set_low(static_cast<uint64_t>(value));
        target.set_high(0);
    }
}

/**
 * @brief Asigna un valor desde uint128_t
 * @param target Referencia al int128_t a modificar
 * @param value uint128_t a convertir
 */
inline void assign_int128(int128_t& target, const uint128_t& value) noexcept
{
    target.set_high(value.high());
    target.set_low(value.low());
}

/**
 * @brief Asigna cero (reset)
 * @param target Referencia al int128_t a modificar
 */
inline void assign_int128_zero(int128_t& target) noexcept
{
    target.set_high(0);
    target.set_low(0);
}

// =============================================================================
// FUNCIONES DE ASIGNACIÓN CONVENIENTES (ALIASES)
// =============================================================================

/**
 * @brief Alias conveniente para asignación desde enteros
 */
template <typename T>
inline void assign_from_int(uint128_t& target, T value) noexcept
    requires(std::is_integral_v<T> && sizeof(T) <= 8)
{
    assign_uint128(target, value);
}

template <typename T>
inline void assign_from_int(int128_t& target, T value) noexcept
    requires(std::is_integral_v<T> && sizeof(T) <= 8)
{
    assign_int128(target, value);
}

/**
 * @brief Alias conveniente para asignación desde high/low
 */
inline void assign_from_parts(uint128_t& target, uint64_t high, uint64_t low) noexcept
{
    assign_uint128(target, high, low);
}

inline void assign_from_parts(int128_t& target, uint64_t high, uint64_t low) noexcept
{
    assign_int128(target, high, low);
}

#endif // INT128_ASSIGN_HPP