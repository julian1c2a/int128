/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_ALGORITHM_HPP
#define INT128_ALGORITHM_HPP

#include "int128_cmath.hpp"
#include "int128_concepts.hpp"
#include "int128_t.hpp"
#include <algorithm>
#include <functional>
#include <iterator>
#include <numeric>
#include <type_traits>

/**
 * @brief Algoritmos optimizados y especializados para int128_t
 *
 * Este archivo proporciona implementaciones optimizadas de algoritmos
 * estándar específicamente diseñados para trabajar con int128_t.
 * Incluye manejo especial para valores negativos y aritmética signada.
 */

namespace int128_algorithm
{

// ===============================================================================
// ALGORITMOS DE BÚSQUEDA
// ===============================================================================

/**
 * @brief Búsqueda binaria optimizada para rangos de int128_t
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param value Valor a buscar
 * @return true si se encuentra el valor, false en caso contrario
 *
 * Optimizada para aprovechar las características específicas de int128_t.
 * Maneja correctamente valores negativos en el ordenamiento.
 */
template <std::forward_iterator ForwardIt>
bool binary_search_int128(ForwardIt first, ForwardIt last, const int128_t& value)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    first = std::lower_bound(first, last, value);
    return (first != last) && (*first == value);
}

/**
 * @brief Encuentra el primer elemento que satisface el predicado
 *
 * @tparam ForwardIt Tipo de iterador
 * @tparam Predicate Tipo del predicado
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado a aplicar
 * @return Iterador al primer elemento que satisface el predicado
 */
template <std::forward_iterator ForwardIt>
ForwardIt find_if_int128(ForwardIt first, ForwardIt last,
                         int128_concepts::int128_predicate auto pred)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    return std::find_if(first, last, pred);
}

// ===============================================================================
// ALGORITMOS DE TRANSFORMACIÓN
// ===============================================================================

/**
 * @brief Transforma un rango aplicando una operación a cada elemento
 *
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam OutputIt Tipo de iterador de salida
 * @tparam UnaryOp Tipo de operación unaria
 * @param first Iterador al inicio del rango de entrada
 * @param last Iterador al final del rango de entrada
 * @param result Iterador al inicio del rango de salida
 * @param op Operación a aplicar
 * @return Iterador al final del rango de salida
 */
template <std::input_iterator InputIt, std::output_iterator<int128_t> OutputIt>
OutputIt transform_int128(InputIt first, InputIt last, OutputIt result, auto op)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    return std::transform(first, last, result, op);
}

/**
 * @brief Aplica una función a cada elemento del rango
 *
 * @tparam ForwardIt Tipo de iterador
 * @tparam Function Tipo de función
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param f Función a aplicar
 */
template <std::forward_iterator ForwardIt>
void for_each_int128(ForwardIt first, ForwardIt last, int128_concepts::int128_function<> auto f)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    std::for_each(first, last, f);
}

// ===============================================================================
// ALGORITMOS DE REDUCCIÓN
// ===============================================================================

/**
 * @brief Acumula valores en un rango usando una operación específica
 *
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam T Tipo del valor inicial
 * @tparam BinaryOp Tipo de operación binaria
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param init Valor inicial
 * @param op Operación binaria
 * @return Resultado de la acumulación
 */
template <std::input_iterator InputIt, typename T>
T accumulate_int128(InputIt first, InputIt last, T init,
                    int128_concepts::int128_reduce_operation<T> auto op)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    return std::accumulate(first, last, init, op);
}

/**
 * @brief Suma todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Suma de todos los elementos (puede ser negativa)
 */
template <std::input_iterator InputIt>
int128_t sum_int128(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    return std::accumulate(first, last, int128_t(0));
}

/**
 * @brief Encuentra el producto de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Producto de todos los elementos (puede ser negativo)
 */
template <std::input_iterator InputIt>
int128_t product_int128(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    return std::accumulate(first, last, int128_t(1), std::multiplies<int128_t>());
}

// ===============================================================================
// ALGORITMOS DE PARTICIÓN Y ORDENAMIENTO
// ===============================================================================

/**
 * @brief Particiona un rango según un predicado
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado de partición
 * @return Iterador al primer elemento que no satisface el predicado
 */
template <std::forward_iterator ForwardIt>
ForwardIt partition_int128(ForwardIt first, ForwardIt last,
                           int128_concepts::int128_predicate auto pred)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    return std::partition(first, last, pred);
}

/**
 * @brief Ordena un rango de int128_t usando una comparación personalizada
 *
 * @tparam RandomIt Tipo de iterador de acceso aleatorio
 * @tparam Compare Tipo de función de comparación
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param comp Función de comparación (por defecto: ascendente)
 */
template <std::random_access_iterator RandomIt>
void sort_int128(RandomIt first, RandomIt last, auto comp = std::less<int128_t>())
    requires std::same_as<typename std::iterator_traits<RandomIt>::value_type, int128_t>
{
    std::sort(first, last, comp);
}

// ===============================================================================
// ALGORITMOS ESPECIALIZADOS PARA int128_t
// ===============================================================================

/**
 * @brief Encuentra el máximo común divisor de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return GCD de todos los elementos (siempre positivo, 0 si rango vacío)
 *
 * Nota: Para int128_t signados, el GCD se calcula sobre valores absolutos.
 */
template <std::input_iterator InputIt>
int128_t gcd_range(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    if (first == last)
        return int128_t(0);

    int128_t result = (*first++).abs();
    while (first != last) {
        result = std::gcd(result, (*first++).abs());
        if (result == int128_t(1))
            break; // Optimización: si GCD es 1, no puede mejorar
    }
    return result;
}

/**
 * @brief Encuentra el mínimo común múltiplo de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return LCM de todos los elementos (siempre positivo, 0 si algún elemento es 0)
 *
 * Nota: Para int128_t signados, el LCM se calcula sobre valores absolutos.
 */
template <std::input_iterator InputIt>
int128_t lcm_range(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    if (first == last)
        return int128_t(0);

    int128_t result = (*first++).abs();
    while (first != last && result != int128_t(0)) {
        result = std::lcm(result, (*first++).abs());
    }
    return result;
}

/**
 * @brief Genera una secuencia aritmética de int128_t
 *
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango de salida
 * @param count Número de elementos a generar
 * @param start Valor inicial
 * @param step Paso de la secuencia (puede ser negativo)
 */
template <std::output_iterator<int128_t> OutputIt>
void generate_arithmetic_sequence(OutputIt first, std::size_t count, const int128_t& start,
                                  const int128_t& step)
{
    int128_t current = start;
    for (std::size_t i = 0; i < count; ++i) {
        *first++ = current;
        current += step;
    }
}

/**
 * @brief Genera una secuencia geométrica de int128_t
 *
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango de salida
 * @param count Número de elementos a generar
 * @param start Valor inicial
 * @param ratio Razón de la secuencia (puede ser negativa)
 */
template <std::output_iterator<int128_t> OutputIt>
void generate_geometric_sequence(OutputIt first, std::size_t count, const int128_t& start,
                                 const int128_t& ratio)
{
    int128_t current = start;
    for (std::size_t i = 0; i < count; ++i) {
        *first++ = current;
        current *= ratio;
    }
}

// ===============================================================================
// ALGORITMOS ESPECÍFICOS PARA VALORES SIGNADOS
// ===============================================================================

/**
 * @brief Separa valores positivos y negativos en un rango
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Iterador que separa valores negativos (izquierda) de positivos/cero (derecha)
 */
template <std::forward_iterator ForwardIt>
ForwardIt partition_by_sign(ForwardIt first, ForwardIt last)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    return std::partition(first, last, [](const int128_t& x) { return x < int128_t(0); });
}

/**
 * @brief Encuentra el valor absoluto máximo en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Valor con el mayor valor absoluto (mantiene signo original)
 */
template <std::input_iterator InputIt>
int128_t max_abs_value(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    if (first == last)
        return int128_t(0);

    return *std::max_element(
        first, last, [](const int128_t& a, const int128_t& b) { return a.abs() < b.abs(); });
}

// ===============================================================================
// UTILIDADES DE ANÁLISIS
// ===============================================================================

/**
 * @brief Estadísticas básicas de un rango de int128_t
 */
struct int128_stats {
    int128_t min_value;
    int128_t max_value;
    int128_t sum;
    std::size_t count;
    std::size_t negative_count;
    std::size_t positive_count;
    std::size_t zero_count;

    double mean() const
    {
        if (count == 0)
            return 0.0;
        // Conversión simple evitando problemas de casting
        bool is_negative = sum < int128_t(0);
        int128_t abs_sum = is_negative ? -sum : sum;
        // Usar conversión a double directamente
        double sum_as_double = static_cast<double>(abs_sum.low());
        double result = sum_as_double / count;
        return is_negative ? -result : result;
    }

    bool has_negative_values() const
    {
        return negative_count > 0;
    }
    bool has_positive_values() const
    {
        return positive_count > 0;
    }
    bool has_zero_values() const
    {
        return zero_count > 0;
    }
};

/**
 * @brief Calcula estadísticas básicas de un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Estructura con estadísticas básicas
 */
template <std::input_iterator InputIt>
int128_stats calculate_stats(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    if (first == last) {
        return {int128_t(0), int128_t(0), int128_t(0), 0, 0, 0, 0};
    }

    int128_stats stats;
    stats.min_value = stats.max_value = stats.sum = *first;
    stats.count = 1;
    stats.negative_count = (*first < int128_t(0)) ? 1 : 0;
    stats.positive_count = (*first > int128_t(0)) ? 1 : 0;
    stats.zero_count = (*first == int128_t(0)) ? 1 : 0;

    ++first;
    while (first != last) {
        const int128_t& value = *first++;
        stats.min_value = std::min(stats.min_value, value);
        stats.max_value = std::max(stats.max_value, value);
        stats.sum += value;
        ++stats.count;

        if (value < int128_t(0))
            ++stats.negative_count;
        else if (value > int128_t(0))
            ++stats.positive_count;
        else
            ++stats.zero_count;
    }

    return stats;
}

} // namespace int128_algorithm

#endif // INT128_ALGORITHM_HPP