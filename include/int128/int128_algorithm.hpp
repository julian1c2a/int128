/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_ALGORITHM_HPP
#define INT128_ALGORITHM_HPP

#include "int128_cmath.hpp"
#include "int128_concepts.hpp"
#include "int128_t.hpp"
#include <algorithm>
#include <functional>
#include <iterator>
#include <numeric>
#include <type_traits>

namespace nstd
{

/**
 * @brief Algoritmos optimizados y especializados para int128_t
 *
 * Este archivo proporciona implementaciones optimizadas de algoritmos
 * estandar especificamente disenados para trabajar con int128_t.
 * Incluye manejo especial para valores negativos y aritmetica signada.
 */

namespace int128_algorithm
{

using uint128_t = nstd::uint128_t;
using int128_t = nstd::int128_t;

// ===============================================================================
// ALGORITMOS DE BuSQUEDA
// ===============================================================================

/**
 * @brief Busqueda binaria optimizada para rangos de int128_t
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param value Valor a buscar
 * @return true si se encuentra el valor, false en caso contrario
 *
 * Optimizada para aprovechar las caracteristicas especificas de int128_t.
 * Maneja correctamente valores negativos en el ordenamiento.
 *
 * @test test_binary_search_int128
 * @code{.cpp}
 * // Verifica busqueda de valores existentes, inexistentes y negativos
 * std::vector<int128_t> vec = {int128_t(-50), int128_t(-20), int128_t(10), int128_t(30),
 * int128_t(50)}; assert(binary_search_int128(vec.begin(), vec.end(), int128_t(30)));
 * assert(!binary_search_int128(vec.begin(), vec.end(), int128_t(15)));
 * @endcode
 */
template <std::forward_iterator ForwardIt>
bool binary_search_int128(ForwardIt first, ForwardIt last, const int128_t& value)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    first = std::lower_bound(first, last, value);
    return (first != last) && (*first == value);
}

/**
 * @brief Encuentra el primer elemento que satisface el predicado
 *
 * @tparam ForwardIt Tipo de iterador
 * @tparam Predicate Tipo del predicado
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado a aplicar
 * @return Iterador al primer elemento que satisface el predicado
 *
 * @test test_find_if_int128
 * @code{.cpp}
 * // Encuentra primer elemento mayor que 7, primer negativo, etc.
 * auto it = find_if_int128(vec.begin(), vec.end(),
 *     [](const int128_t& x) { return x > int128_t(7); });
 * assert(it != vec.end() && *it == int128_t(10));
 * @endcode
 */
template <std::forward_iterator ForwardIt>
ForwardIt find_if_int128(ForwardIt first, ForwardIt last,
                         int128_concepts::int128_predicate auto pred)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    return std::find_if(first, last, pred);
}

// ===============================================================================
// ALGORITMOS DE TRANSFORMACIoN
// ===============================================================================

/**
 * @brief Transforma un rango aplicando una operacion a cada elemento
 *
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam OutputIt Tipo de iterador de salida
 * @tparam UnaryOp Tipo de operacion unaria
 * @param first Iterador al inicio del rango de entrada
 * @param last Iterador al final del rango de entrada
 * @param result Iterador al inicio del rango de salida
 * @param op Operacion a aplicar
 * @return Iterador al final del rango de salida
 *
 * @test test_transform_int128
 * @code{.cpp}
 * // Aplica transformaciones (duplicar, valor absoluto)
 * transform_int128(input.begin(), input.end(), output.begin(),
 *     [](const int128_t& x) { return x * int128_t(2); });
 * assert(output[0] == int128_t(-10) && output[1] == int128_t(20));
 * @endcode
 */
template <std::input_iterator InputIt, std::output_iterator<int128_t> OutputIt>
OutputIt transform_int128(InputIt first, InputIt last, OutputIt result, auto op)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    return std::transform(first, last, result, op);
}

/**
 * @brief Aplica una funcion a cada elemento del rango
 *
 * @tparam ForwardIt Tipo de iterador
 * @tparam Function Tipo de funcion
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param f Funcion a aplicar
 *
 * @test test_for_each_int128
 * @code{.cpp}
 * // Aplica funcion a cada elemento (contar, sumar)
 * int128_t sum = 0;
 * for_each_int128(vec.begin(), vec.end(),
 *     [&sum](const int128_t& x) { sum += x; });
 * assert(sum == int128_t(2));
 * @endcode
 */
template <std::forward_iterator ForwardIt>
void for_each_int128(ForwardIt first, ForwardIt last, int128_concepts::int128_function<> auto f)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    std::for_each(first, last, f);
}

// ===============================================================================
// ALGORITMOS DE REDUCCIoN
// ===============================================================================

/**
 * @brief Acumula valores en un rango usando una operacion especifica
 *
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam T Tipo del valor inicial
 * @tparam BinaryOp Tipo de operacion binaria
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param init Valor inicial
 * @param op Operacion binaria
 * @return Resultado de la acumulacion
 *
 * @test test_accumulate_int128
 * @code{.cpp}
 * // Acumula con operaciones de suma y producto
 * auto sum = accumulate_int128(vec.begin(), vec.end(),
 *     int128_t(100), std::plus<int128_t>());
 * assert(sum == int128_t(120));
 * @endcode
 */
template <std::input_iterator InputIt, typename T>
T accumulate_int128(InputIt first, InputIt last, T init,
                    int128_concepts::int128_reduce_operation<T> auto op)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    return std::accumulate(first, last, init, op);
}

/**
 * @brief Suma todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Suma de todos los elementos (puede ser negativa)
 *
 * @test test_sum_int128
 * @code{.cpp}
 * // Suma elementos del rango, verifica rango vacio y negativos
 * std::vector<int128_t> vec = {int128_t(-5), int128_t(10), int128_t(-15), int128_t(20)};
 * auto sum = sum_int128(vec.begin(), vec.end());
 * assert(sum == int128_t(10));
 * @endcode
 */
template <std::input_iterator InputIt>
int128_t sum_int128(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    return std::accumulate(first, last, int128_t(0));
}

/**
 * @brief Encuentra el producto de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Producto de todos los elementos (puede ser negativo)
 *
 * @test test_product_int128
 * @code{.cpp}
 * // Calcula producto, verifica comportamiento con cero y negativos
 * std::vector<int128_t> vec = {int128_t(-2), int128_t(3), int128_t(-4)};
 * auto product = product_int128(vec.begin(), vec.end());
 * assert(product == int128_t(24));
 * @endcode
 */
template <std::input_iterator InputIt>
int128_t product_int128(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    return std::accumulate(first, last, int128_t(1), std::multiplies<int128_t>());
}

// ===============================================================================
// ALGORITMOS DE PARTICIoN Y ORDENAMIENTO
// ===============================================================================

/**
 * @brief Particiona un rango segun un predicado
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado de particion
 * @return Iterador al primer elemento que no satisface el predicado
 *
 * @test test_partition_int128
 * @code{.cpp}
 * // Particiona en negativos/positivos, verifica separacion correcta
 * auto middle = partition_int128(vec.begin(), vec.end(),
 *     [](const int128_t& x) { return x < int128_t(0); });
 * // Verifica que elementos antes de middle son negativos
 * @endcode
 */
template <std::forward_iterator ForwardIt>
ForwardIt partition_int128(ForwardIt first, ForwardIt last,
                           int128_concepts::int128_predicate auto pred)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    return std::partition(first, last, pred);
}

/**
 * @brief Ordena un rango de int128_t usando una comparacion personalizada
 *
 * @tparam RandomIt Tipo de iterador de acceso aleatorio
 * @tparam Compare Tipo de funcion de comparacion
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param comp Funcion de comparacion
 *
 * @test test_sort_int128
 * @code{.cpp}
 * // Ordena ascendente y descendente, verifica orden correcto con negativos
 * sort_int128(vec.begin(), vec.end());
 * assert(vec[0] == int128_t(-20) && vec[4] == int128_t(50));
 * sort_int128(vec.begin(), vec.end(), std::greater<int128_t>());
 * @endcode
 */
template <std::random_access_iterator RandomIt>
void sort_int128(RandomIt first, RandomIt last)
    requires std::same_as<typename std::iterator_traits<RandomIt>::value_type, int128_t>
{
    std::sort(first, last);
}

template <std::random_access_iterator RandomIt, typename Compare>
void sort_int128(RandomIt first, RandomIt last, Compare comp)
    requires std::same_as<typename std::iterator_traits<RandomIt>::value_type, int128_t>
{
    std::sort(first, last, comp);
}

// ===============================================================================
// ALGORITMOS ESPECIALIZADOS PARA int128_t
// ===============================================================================

/**
 * @brief Encuentra el maximo comun divisor de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return GCD de todos los elementos (siempre positivo, 0 si rango vacio)
 *
 * Nota: Para int128_t signados, el GCD se calcula sobre valores absolutos.
 *
 * @test test_gcd_range
 * @code{.cpp}
 * // Calcula GCD de multiples numeros con negativos
 * std::vector<int128_t> vec = {int128_t(12), int128_t(-18), int128_t(24)};
 * auto gcd = gcd_range(vec.begin(), vec.end());
 * assert(gcd == int128_t(6));
 * @endcode
 */
template <std::input_iterator InputIt>
int128_t gcd_range(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    if (first == last)
        return int128_t(0);

    int128_t result = (*first++).abs();
    while (first != last) {
        result = nstd::gcd(result, (*first++).abs());
        if (result == int128_t(1))
            break; // Optimizacion: si GCD es 1, no puede mejorar
    }
    return result;
}

/**
 * @brief Encuentra el minimo comun multiplo de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return LCM de todos los elementos (siempre positivo, 0 si algun elemento es 0)
 *
 * Nota: Para int128_t signados, el LCM se calcula sobre valores absolutos.
 *
 * @test test_lcm_range
 * @code{.cpp}
 * // Calcula LCM de multiples numeros con negativos y cero
 * std::vector<int128_t> vec = {int128_t(4), int128_t(-6), int128_t(8)};
 * auto lcm = lcm_range(vec.begin(), vec.end());
 * assert(lcm == int128_t(24));
 * @endcode
 */
template <std::input_iterator InputIt>
int128_t lcm_range(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    if (first == last)
        return int128_t(0);

    int128_t result = (*first++).abs();
    while (first != last && result != int128_t(0)) {
        result = nstd::gcd(result, (*first++).abs());
    }
    return result;
}

/**
 * @brief Genera una secuencia aritmetica de int128_t
 *
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango de salida
 * @param count Numero de elementos a generar
 * @param start Valor inicial
 * @param step Paso de la secuencia (puede ser negativo)
 *
 * @test test_generate_arithmetic_sequence
 * @code{.cpp}
 * // Genera secuencias ascendentes/descendentes con negativos
 * generate_arithmetic_sequence(seq.begin(), 5, int128_t(10), int128_t(5));
 * assert(seq[0] == int128_t(10) && seq[4] == int128_t(30));
 * generate_arithmetic_sequence(seq.begin(), 5, int128_t(20), int128_t(-10));
 * @endcode
 */
template <std::output_iterator<int128_t> OutputIt>
void generate_arithmetic_sequence(OutputIt first, std::size_t count, const int128_t& start,
                                  const int128_t& step)
{
    int128_t current = start;
    for (std::size_t i = 0; i < count; ++i) {
        *first++ = current;
        current += step;
    }
}

/**
 * @brief Genera una secuencia geometrica de int128_t
 *
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango de salida
 * @param count Numero de elementos a generar
 * @param start Valor inicial
 * @param ratio Razon de la secuencia (puede ser negativa)
 *
 * @test test_generate_geometric_sequence
 * @code{.cpp}
 * // Genera progresiones geometricas con ratio negativo
 * generate_geometric_sequence(seq.begin(), 5, int128_t(2), int128_t(2));
 * assert(seq[0] == int128_t(2) && seq[4] == int128_t(32));
 * generate_geometric_sequence(seq.begin(), 5, int128_t(3), int128_t(-2));
 * @endcode
 */
template <std::output_iterator<int128_t> OutputIt>
void generate_geometric_sequence(OutputIt first, std::size_t count, const int128_t& start,
                                 const int128_t& ratio)
{
    int128_t current = start;
    for (std::size_t i = 0; i < count; ++i) {
        *first++ = current;
        current *= ratio;
    }
}

// ===============================================================================
// ALGORITMOS ESPECiFICOS PARA VALORES SIGNADOS
// ===============================================================================

/**
 * @brief Separa valores positivos y negativos en un rango
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Iterador que separa valores negativos (izquierda) de positivos/cero (derecha)
 *
 * @test test_partition_by_sign
 * @code{.cpp}
 * // Particiona por signo, verifica negativos a la izquierda
 * auto middle = partition_by_sign(vec.begin(), vec.end());
 * for (auto it = vec.begin(); it != middle; ++it) {
 *     assert(*it < int128_t(0));
 * }
 * @endcode
 */
template <std::forward_iterator ForwardIt>
ForwardIt partition_by_sign(ForwardIt first, ForwardIt last)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, int128_t>
{
    return std::partition(first, last, [](const int128_t& x) { return x < int128_t(0); });
}

/**
 * @brief Encuentra el valor absoluto maximo en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Valor con el mayor valor absoluto (mantiene signo original)
 *
 * @test test_max_abs_value
 * @code{.cpp}
 * // Encuentra valor con mayor magnitud, mantiene signo original
 * std::vector<int128_t> vec = {int128_t(10), int128_t(-50), int128_t(30), int128_t(-20)};
 * auto max_abs = max_abs_value(vec.begin(), vec.end());
 * assert(max_abs == int128_t(-50));
 * @endcode
 */
template <std::input_iterator InputIt>
int128_t max_abs_value(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    if (first == last)
        return int128_t(0);

    return *std::max_element(
        first, last, [](const int128_t& a, const int128_t& b) { return a.abs() < b.abs(); });
}

// ===============================================================================
// UTILIDADES DE ANaLISIS
// ===============================================================================

/**
 * @brief Estadisticas basicas de un rango de int128_t
 */
struct int128_stats {
    int128_t min_value;
    int128_t max_value;
    int128_t sum;
    std::size_t count;
    std::size_t negative_count;
    std::size_t positive_count;
    std::size_t zero_count;

    double mean() const
    {
        if (count == 0)
            return 0.0;
        // Conversion simple evitando problemas de casting
        bool is_negative = sum < int128_t(0);
        int128_t abs_sum = is_negative ? -sum : sum;
        // Usar conversion a double directamente
        double sum_as_double = static_cast<double>(abs_sum.low());
        double result = sum_as_double / count;
        return is_negative ? -result : result;
    }

    bool has_negative_values() const
    {
        return negative_count > 0;
    }
    bool has_positive_values() const
    {
        return positive_count > 0;
    }
    bool has_zero_values() const
    {
        return zero_count > 0;
    }
};

/**
 * @brief Calcula estadisticas basicas de un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Estructura con estadisticas basicas
 *
 * @test test_calculate_stats
 * @code{.cpp}
 * // Calcula min, max, sum, count, contadores de signo y mean
 * auto stats = calculate_stats(vec.begin(), vec.end());
 * assert(stats.min_value == int128_t(-30) && stats.max_value == int128_t(40));
 * assert(stats.negative_count == 2 && stats.positive_count == 2);
 * @endcode
 */
template <std::input_iterator InputIt>
int128_stats calculate_stats(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, int128_t>
{
    if (first == last) {
        return {int128_t(0), int128_t(0), int128_t(0), 0, 0, 0, 0};
    }

    int128_stats stats;
    stats.min_value = stats.max_value = stats.sum = *first;
    stats.count = 1;
    stats.negative_count = (*first < int128_t(0)) ? 1 : 0;
    stats.positive_count = (*first > int128_t(0)) ? 1 : 0;
    stats.zero_count = (*first == int128_t(0)) ? 1 : 0;

    ++first;
    while (first != last) {
        const int128_t& value = *first++;
        stats.min_value = std::min(stats.min_value, value);
        stats.max_value = std::max(stats.max_value, value);
        stats.sum += value;
        ++stats.count;

        if (value < int128_t(0))
            ++stats.negative_count;
        else if (value > int128_t(0))
            ++stats.positive_count;
        else
            ++stats.zero_count;
    }

    return stats;
}

} // namespace int128_algorithm

} // namespace nstd

#endif // INT128_ALGORITHM_HPP