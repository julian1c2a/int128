/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_FACTORY_HPP
#define INT128_FACTORY_HPP

#include "../uint128/uint128_t.hpp"
#include "int128_t.hpp"
#include <cstdint>
#include <string>
#include <type_traits>

// =============================================================================
// FUNCIONES DE FÁBRICA PARA UINT128_T
// =============================================================================

/**
 * @brief Crea un uint128_t desde dos valores uint64_t
 * @param high Parte alta (64 bits superiores)
 * @param low Parte baja (64 bits inferiores)
 * @return uint128_t construido
 */
constexpr uint128_t make_uint128(uint64_t high, uint64_t low) noexcept
{
    uint128_t result{};
    result.set_high(high);
    result.set_low(low);
    return result;
}

/**
 * @brief Crea un uint128_t desde un tipo integral
 * @param value Valor integral a convertir
 * @return uint128_t construido
 */
template <typename T>
constexpr uint128_t make_uint128(T value) noexcept
    requires(std::is_integral_v<T> && !std::is_same_v<T, bool>)
{
    uint128_t result{};
    if constexpr (std::is_signed_v<T>) {
        if (value < 0) {
            // Para valores negativos, convertir a uint64_t y extender signo
            uint64_t val = static_cast<uint64_t>(static_cast<int64_t>(value));
            result.set_low(val);
            result.set_high(UINT64_MAX); // Extensión de signo
        } else {
            result.set_low(static_cast<uint64_t>(value));
            result.set_high(0);
        }
    } else {
        result.set_low(static_cast<uint64_t>(value));
        result.set_high(0);
    }
    return result;
}

/**
 * @brief Crea un uint128_t desde una cadena
 * @param str Cadena que representa el número
 * @param base Base numérica (por defecto 10)
 * @return uint128_t construido
 */
uint128_t make_uint128(const std::string& str, int base = 10);

/**
 * @brief Crea un uint128_t cero
 * @return uint128_t inicializado en cero
 */
constexpr uint128_t make_uint128_zero() noexcept
{
    return uint128_t{};
}

/**
 * @brief Crea un uint128_t con valor uno
 * @return uint128_t inicializado en uno
 */
constexpr uint128_t make_uint128_one() noexcept
{
    uint128_t result{};
    result.set_low(1);
    result.set_high(0);
    return result;
}

/**
 * @brief Crea un uint128_t con valor máximo
 * @return uint128_t inicializado con valor máximo
 */
constexpr uint128_t make_uint128_max() noexcept
{
    uint128_t result{};
    result.set_high(UINT64_MAX);
    result.set_low(UINT64_MAX);
    return result;
}

// =============================================================================
// FUNCIONES DE FÁBRICA PARA INT128_T
// =============================================================================

/**
 * @brief Crea un int128_t desde dos valores uint64_t
 * @param high Parte alta (64 bits superiores, MSB es signo)
 * @param low Parte baja (64 bits inferiores)
 * @return int128_t construido
 */
constexpr int128_t make_int128(uint64_t high, uint64_t low) noexcept
{
    int128_t result{};
    result.set_high(high);
    result.set_low(low);
    return result;
}

/**
 * @brief Crea un int128_t desde un tipo integral
 * @param value Valor integral a convertir
 * @return int128_t construido
 */
template <typename T>
constexpr int128_t make_int128(T value) noexcept
    requires(std::is_integral_v<T> && !std::is_same_v<T, bool>)
{
    int128_t result{};
    if constexpr (std::is_signed_v<T>) {
        int64_t val = static_cast<int64_t>(value);
        result.set_low(static_cast<uint64_t>(val));
        result.set_high(val < 0 ? UINT64_MAX : 0); // Extensión de signo
    } else {
        uint64_t val = static_cast<uint64_t>(value);
        result.set_low(val);
        result.set_high(0);
    }
    return result;
}

/**
 * @brief Crea un int128_t desde un uint128_t (interpretación directa)
 * @param value uint128_t a interpretar como int128_t
 * @return int128_t construido
 */
constexpr int128_t make_int128(const uint128_t& value) noexcept
{
    int128_t result{};
    result.set_low(value.low());
    result.set_high(value.high());
    return result;
}

/**
 * @brief Crea un int128_t desde una cadena
 * @param str Cadena que representa el número
 * @param base Base numérica (por defecto 10)
 * @return int128_t construido
 */
int128_t make_int128(const std::string& str, int base = 10);

/**
 * @brief Crea un int128_t cero
 * @return int128_t inicializado en cero
 */
constexpr int128_t make_int128_zero() noexcept
{
    return int128_t{};
}

/**
 * @brief Crea un int128_t con valor uno
 * @return int128_t inicializado en uno
 */
constexpr int128_t make_int128_one() noexcept
{
    int128_t result{};
    result.set_low(1);
    result.set_high(0);
    return result;
}

/**
 * @brief Crea un int128_t con valor menos uno
 * @return int128_t inicializado en -1
 */
constexpr int128_t make_int128_minus_one() noexcept
{
    int128_t result{};
    result.set_low(UINT64_MAX);
    result.set_high(UINT64_MAX);
    return result;
}

/**
 * @brief Crea un int128_t con valor máximo (2^127 - 1)
 * @return int128_t inicializado con valor máximo
 */
constexpr int128_t make_int128_max() noexcept
{
    int128_t result{};
    result.set_high(0x7FFFFFFFFFFFFFFFULL);
    result.set_low(UINT64_MAX);
    return result;
}

/**
 * @brief Crea un int128_t con valor mínimo (-2^127)
 * @return int128_t inicializado con valor mínimo
 */
constexpr int128_t make_int128_min() noexcept
{
    int128_t result{};
    result.set_high(0x8000000000000000ULL);
    result.set_low(0);
    return result;
}

// =============================================================================
// FUNCIONES DE CONVERSIÓN Y UTILIDAD
// =============================================================================

/**
 * @brief Convierte un int128_t a uint128_t (interpretación directa de bits)
 * @param value int128_t a convertir
 * @return uint128_t resultado
 */
constexpr uint128_t int128_to_uint128(const int128_t& value) noexcept
{
    return make_uint128(value.high(), value.low());
}

/**
 * @brief Convierte un uint128_t a int128_t (interpretación directa de bits)
 * @param value uint128_t a convertir
 * @return int128_t resultado
 */
constexpr int128_t uint128_to_int128(const uint128_t& value) noexcept
{
    return make_int128(value.high(), value.low());
}

/**
 * @brief Convierte de forma segura un uint128_t a int128_t verificando overflow
 * @param value uint128_t a convertir
 * @return int128_t resultado si es válido
 * @throws std::overflow_error si el valor no cabe en int128_t
 */
int128_t safe_uint128_to_int128(const uint128_t& value);

/**
 * @brief Convierte de forma segura un int128_t a uint128_t verificando underflow
 * @param value int128_t a convertir
 * @return uint128_t resultado si es válido
 * @throws std::underflow_error si el valor es negativo
 */
uint128_t safe_int128_to_uint128(const int128_t& value);

// =============================================================================
// FUNCIONES AUXILIARES PARA BACKWARD COMPATIBILITY
// =============================================================================

/**
 * @brief Alias para make_uint128 (compatibilidad)
 */
template <typename... Args>
constexpr auto uint128(Args&&... args) noexcept
    -> decltype(make_uint128(std::forward<Args>(args)...))
{
    return make_uint128(std::forward<Args>(args)...);
}

/**
 * @brief Alias para make_int128 (compatibilidad)
 */
template <typename... Args>
constexpr auto int128(Args&&... args) noexcept -> decltype(make_int128(std::forward<Args>(args)...))
{
    return make_int128(std::forward<Args>(args)...);
}

#endif // INT128_FACTORY_HPP