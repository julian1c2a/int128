/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_BASE_BITS_HPP
#define INT128_BASE_BITS_HPP

/**
 * @file int128_base_bits.hpp
 * @brief Operaciones de manipulación de bits para int128_base_t<S>
 * @author Julián Calderón Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.66.0
 * @date 2026-01-05
 * @copyright Boost Software License 1.0
 *
 * Proporciona funciones de manipulación de bits optimizadas que funcionan
 * con el template unificado int128_base_t<signedness S>:
 * - popcount, countl_zero, countr_zero, countl_one, countr_one
 * - bit_width, has_single_bit, bit_floor, bit_ceil
 * - rotl, rotr, reverse_bits, byteswap
 * - extract_bits, insert_bits, test_bit, set_bit, clear_bit, flip_bit
 * - find_first_set, find_last_set
 * - to_bitset, from_bitset
 */

#include "int128_base_tt.hpp"
#include "intrinsics/bit_operations.hpp"
#include <bitset>
#include <type_traits>

namespace nstd
{

    // =============================================================================
    // FUNCIONES BÁSICAS DE CONTEO DE BITS
    // =============================================================================

    /**
     * @brief Cuenta el número de bits establecidos (population count)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Número de bits establecidos (0-128)
     */
    template <signedness S>
    inline constexpr int popcount(const int128_base_t<S> &value) noexcept
    {
        return intrinsics::popcount64(value.high()) + intrinsics::popcount64(value.low());
    }

    /**
     * @brief Cuenta ceros a la izquierda (leading zeros)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Número de ceros a la izquierda (0-128)
     *
     * @note Para tipos signed negativos, siempre retorna 0 (MSB es 1)
     */
    template <signedness S>
    inline constexpr int countl_zero(const int128_base_t<S> &value) noexcept
    {
        // Para tipos signed negativos, el bit de signo es 1 → 0 leading zeros
        if constexpr (S == signedness::signed_type)
        {
            if (value.is_negative())
            {
                return 0;
            }
        }

        if (value.high() != 0)
        {
            return intrinsics::clz64(value.high());
        }
        else if (value.low() != 0)
        {
            return 64 + intrinsics::clz64(value.low());
        }
        else
        {
            return 128;
        }
    }

    /**
     * @brief Cuenta ceros a la derecha (trailing zeros)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Número de ceros a la derecha (0-128)
     */
    template <signedness S>
    inline constexpr int countr_zero(const int128_base_t<S> &value) noexcept
    {
        if (value.low() != 0)
        {
            return intrinsics::ctz64(value.low());
        }
        else if (value.high() != 0)
        {
            return 64 + intrinsics::ctz64(value.high());
        }
        else
        {
            return 128;
        }
    }

    /**
     * @brief Cuenta unos a la izquierda (leading ones)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Número de unos a la izquierda (0-128)
     *
     * @note Para tipos signed positivos/cero, siempre retorna 0 (MSB es 0)
     */
    template <signedness S>
    inline constexpr int countl_one(const int128_base_t<S> &value) noexcept
    {
        // Para tipos signed positivos/cero, el bit de signo es 0 → 0 leading ones
        if constexpr (S == signedness::signed_type)
        {
            if (!value.is_negative())
            {
                return 0;
            }
        }

        constexpr uint64_t ALL_ONES = ~uint64_t(0);

        if (value.high() == ALL_ONES)
        {
            if (value.low() == ALL_ONES)
            {
                return 128;
            }
            else
            {
                // high es todo 1s, contar leading 1s en ~low
                return 64 + intrinsics::clz64(~value.low());
            }
        }
        else
        {
            // high no es todo 1s, contar leading 1s en high
            return intrinsics::clz64(~value.high());
        }
    }

    /**
     * @brief Cuenta unos a la derecha (trailing ones)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Número de unos a la derecha (0-128)
     */
    template <signedness S>
    inline constexpr int countr_one(const int128_base_t<S> &value) noexcept
    {
        constexpr uint64_t ALL_ONES = ~uint64_t(0);

        if (value.low() == ALL_ONES)
        {
            if (value.high() == ALL_ONES)
            {
                return 128;
            }
            else
            {
                // low es todo 1s, contar trailing 1s en high
                return 64 + intrinsics::ctz64(~value.high());
            }
        }
        else
        {
            // low no es todo 1s, contar trailing 1s en ~low
            return intrinsics::ctz64(~value.low());
        }
    }

    /**
     * @brief Ancho de bits (número de bits necesarios para representar el valor)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Número de bits necesarios (0-128)
     *
     * @note Para tipos signed negativos, retorna 128 (usan todos los bits)
     */
    template <signedness S>
    inline constexpr int bit_width(const int128_base_t<S> &value) noexcept
    {
        if constexpr (S == signedness::signed_type)
        {
            if (value.is_negative())
            {
                return 128; // Los números negativos usan todos los bits
            }
        }
        return 128 - countl_zero(value);
    }

    /**
     * @brief Verifica si el valor tiene exactamente un bit establecido
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return true si es potencia de 2 (exactamente 1 bit establecido)
     *
     * @note Para tipos signed, solo valores positivos pueden ser potencias de 2
     */
    template <signedness S>
    inline constexpr bool has_single_bit(const int128_base_t<S> &value) noexcept
    {
        if constexpr (S == signedness::signed_type)
        {
            if (value.is_negative() || value.is_zero())
            {
                return false;
            }
        }
        else
        {
            if (value.is_zero())
            {
                return false;
            }
        }
        return popcount(value) == 1;
    }

    /**
     * @brief Mayor potencia de 2 no mayor que value (bit_floor)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Mayor potencia de 2 ≤ value, o 0 si value ≤ 0
     */
    template <signedness S>
    inline constexpr int128_base_t<S> bit_floor(const int128_base_t<S> &value) noexcept
    {
        if constexpr (S == signedness::signed_type)
        {
            if (value.is_negative() || value.is_zero())
            {
                return int128_base_t<S>(0);
            }
        }
        else
        {
            if (value.is_zero())
            {
                return int128_base_t<S>(0);
            }
        }

        int width = bit_width(value);
        return int128_base_t<S>(1) << (width - 1);
    }

    /**
     * @brief Menor potencia de 2 no menor que value (bit_ceil)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Menor potencia de 2 ≥ value
     *
     * @note Para negativos, retorna 1 (la menor potencia de 2 positiva)
     */
    template <signedness S>
    inline constexpr int128_base_t<S> bit_ceil(const int128_base_t<S> &value) noexcept
    {
        if constexpr (S == signedness::signed_type)
        {
            if (value.is_negative())
            {
                return int128_base_t<S>(0);
            }
        }

        if (value <= int128_base_t<S>(1))
        {
            return int128_base_t<S>(1);
        }

        int width = bit_width(value - int128_base_t<S>(1));
        return int128_base_t<S>(1) << width;
    }

    // =============================================================================
    // ROTACIONES Y MANIPULACIÓN DE BYTES
    // =============================================================================

    /**
     * @brief Rotación a la izquierda
     * @tparam S signedness del tipo
     * @param value Valor a rotar
     * @param shift Número de posiciones a rotar
     * @return Valor rotado
     */
    template <signedness S>
    inline constexpr int128_base_t<S> rotl(const int128_base_t<S> &value, int shift) noexcept
    {
        shift %= 128;
        if (shift == 0)
            return value;
        if (shift < 0)
            shift += 128;

        // Trabajar con representación unsigned para rotación
        uint128_t uval = static_cast<uint128_t>(value);
        uint128_t result = (uval << shift) | (uval >> (128 - shift));
        return static_cast<int128_base_t<S>>(result);
    }

    /**
     * @brief Rotación a la derecha
     * @tparam S signedness del tipo
     * @param value Valor a rotar
     * @param shift Número de posiciones a rotar
     * @return Valor rotado
     */
    template <signedness S>
    inline constexpr int128_base_t<S> rotr(const int128_base_t<S> &value, int shift) noexcept
    {
        shift %= 128;
        if (shift == 0)
            return value;
        if (shift < 0)
            shift += 128;

        // Trabajar con representación unsigned para rotación
        uint128_t uval = static_cast<uint128_t>(value);
        uint128_t result = (uval >> shift) | (uval << (128 - shift));
        return static_cast<int128_base_t<S>>(result);
    }

    namespace detail
    {

        /**
         * @brief Helper para revertir bits de 64 bits
         */
        inline constexpr uint64_t reverse64_impl(uint64_t v) noexcept
        {
            v = ((v >> 1) & 0x5555555555555555ULL) | ((v & 0x5555555555555555ULL) << 1);
            v = ((v >> 2) & 0x3333333333333333ULL) | ((v & 0x3333333333333333ULL) << 2);
            v = ((v >> 4) & 0x0F0F0F0F0F0F0F0FULL) | ((v & 0x0F0F0F0F0F0F0F0FULL) << 4);
            v = ((v >> 8) & 0x00FF00FF00FF00FFULL) | ((v & 0x00FF00FF00FF00FFULL) << 8);
            v = ((v >> 16) & 0x0000FFFF0000FFFFULL) | ((v & 0x0000FFFF0000FFFFULL) << 16);
            v = (v >> 32) | (v << 32);
            return v;
        }

        /**
         * @brief Helper para intercambiar bytes de 64 bits
         */
        inline constexpr uint64_t byteswap64_impl(uint64_t v) noexcept
        {
#if defined(__GNUC__) || defined(__clang__)
            if (!INTRINSICS_IS_CONSTANT_EVALUATED())
            {
                return __builtin_bswap64(v);
            }
#elif defined(_MSC_VER)
            if (!INTRINSICS_IS_CONSTANT_EVALUATED())
            {
                return _byteswap_uint64(v);
            }
#endif
            // Fallback constexpr
            return ((v & 0x00000000000000FFULL) << 56) | ((v & 0x000000000000FF00ULL) << 40) |
                   ((v & 0x0000000000FF0000ULL) << 24) | ((v & 0x00000000FF000000ULL) << 8) |
                   ((v & 0x000000FF00000000ULL) >> 8) | ((v & 0x0000FF0000000000ULL) >> 24) |
                   ((v & 0x00FF000000000000ULL) >> 40) | ((v & 0xFF00000000000000ULL) >> 56);
        }

    } // namespace detail

    /**
     * @brief Revierte todos los bits
     * @tparam S signedness del tipo
     * @param value Valor a revertir
     * @return Valor con bits en orden inverso
     */
    template <signedness S>
    inline constexpr int128_base_t<S> reverse_bits(const int128_base_t<S> &value) noexcept
    {
        // Revertir cada parte de 64 bits e intercambiar posiciones
        return int128_base_t<S>(detail::reverse64_impl(value.low()),
                                detail::reverse64_impl(value.high()));
    }

    /**
     * @brief Intercambia bytes (endianness swap)
     * @tparam S signedness del tipo
     * @param value Valor a convertir
     * @return Valor con bytes en orden inverso
     */
    template <signedness S>
    inline constexpr int128_base_t<S> byteswap(const int128_base_t<S> &value) noexcept
    {
        return int128_base_t<S>(detail::byteswap64_impl(value.low()),
                                detail::byteswap64_impl(value.high()));
    }

    // =============================================================================
    // OPERACIONES DE CAMPOS DE BITS
    // =============================================================================

    /**
     * @brief Extrae un campo de bits
     * @tparam S signedness del tipo
     * @param value Valor fuente
     * @param offset Posición inicial (0-based, desde LSB)
     * @param width Número de bits a extraer
     * @return Campo de bits extraído
     */
    template <signedness S>
    inline constexpr int128_base_t<S> extract_bits(const int128_base_t<S> &value, int offset,
                                                   int width) noexcept
    {
        if (width <= 0 || offset < 0 || offset >= 128)
        {
            return int128_base_t<S>(0);
        }

        if (offset + width > 128)
        {
            width = 128 - offset;
        }

        // Trabajar con uint128_t para evitar problemas de signo
        uint128_t uval = static_cast<uint128_t>(value);

        // Desplazar a la derecha para mover los bits deseados a la posición LSB
        uval >>= offset;

        // Crear máscara para los bits deseados
        if (width == 128)
        {
            return static_cast<int128_base_t<S>>(uval);
        }

        uint128_t mask = (uint128_t(1) << width) - uint128_t(1);
        return static_cast<int128_base_t<S>>(uval & mask);
    }

    /**
     * @brief Inserta un campo de bits
     * @tparam S signedness del tipo
     * @param dest Valor destino
     * @param src Bits a insertar
     * @param offset Posición inicial (0-based, desde LSB)
     * @param width Número de bits a insertar
     * @return Valor con bits insertados
     */
    template <signedness S>
    inline constexpr int128_base_t<S> insert_bits(const int128_base_t<S> &dest,
                                                  const int128_base_t<S> &src, int offset,
                                                  int width) noexcept
    {
        if (width <= 0 || offset < 0 || offset >= 128)
        {
            return dest;
        }

        if (offset + width > 128)
        {
            width = 128 - offset;
        }

        uint128_t udest = static_cast<uint128_t>(dest);
        uint128_t usrc = static_cast<uint128_t>(src);

        // Crear máscara para limpiar el área de destino
        uint128_t mask;
        if (width == 128)
        {
            mask = uint128_t(0);
        }
        else
        {
            mask = (uint128_t(1) << width) - uint128_t(1);
        }

        // Limpiar bits del dest
        udest &= ~(mask << offset);

        // Limpiar bits extra del src e insertar
        usrc &= mask;
        udest |= (usrc << offset);

        return static_cast<int128_base_t<S>>(udest);
    }

    // =============================================================================
    // OPERACIONES DE BITS INDIVIDUALES
    // =============================================================================

    /**
     * @brief Prueba si un bit específico está establecido
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @param position Posición del bit (0-127)
     * @return true si el bit está establecido
     */
    template <signedness S>
    inline constexpr bool test_bit(const int128_base_t<S> &value, int position) noexcept
    {
        if (position < 0 || position >= 128)
        {
            return false;
        }

        if (position < 64)
        {
            return (value.low() & (uint64_t(1) << position)) != 0;
        }
        else
        {
            return (value.high() & (uint64_t(1) << (position - 64))) != 0;
        }
    }

    /**
     * @brief Establece un bit específico
     * @tparam S signedness del tipo
     * @param value Valor a modificar
     * @param position Posición del bit (0-127)
     * @param bit_value Valor del bit (true=1, false=0)
     * @return Valor con el bit establecido
     */
    template <signedness S>
    inline constexpr int128_base_t<S> set_bit(const int128_base_t<S> &value, int position,
                                              bool bit_value = true) noexcept
    {
        if (position < 0 || position >= 128)
        {
            return value;
        }

        uint128_t uval = static_cast<uint128_t>(value);

        if (bit_value)
        {
            uval |= (uint128_t(1) << position);
        }
        else
        {
            uval &= ~(uint128_t(1) << position);
        }

        return static_cast<int128_base_t<S>>(uval);
    }

    /**
     * @brief Limpia un bit específico
     * @tparam S signedness del tipo
     * @param value Valor a modificar
     * @param position Posición del bit (0-127)
     * @return Valor con el bit limpiado
     */
    template <signedness S>
    inline constexpr int128_base_t<S> clear_bit(const int128_base_t<S> &value, int position) noexcept
    {
        return set_bit(value, position, false);
    }

    /**
     * @brief Invierte un bit específico
     * @tparam S signedness del tipo
     * @param value Valor a modificar
     * @param position Posición del bit (0-127)
     * @return Valor con el bit invertido
     */
    template <signedness S>
    inline constexpr int128_base_t<S> flip_bit(const int128_base_t<S> &value, int position) noexcept
    {
        if (position < 0 || position >= 128)
        {
            return value;
        }

        uint128_t uval = static_cast<uint128_t>(value);
        uval ^= (uint128_t(1) << position);
        return static_cast<int128_base_t<S>>(uval);
    }

    // =============================================================================
    // BÚSQUEDA DE BITS
    // =============================================================================

    /**
     * @brief Encuentra el primer bit establecido (LSB a MSB)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Posición del primer bit establecido (0-based), o -1 si ninguno
     */
    template <signedness S>
    inline constexpr int find_first_set(const int128_base_t<S> &value) noexcept
    {
        if (value.is_zero())
        {
            return -1;
        }
        return countr_zero(value);
    }

    /**
     * @brief Encuentra el último bit establecido (MSB a LSB)
     * @tparam S signedness del tipo
     * @param value Valor a examinar
     * @return Posición del último bit establecido (0-based), o -1 si ninguno
     *
     * @note Para tipos signed negativos, el bit de signo (127) siempre está establecido
     */
    template <signedness S>
    inline constexpr int find_last_set(const int128_base_t<S> &value) noexcept
    {
        if (value.is_zero())
        {
            return -1;
        }

        if constexpr (S == signedness::signed_type)
        {
            if (value.is_negative())
            {
                return 127; // El bit de signo siempre está establecido
            }
        }

        return 127 - countl_zero(value);
    }

    // =============================================================================
    // CONVERSIÓN A/DESDE BITSET
    // =============================================================================

    /**
     * @brief Convierte int128_base_t a std::bitset<128>
     * @tparam S signedness del tipo
     * @param value Valor a convertir
     * @return std::bitset<128> con los mismos bits
     */
    template <signedness S>
    inline constexpr std::bitset<128> to_bitset(const int128_base_t<S> &value) noexcept
    {
        std::bitset<128> result;

        // Establecer bits para los 64 bits bajos
        for (int i = 0; i < 64; ++i)
        {
            if ((value.low() & (uint64_t(1) << i)) != 0)
            {
                result.set(i);
            }
        }

        // Establecer bits para los 64 bits altos
        for (int i = 0; i < 64; ++i)
        {
            if ((value.high() & (uint64_t(1) << i)) != 0)
            {
                result.set(64 + i);
            }
        }

        return result;
    }

    /**
     * @brief Convierte std::bitset a int128_base_t
     * @tparam S signedness del tipo destino
     * @tparam N Tamaño del bitset (máximo 128)
     * @param bs Bitset a convertir
     * @return int128_base_t con los mismos bits
     */
    template <signedness S, size_t N>
    inline constexpr int128_base_t<S> from_bitset(const std::bitset<N> &bs) noexcept
    {
        static_assert(N <= 128, "Bitset size cannot exceed 128 bits");

        uint64_t low_part = 0;
        uint64_t high_part = 0;

        // Extraer los 64 bits bajos
        for (int i = 0; i < 64 && i < static_cast<int>(N); ++i)
        {
            if (bs[i])
            {
                low_part |= (uint64_t(1) << i);
            }
        }

        // Extraer los 64 bits altos
        for (int i = 64; i < 128 && i < static_cast<int>(N); ++i)
        {
            if (bs[i])
            {
                high_part |= (uint64_t(1) << (i - 64));
            }
        }

        return int128_base_t<S>(high_part, low_part);
    }

    // =============================================================================
    // OPERACIONES PDEP/PEXT (PARALLEL DEPOSIT/EXTRACT)
    // =============================================================================

    /**
     * @brief Parallel bit deposit (PDEP)
     * @tparam S signedness del tipo
     * @param value Bits fuente a depositar
     * @param mask Máscara indicando posiciones destino
     * @return Valor con bits depositados según la máscara
     */
    template <signedness S>
    inline constexpr int128_base_t<S> parallel_deposit(const int128_base_t<S> &value,
                                                       const int128_base_t<S> &mask) noexcept
    {
        uint128_t result(0);
        uint128_t uval = static_cast<uint128_t>(value);
        uint128_t umask = static_cast<uint128_t>(mask);
        uint128_t src_bit(1);

        for (int i = 0; i < 128; ++i)
        {
            if ((umask & (uint128_t(1) << i)) != uint128_t(0))
            {
                if ((uval & src_bit) != uint128_t(0))
                {
                    result |= (uint128_t(1) << i);
                }
                src_bit <<= 1;
            }
        }

        return static_cast<int128_base_t<S>>(result);
    }

    /**
     * @brief Parallel bit extract (PEXT)
     * @tparam S signedness del tipo
     * @param value Valor fuente
     * @param mask Máscara indicando posiciones a extraer
     * @return Bits extraídos empaquetados desde LSB
     */
    template <signedness S>
    inline constexpr int128_base_t<S> parallel_extract(const int128_base_t<S> &value,
                                                       const int128_base_t<S> &mask) noexcept
    {
        uint128_t result(0);
        uint128_t uval = static_cast<uint128_t>(value);
        uint128_t umask = static_cast<uint128_t>(mask);
        uint128_t dst_bit(1);

        for (int i = 0; i < 128; ++i)
        {
            if ((umask & (uint128_t(1) << i)) != uint128_t(0))
            {
                if ((uval & (uint128_t(1) << i)) != uint128_t(0))
                {
                    result |= dst_bit;
                }
                dst_bit <<= 1;
            }
        }

        return static_cast<int128_base_t<S>>(result);
    }

} // namespace nstd

#endif // INT128_BASE_BITS_HPP
