/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @file int128_base_traits.hpp
 * @brief Type traits adicionales para int128_base_t<S> unificado
 *
 * Proporciona especializaciones adicionales a las de int128_base_traits_specializations.hpp:
 * - common_type entre int128 y tipos estándar
 * - hash para contenedores unordered
 *
 * @note Fase 1.5: Template unificado para signed/unsigned
 * @note Los traits básicos (is_integral, is_signed, etc.) están en
 * int128_base_traits_specializations.hpp
 */

#ifndef INT128_BASE_TRAITS_HPP
#define INT128_BASE_TRAITS_HPP

#include "int128_base_tt.hpp"
#include <functional>
#include <type_traits>

namespace nstd
{

// =============================================================================
// COMMON_TYPE - Template base y especializaciones
// =============================================================================

// Template base (no tiene definición por defecto)
template <typename T1, typename T2> struct common_type {
};

// Helper _t
template <typename T1, typename T2> using common_type_t = typename common_type<T1, T2>::type;

// --- int128_base_t<S> consigo mismo ---
template <signedness S> struct common_type<int128_base_t<S>, int128_base_t<S>> {
    using type = int128_base_t<S>;
};

// --- uint128_t con int128_t -> int128_t (signed tiene prioridad) ---
template <>
struct common_type<int128_base_t<signedness::unsigned_type>,
                   int128_base_t<signedness::signed_type>> {
    using type = int128_base_t<signedness::signed_type>;
};
template <>
struct common_type<int128_base_t<signedness::signed_type>,
                   int128_base_t<signedness::unsigned_type>> {
    using type = int128_base_t<signedness::signed_type>;
};

// --- uint128_t con tipos integrales estándar ---
template <> struct common_type<uint128_t, uint64_t> {
    using type = uint128_t;
};
template <> struct common_type<uint64_t, uint128_t> {
    using type = uint128_t;
};
template <> struct common_type<uint128_t, uint32_t> {
    using type = uint128_t;
};
template <> struct common_type<uint32_t, uint128_t> {
    using type = uint128_t;
};
template <> struct common_type<uint128_t, uint16_t> {
    using type = uint128_t;
};
template <> struct common_type<uint16_t, uint128_t> {
    using type = uint128_t;
};
template <> struct common_type<uint128_t, uint8_t> {
    using type = uint128_t;
};
template <> struct common_type<uint8_t, uint128_t> {
    using type = uint128_t;
};
template <> struct common_type<uint128_t, int64_t> {
    using type = uint128_t;
};
template <> struct common_type<int64_t, uint128_t> {
    using type = uint128_t;
};
template <> struct common_type<uint128_t, int32_t> {
    using type = uint128_t;
};
template <> struct common_type<int32_t, uint128_t> {
    using type = uint128_t;
};
template <> struct common_type<uint128_t, int16_t> {
    using type = uint128_t;
};
template <> struct common_type<int16_t, uint128_t> {
    using type = uint128_t;
};
template <> struct common_type<uint128_t, int8_t> {
    using type = uint128_t;
};
template <> struct common_type<int8_t, uint128_t> {
    using type = uint128_t;
};

// --- int128_t con tipos integrales estándar ---
template <> struct common_type<int128_t, int64_t> {
    using type = int128_t;
};
template <> struct common_type<int64_t, int128_t> {
    using type = int128_t;
};
template <> struct common_type<int128_t, int32_t> {
    using type = int128_t;
};
template <> struct common_type<int32_t, int128_t> {
    using type = int128_t;
};
template <> struct common_type<int128_t, int16_t> {
    using type = int128_t;
};
template <> struct common_type<int16_t, int128_t> {
    using type = int128_t;
};
template <> struct common_type<int128_t, int8_t> {
    using type = int128_t;
};
template <> struct common_type<int8_t, int128_t> {
    using type = int128_t;
};
template <> struct common_type<int128_t, uint64_t> {
    using type = int128_t;
};
template <> struct common_type<uint64_t, int128_t> {
    using type = int128_t;
};
template <> struct common_type<int128_t, uint32_t> {
    using type = int128_t;
};
template <> struct common_type<uint32_t, int128_t> {
    using type = int128_t;
};
template <> struct common_type<int128_t, uint16_t> {
    using type = int128_t;
};
template <> struct common_type<uint16_t, int128_t> {
    using type = int128_t;
};
template <> struct common_type<int128_t, uint8_t> {
    using type = int128_t;
};
template <> struct common_type<uint8_t, int128_t> {
    using type = int128_t;
};

// =============================================================================
// VERIFICACIONES ESTÁTICAS
// =============================================================================

// Verificar que los traits básicos funcionan (definidos en int128_base_traits_specializations.hpp)
static_assert(is_integral_v<uint128_t>, "uint128_t debe ser integral");
static_assert(is_integral_v<int128_t>, "int128_t debe ser integral");
static_assert(is_unsigned_v<uint128_t>, "uint128_t debe ser unsigned");
static_assert(!is_unsigned_v<int128_t>, "int128_t no debe ser unsigned");
static_assert(!is_signed_v<uint128_t>, "uint128_t no debe ser signed");
static_assert(is_signed_v<int128_t>, "int128_t debe ser signed");
static_assert(is_arithmetic_v<uint128_t>, "uint128_t debe ser arithmetic");
static_assert(is_arithmetic_v<int128_t>, "int128_t debe ser arithmetic");

// Verificar make_signed/make_unsigned
static_assert(std::is_same_v<make_signed_t<uint128_t>, int128_t>,
              "make_signed<uint128_t> debe ser int128_t");
static_assert(std::is_same_v<make_unsigned_t<int128_t>, uint128_t>,
              "make_unsigned<int128_t> debe ser uint128_t");

// Verificar common_type
static_assert(std::is_same_v<common_type_t<uint128_t, int128_t>, int128_t>,
              "common_type<uint128_t, int128_t> debe ser int128_t");

} // namespace nstd

#endif // INT128_BASE_TRAITS_HPP
