/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef UINT128_IOSTREAMS_HPP
#define UINT128_IOSTREAMS_HPP

#include "uint128_t.hpp"
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

/**
 * @brief Soporte completo de iostreams con iomanip para uint128_t
 *
 * Este archivo implementa soporte completo de formateo para uint128_t,
 * incluyendo todos los manipuladores estándar de iomanip:
 * - Bases: std::hex, std::oct, std::dec
 * - Ancho: std::setw()
 * - Relleno: std::setfill()
 * - Alineación: std::left, std::right, std::internal
 * - Prefijos: std::showbase, std::noshowbase
 * - Mayúsculas: std::uppercase, std::nouppercase
 */

namespace std
{

/**
 * @brief Operador de salida mejorado que respeta iomanip
 */
inline std::ostream& operator<<(std::ostream& os, const uint128_t& value)
{
    // Guardar el estado de formateo actual
    const auto flags = os.flags();
    const int base = (flags & std::ios_base::basefield);
    const bool show_base = (flags & std::ios_base::showbase);
    const bool uppercase = (flags & std::ios_base::uppercase);
    const auto width = os.width();
    const auto fill_char = os.fill();
    const auto alignment = (flags & std::ios_base::adjustfield);

    std::string result;

    // Determinar la base numérica
    switch (base) {
    case std::ios_base::hex:
        result = value.to_string_hex(show_base);
        if (uppercase) {
            // Convertir a mayúsculas
            for (char& c : result) {
                if (c >= 'a' && c <= 'f') {
                    c = c - 'a' + 'A';
                }
            }
        }
        break;

    case std::ios_base::oct:
        result = value.to_string_oct(show_base);
        break;

    default: // std::ios_base::dec o sin especificar
        result = value.to_string();
        if (show_base) {
            // Para decimal no hay prefijo estándar, pero algunos sistemas usan "#"
            // result = "#" + result; // Comentado - decimal no necesita prefijo
        }
        break;
    }

    // Aplicar ancho de campo y alineación
    if (width > 0 && static_cast<int>(result.length()) < width) {
        const int padding = width - static_cast<int>(result.length());

        switch (alignment) {
        case std::ios_base::left:
            result += std::string(padding, fill_char);
            break;

        case std::ios_base::internal:
            // Para internal, el relleno va después del prefijo pero antes del número
            if ((show_base && (base == std::ios_base::hex || base == std::ios_base::oct))) {
                if (base == std::ios_base::hex && result.substr(0, 2) == "0x") {
                    result = "0x" + std::string(padding, fill_char) + result.substr(2);
                } else if (base == std::ios_base::hex && result.substr(0, 2) == "0X") {
                    result = "0X" + std::string(padding, fill_char) + result.substr(2);
                } else if (base == std::ios_base::oct && result.substr(0, 1) == "0") {
                    result = "0" + std::string(padding, fill_char) + result.substr(1);
                } else {
                    result = std::string(padding, fill_char) + result; // fallback a right
                }
            } else {
                result = std::string(padding, fill_char) + result; // Sin prefijo, actúa como right
            }
            break;

        default: // std::ios_base::right o sin especificar
            result = std::string(padding, fill_char) + result;
            break;
        }
    }

    // Resetear width (comportamiento estándar de iostream)
    os.width(0);

    return os << result;
}

/**
 * @brief Operador de entrada mejorado que respeta la base
 */
inline std::istream& operator>>(std::istream& is, uint128_t& value)
{
    const auto flags = is.flags();
    const int base_flags = (flags & std::ios_base::basefield);

    std::string str;
    is >> str;

    if (is.good() || is.eof()) {
        // Determinar la base para la entrada
        int input_base = 10; // Por defecto decimal

        switch (base_flags) {
        case std::ios_base::hex:
            input_base = 16;
            break;
        case std::ios_base::oct:
            input_base = 8;
            break;
        default:
            // Auto-detectar la base si no está especificada
            if (str.length() >= 2 && str.substr(0, 2) == "0x") {
                input_base = 16;
            } else if (str.length() >= 1 && str[0] == '0' && str.length() > 1) {
                input_base = 8;
            } else {
                input_base = 10;
            }
            break;
        }

        try {
            value = uint128_t::from_string_base(str, input_base);
        } catch (const std::exception&) {
            is.setstate(std::ios_base::failbit);
        }
    }

    return is;
}

} // namespace std

// ===============================================================================
// FUNCIONES DE CONVENIENCIA PARA FORMATEO ESPECÍFICO
// ===============================================================================

namespace uint128_format
{

/**
 * @brief Formatea uint128_t con especificaciones completas
 */
inline std::string format(const uint128_t& value, int base = 10, int width = 0, char fill = ' ',
                          bool show_base = false, bool uppercase = false, bool left_align = false,
                          bool internal_align = false)
{

    std::ostringstream oss;

    // Configurar base
    switch (base) {
    case 16:
        oss << std::hex;
        break;
    case 8:
        oss << std::oct;
        break;
    default:
        oss << std::dec;
        break;
    }

    // Configurar opciones
    if (show_base)
        oss << std::showbase;
    if (uppercase)
        oss << std::uppercase;
    if (width > 0)
        oss << std::setw(width);
    if (fill != ' ')
        oss << std::setfill(fill);

    // Configurar alineación
    if (left_align) {
        oss << std::left;
    } else if (internal_align) {
        oss << std::internal;
    } else {
        oss << std::right; // Por defecto
    }

    // Generar resultado
    oss << value;
    return oss.str();
}

/**
 * @brief Formateo hexadecimal con opciones
 */
inline std::string hex(const uint128_t& value, int width = 0, bool show_base = false,
                       bool uppercase = false, char fill = '0')
{
    return format(value, 16, width, fill, show_base, uppercase, false, false);
}

/**
 * @brief Formateo octal con opciones
 */
inline std::string oct(const uint128_t& value, int width = 0, bool show_base = false,
                       char fill = '0')
{
    return format(value, 8, width, fill, show_base, false, false, false);
}

/**
 * @brief Formateo decimal con opciones
 */
inline std::string dec(const uint128_t& value, int width = 0, char fill = ' ',
                       bool left_align = false)
{
    return format(value, 10, width, fill, false, false, left_align, false);
}

} // namespace uint128_format

#endif // UINT128_IOSTREAMS_HPP