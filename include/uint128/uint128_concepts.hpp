/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef UINT128_CONCEPTS_HPP
#define UINT128_CONCEPTS_HPP

#include "uint128_t.hpp"
#include <concepts>
#include <type_traits>

namespace nstd
{

/**
 * @brief Conceptos personalizados para uint128_t
 *
 * Este archivo define conceptos C++20 específicos para trabajar con uint128_t
 * y proporciona herramientas de metaprogramación avanzadas.
 */

namespace uint128_concepts
{

using uint128_t = nstd::uint128_t;
using int128_t = nstd::int128_t;

// ===============================================================================
// CONCEPTOS BÁSICOS
// ===============================================================================

/**
 * @brief Concept para tipos que pueden convertirse a uint128_t
 *
 * @tparam T Tipo a verificar
 *
 * Un tipo satisface este concepto si es un tipo integral estándar
 * o es el mismo uint128_t.
 */
template <typename T>
concept uint128_convertible = std::integral<T> || std::same_as<T, uint128_t>;

/**
 * @brief Concept para tipos que son compatibles con operaciones de uint128_t
 *
 * @tparam T Tipo a verificar
 *
 * Incluye todos los tipos convertibles a uint128_t y también tipos
 * de punto flotante para operaciones mixtas.
 */
template <typename T>
concept uint128_compatible = uint128_convertible<T> || std::floating_point<T>;

/**
 * @brief Concept para tipos que pueden usar con operaciones bitwise
 *
 * @tparam T Tipo a verificar
 *
 * Solo tipos integrales pueden realizar operaciones bitwise seguras.
 */
template <typename T>
concept uint128_bitwise_compatible = std::integral<T> || std::same_as<T, uint128_t>;

// ===============================================================================
// CONCEPTOS PARA OPERACIONES ESPECÍFICAS
// ===============================================================================

/**
 * @brief Concept para tipos válidos en operaciones de desplazamiento
 *
 * @tparam T Tipo del operando de desplazamiento
 *
 * Los operandos de desplazamiento deben ser tipos integrales pequeños
 * para evitar comportamiento indefinido.
 */
template <typename T>
concept valid_shift_type = std::integral<T> && sizeof(T) <= 8;

/**
 * @brief Concept para tipos que pueden usarse como índices de bit
 *
 * @tparam T Tipo del índice
 *
 * Los índices de bit deben ser tipos enteros no negativos.
 */
template <typename T>
concept bit_index_type = std::unsigned_integral<T> && sizeof(T) <= 8;

/**
 * @brief Concept para tipos que pueden usarse en comparaciones con uint128_t
 *
 * @tparam T Tipo a comparar
 *
 * Las comparaciones son seguras con tipos integrales y uint128_t mismo.
 */
template <typename T>
concept uint128_comparable = std::integral<T> || std::same_as<T, uint128_t>;

// ===============================================================================
// CONCEPTOS PARA METAPROGRAMACIÓN
// ===============================================================================

/**
 * @brief Concept que verifica si un tipo puede ser promovido a uint128_t
 *
 * @tparam T Tipo a verificar
 *
 * Un tipo puede ser promovido si es un tipo integral más pequeño que uint128_t.
 */
template <typename T>
concept promotable_to_uint128 = std::integral<T> && sizeof(T) <= 16 && !std::same_as<T, uint128_t>;

/**
 * @brief Concept para funciones que pueden operar sobre uint128_t
 *
 * @tparam F Tipo de función
 * @tparam Args Tipos de argumentos
 *
 * Verifica que una función pueda ser llamada con uint128_t como primer argumento.
 */
template <typename F, typename... Args>
concept uint128_function = requires(F f, uint128_t u, Args... args) { f(u, args...); };

/**
 * @brief Concept para tipos que pueden actuar como contenedores de uint128_t
 *
 * @tparam Container Tipo de contenedor
 *
 * Verifica que el contenedor tenga las operaciones básicas necesarias.
 */
template <typename Container>
concept uint128_container = requires(Container c) {
    typename Container::value_type;
    requires std::same_as<typename Container::value_type, uint128_t>;
    c.begin();
    c.end();
    c.size();
};

// ===============================================================================
// CONCEPTOS PARA ALGORITMOS
// ===============================================================================

/**
 * @brief Concept para predicados que operan sobre uint128_t
 *
 * @tparam Pred Tipo del predicado
 *
 * Un predicado debe retornar un tipo convertible a bool cuando
 * se aplica a uint128_t.
 */
template <typename Pred>
concept uint128_predicate = requires(Pred p, uint128_t u) {
    { p(u) } -> std::convertible_to<bool>;
};

/**
 * @brief Concept para operaciones binarias sobre uint128_t
 *
 * @tparam BinaryOp Tipo de la operación binaria
 *
 * La operación debe poder tomar dos uint128_t y retornar un resultado.
 */
template <typename BinaryOp>
concept uint128_binary_operation = requires(BinaryOp op, uint128_t a, uint128_t b) { op(a, b); };

/**
 * @brief Concept para operaciones de reducción sobre uint128_t
 *
 * @tparam ReduceOp Tipo de la operación de reducción
 * @tparam T Tipo del valor inicial/acumulado
 *
 * La operación debe poder combinar un acumulador con un uint128_t.
 */
template <typename ReduceOp, typename T>
concept uint128_reduce_operation = requires(ReduceOp op, T acc, uint128_t u) {
    { op(acc, u) } -> std::convertible_to<T>;
};

} // namespace uint128_concepts

// ===============================================================================
// CONCEPTS EN NAMESPACE GLOBAL PARA COMPATIBILIDAD STL
// ===============================================================================

/**
 * @brief Verifica que uint128_t satisfaga los conceptos estándar de C++20
 *
 * Estas verificaciones se ejecutan en tiempo de compilación para
 * asegurar compatibilidad con la biblioteca estándar.
 */
namespace uint128_concept_checks
{

using uint128_t = nstd::uint128_t;
using int128_t = nstd::int128_t;

// Verificaciones básicas de conceptos
// NOTA: uint128_t es una clase, no un tipo integral nativo de C++,
// por lo que no satisface std::integral (requiere std::is_integral_v<T>)
// pero implementa todas las operaciones de un tipo entero sin signo.

// static_assert(std::integral<uint128_t>, "uint128_t debe satisfacer std::integral");
// static_assert(std::unsigned_integral<uint128_t>,
//               "uint128_t debe satisfacer std::unsigned_integral");
// static_assert(!std::signed_integral<uint128_t>,
//               "uint128_t no debe satisfacer std::signed_integral");

static_assert(std::regular<uint128_t>, "uint128_t debe satisfacer std::regular");
static_assert(std::totally_ordered<uint128_t>, "uint128_t debe satisfacer std::totally_ordered");

// Verificaciones de operaciones
static_assert(std::equality_comparable<uint128_t>, "uint128_t debe ser comparable por igualdad");
// NOTA: uint128_t no implementa operator<=> (C++20 three-way comparison)
// static_assert(std::three_way_comparable<uint128_t>,
//               "uint128_t debe soportar comparación a tres vías");

// Verificaciones de construcción y asignación
static_assert(std::default_initializable<uint128_t>, "uint128_t debe ser default-constructible");
static_assert(std::copy_constructible<uint128_t>, "uint128_t debe ser copy-constructible");
static_assert(std::move_constructible<uint128_t>, "uint128_t debe ser move-constructible");
static_assert(std::assignable_from<uint128_t&, const uint128_t&>,
              "uint128_t debe soportar asignación");

} // namespace uint128_concept_checks

} // namespace nstd