/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef UINT128_ALGORITHM_HPP
#define UINT128_ALGORITHM_HPP

#include "uint128_concepts.hpp"
#include "uint128_t.hpp"
#include <algorithm>
#include <functional>
#include <iterator>
#include <numeric>
#include <type_traits>

/**
 * @brief Algoritmos optimizados y especializados para uint128_t
 *
 * Este archivo proporciona implementaciones optimizadas de algoritmos
 * estándar específicamente diseñados para trabajar con uint128_t.
 */

namespace uint128_algorithm
{

// ===============================================================================
// ALGORITMOS DE BÚSQUEDA
// ===============================================================================

/**
 * @brief Búsqueda binaria optimizada para rangos de uint128_t
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param value Valor a buscar
 * @return true si se encuentra el valor, false en caso contrario
 *
 * Optimizada para aprovechar las características específicas de uint128_t.
 */
template <std::forward_iterator ForwardIt>
bool binary_search_uint128(ForwardIt first, ForwardIt last, const uint128_t& value)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, uint128_t>
{
    first = std::lower_bound(first, last, value);
    return (first != last) && (*first == value);
}

/**
 * @brief Encuentra el primer elemento que satisface el predicado
 *
 * @tparam ForwardIt Tipo de iterador
 * @tparam Predicate Tipo del predicado
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado a aplicar
 * @return Iterador al primer elemento que satisface el predicado
 */
template <std::forward_iterator ForwardIt>
ForwardIt find_if_uint128(ForwardIt first, ForwardIt last,
                          uint128_concepts::uint128_predicate auto pred)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, uint128_t>
{
    return std::find_if(first, last, pred);
}

// ===============================================================================
// ALGORITMOS DE TRANSFORMACIÓN
// ===============================================================================

/**
 * @brief Transforma un rango aplicando una operación a cada elemento
 *
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam OutputIt Tipo de iterador de salida
 * @tparam UnaryOp Tipo de operación unaria
 * @param first Iterador al inicio del rango de entrada
 * @param last Iterador al final del rango de entrada
 * @param result Iterador al inicio del rango de salida
 * @param op Operación a aplicar
 * @return Iterador al final del rango de salida
 */
template <std::input_iterator InputIt, std::output_iterator<uint128_t> OutputIt>
OutputIt transform_uint128(InputIt first, InputIt last, OutputIt result, auto op)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    return std::transform(first, last, result, op);
}

/**
 * @brief Aplica una función a cada elemento del rango
 *
 * @tparam ForwardIt Tipo de iterador
 * @tparam Function Tipo de función
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param f Función a aplicar
 */
template <std::forward_iterator ForwardIt>
void for_each_uint128(ForwardIt first, ForwardIt last, uint128_concepts::uint128_function<> auto f)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, uint128_t>
{
    std::for_each(first, last, f);
}

// ===============================================================================
// ALGORITMOS DE REDUCCIÓN
// ===============================================================================

/**
 * @brief Acumula valores en un rango usando una operación específica
 *
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam T Tipo del valor inicial
 * @tparam BinaryOp Tipo de operación binaria
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param init Valor inicial
 * @param op Operación binaria
 * @return Resultado de la acumulación
 */
template <std::input_iterator InputIt, typename T>
T accumulate_uint128(InputIt first, InputIt last, T init,
                     uint128_concepts::uint128_reduce_operation<T> auto op)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    return std::accumulate(first, last, init, op);
}

/**
 * @brief Suma todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Suma de todos los elementos
 */
template <std::input_iterator InputIt>
uint128_t sum_uint128(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    return std::accumulate(first, last, uint128_t(0));
}

/**
 * @brief Encuentra el producto de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Producto de todos los elementos
 */
template <std::input_iterator InputIt>
uint128_t product_uint128(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    return std::accumulate(first, last, uint128_t(1), std::multiplies<uint128_t>());
}

// ===============================================================================
// ALGORITMOS DE PARTICIÓN Y ORDENAMIENTO
// ===============================================================================

/**
 * @brief Particiona un rango según un predicado
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado de partición
 * @return Iterador al primer elemento que no satisface el predicado
 */
template <std::forward_iterator ForwardIt>
ForwardIt partition_uint128(ForwardIt first, ForwardIt last,
                            uint128_concepts::uint128_predicate auto pred)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, uint128_t>
{
    return std::partition(first, last, pred);
}

/**
 * @brief Ordena un rango de uint128_t usando una comparación personalizada
 *
 * @tparam RandomIt Tipo de iterador de acceso aleatorio
 * @tparam Compare Tipo de función de comparación
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param comp Función de comparación
 */
template <std::random_access_iterator RandomIt>
void sort_uint128(RandomIt first, RandomIt last, auto comp = std::less<uint128_t>())
    requires std::same_as<typename std::iterator_traits<RandomIt>::value_type, uint128_t>
{
    std::sort(first, last, comp);
}

// ===============================================================================
// ALGORITMOS ESPECIALIZADOS PARA uint128_t
// ===============================================================================

/**
 * @brief Encuentra el máximo común divisor de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return GCD de todos los elementos (0 si el rango está vacío)
 */
template <std::input_iterator InputIt>
uint128_t gcd_range(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    if (first == last)
        return uint128_t(0);

    uint128_t result = *first++;
    while (first != last) {
        result = gcd(result, *first++);
        if (result == uint128_t(1))
            break; // Optimización: si GCD es 1, no puede mejorar
    }
    return result;
}

/**
 * @brief Encuentra el mínimo común múltiplo de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return LCM de todos los elementos (0 si algún elemento es 0)
 */
template <std::input_iterator InputIt>
uint128_t lcm_range(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    if (first == last)
        return uint128_t(0);

    uint128_t result = *first++;
    while (first != last && result != uint128_t(0)) {
        result = lcm(result, *first++);
    }
    return result;
}

/**
 * @brief Genera una secuencia aritmética de uint128_t
 *
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango de salida
 * @param count Número de elementos a generar
 * @param start Valor inicial
 * @param step Paso de la secuencia
 */
template <std::output_iterator<uint128_t> OutputIt>
void generate_arithmetic_sequence(OutputIt first, std::size_t count, const uint128_t& start,
                                  const uint128_t& step)
{
    uint128_t current = start;
    for (std::size_t i = 0; i < count; ++i) {
        *first++ = current;
        current += step;
    }
}

/**
 * @brief Genera una secuencia geométrica de uint128_t
 *
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango de salida
 * @param count Número de elementos a generar
 * @param start Valor inicial
 * @param ratio Razón de la secuencia
 */
template <std::output_iterator<uint128_t> OutputIt>
void generate_geometric_sequence(OutputIt first, std::size_t count, const uint128_t& start,
                                 const uint128_t& ratio)
{
    uint128_t current = start;
    for (std::size_t i = 0; i < count; ++i) {
        *first++ = current;
        current *= ratio;
    }
}

// ===============================================================================
// UTILIDADES DE ANÁLISIS
// ===============================================================================

/**
 * @brief Estadísticas básicas de un rango de uint128_t
 */
struct uint128_stats {
    uint128_t min_value;
    uint128_t max_value;
    uint128_t sum;
    std::size_t count;

    double mean() const
    {
        return count > 0 ? static_cast<double>(static_cast<uint64_t>(sum)) / count : 0.0;
    }
};

/**
 * @brief Calcula estadísticas básicas de un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Estructura con estadísticas básicas
 */
template <std::input_iterator InputIt>
uint128_stats calculate_stats(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    if (first == last) {
        return {uint128_t(0), uint128_t(0), uint128_t(0), 0};
    }

    uint128_stats stats;
    stats.min_value = stats.max_value = stats.sum = *first;
    stats.count = 1;

    ++first;
    while (first != last) {
        const uint128_t& value = *first++;
        stats.min_value = std::min(stats.min_value, value);
        stats.max_value = std::max(stats.max_value, value);
        stats.sum += value;
        ++stats.count;
    }

    return stats;
}

} // namespace uint128_algorithm

#endif // UINT128_ALGORITHM_HPP