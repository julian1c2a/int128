/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef UINT128_ALGORITHM_HPP
#define UINT128_ALGORITHM_HPP

#include "uint128_cmath.hpp"
#include "uint128_concepts.hpp"
#include "uint128_t.hpp"
#include <algorithm>
#include <functional>
#include <iterator>
#include <numeric>
#include <type_traits>

/**
 * @brief Algoritmos optimizados y especializados para uint128_t
 *
 * Este archivo proporciona implementaciones optimizadas de algoritmos
 * estandar especificamente disenados para trabajar con uint128_t.
 */

namespace uint128_algorithm
{

// ===============================================================================
// ALGORITMOS DE BuSQUEDA
// ===============================================================================

/**
 * @brief Busqueda binaria optimizada para rangos de uint128_t
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param value Valor a buscar
 * @return true si se encuentra el valor, false en caso contrario
 *
 * Optimizada para aprovechar las caracteristicas especificas de uint128_t.
 *
 * @test test_binary_search_uint128
 * @code{.cpp}
 * // Verifica busqueda de valores existentes e inexistentes
 * std::vector<uint128_t> vec = {10, 20, 30, 40, 50};
 * assert(binary_search_uint128(vec.begin(), vec.end(), uint128_t(30)));
 * assert(!binary_search_uint128(vec.begin(), vec.end(), uint128_t(15)));
 * @endcode
 */
template <std::forward_iterator ForwardIt>
bool binary_search_uint128(ForwardIt first, ForwardIt last, const uint128_t& value)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, uint128_t>
{
    first = std::lower_bound(first, last, value);
    return (first != last) && (*first == value);
}

/**
 * @brief Encuentra el primer elemento que satisface el predicado
 *
 * @tparam ForwardIt Tipo de iterador
 * @tparam Predicate Tipo del predicado
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado a aplicar
 * @return Iterador al primer elemento que satisface el predicado
 *
 * @test test_find_if_uint128
 * @code{.cpp}
 * // Encuentra primer elemento mayor que 12, numeros pares, etc.
 * auto it = find_if_uint128(vec.begin(), vec.end(),
 *     [](const uint128_t& x) { return x > uint128_t(12); });
 * assert(it != vec.end() && *it == uint128_t(15));
 * @endcode
 */
template <std::forward_iterator ForwardIt>
ForwardIt find_if_uint128(ForwardIt first, ForwardIt last,
                          uint128_concepts::uint128_predicate auto pred)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, uint128_t>
{
    return std::find_if(first, last, pred);
}

// ===============================================================================
// ALGORITMOS DE TRANSFORMACIoN
// ===============================================================================

/**
 * @brief Transforma un rango aplicando una operacion a cada elemento
 *
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam OutputIt Tipo de iterador de salida
 * @tparam UnaryOp Tipo de operacion unaria
 * @param first Iterador al inicio del rango de entrada
 * @param last Iterador al final del rango de entrada
 * @param result Iterador al inicio del rango de salida
 * @param op Operacion a aplicar
 * @return Iterador al final del rango de salida
 *
 * @test test_transform_uint128
 * @code{.cpp}
 * // Aplica transformaciones (duplicar, elevar al cuadrado)
 * transform_uint128(input.begin(), input.end(), output.begin(),
 *     [](const uint128_t& x) { return x * uint128_t(2); });
 * assert(output[0] == uint128_t(2) && output[1] == uint128_t(4));
 * @endcode
 */
template <std::input_iterator InputIt, std::output_iterator<uint128_t> OutputIt>
OutputIt transform_uint128(InputIt first, InputIt last, OutputIt result, auto op)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    return std::transform(first, last, result, op);
}

/**
 * @brief Aplica una funcion a cada elemento del rango
 *
 * @tparam ForwardIt Tipo de iterador
 * @tparam Function Tipo de funcion
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param f Funcion a aplicar
 *
 * @test test_for_each_uint128
 * @code{.cpp}
 * // Aplica funcion a cada elemento (contar, sumar)
 * uint128_t sum = 0;
 * for_each_uint128(vec.begin(), vec.end(),
 *     [&sum](const uint128_t& x) { sum += x; });
 * assert(sum == uint128_t(6));
 * @endcode
 */
template <std::forward_iterator ForwardIt>
void for_each_uint128(ForwardIt first, ForwardIt last, uint128_concepts::uint128_function<> auto f)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, uint128_t>
{
    std::for_each(first, last, f);
}

// ===============================================================================
// ALGORITMOS DE REDUCCIoN
// ===============================================================================

/**
 * @brief Acumula valores en un rango usando una operacion especifica
 *
 * @tparam InputIt Tipo de iterador de entrada
 * @tparam T Tipo del valor inicial
 * @tparam BinaryOp Tipo de operacion binaria
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param init Valor inicial
 * @param op Operacion binaria
 * @return Resultado de la acumulacion
 *
 * @test test_accumulate_uint128
 * @code{.cpp}
 * // Acumula con operaciones de suma y producto
 * auto sum = accumulate_uint128(vec.begin(), vec.end(),
 *     uint128_t(0), std::plus<uint128_t>());
 * assert(sum == uint128_t(60));
 * @endcode
 */
template <std::input_iterator InputIt, typename T>
T accumulate_uint128(InputIt first, InputIt last, T init,
                     uint128_concepts::uint128_reduce_operation<T> auto op)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    return std::accumulate(first, last, init, op);
}

/**
 * @brief Suma todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Suma de todos los elementos
 *
 * @test test_sum_uint128
 * @code{.cpp}
 * // Suma elementos del rango, verifica rango vacio
 * std::vector<uint128_t> vec = {5, 10, 15, 20};
 * auto sum = sum_uint128(vec.begin(), vec.end());
 * assert(sum == uint128_t(50));
 * @endcode
 */
template <std::input_iterator InputIt>
uint128_t sum_uint128(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    return std::accumulate(first, last, uint128_t(0));
}

/**
 * @brief Encuentra el producto de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Producto de todos los elementos
 *
 * @test test_product_uint128
 * @code{.cpp}
 * // Calcula producto, verifica comportamiento con cero
 * std::vector<uint128_t> vec = {2, 3, 4};
 * auto product = product_uint128(vec.begin(), vec.end());
 * assert(product == uint128_t(24));
 * @endcode
 */
template <std::input_iterator InputIt>
uint128_t product_uint128(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    return std::accumulate(first, last, uint128_t(1), std::multiplies<uint128_t>());
}

// ===============================================================================
// ALGORITMOS DE PARTICIoN Y ORDENAMIENTO
// ===============================================================================

/**
 * @brief Particiona un rango segun un predicado
 *
 * @tparam ForwardIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param pred Predicado de particion
 * @return Iterador al primer elemento que no satisface el predicado
 *
 * @test test_partition_uint128
 * @code{.cpp}
 * // Particiona en pares/impares, verifica separacion correcta
 * auto middle = partition_uint128(vec.begin(), vec.end(),
 *     [](const uint128_t& x) { return (x % uint128_t(2)) == uint128_t(0); });
 * // Verifica que elementos antes de middle son pares
 * @endcode
 */
template <std::forward_iterator ForwardIt>
ForwardIt partition_uint128(ForwardIt first, ForwardIt last,
                            uint128_concepts::uint128_predicate auto pred)
    requires std::same_as<typename std::iterator_traits<ForwardIt>::value_type, uint128_t>
{
    return std::partition(first, last, pred);
}

/**
 * @brief Ordena un rango de uint128_t usando una comparacion personalizada
 *
 * @tparam RandomIt Tipo de iterador de acceso aleatorio
 * @tparam Compare Tipo de funcion de comparacion
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @param comp Funcion de comparacion
 *
 * @test test_sort_uint128
 * @code{.cpp}
 * // Ordena ascendente y descendente, verifica orden correcto
 * sort_uint128(vec.begin(), vec.end());
 * assert(vec[0] == uint128_t(10) && vec[4] == uint128_t(80));
 * sort_uint128(vec.begin(), vec.end(), std::greater<uint128_t>());
 * @endcode
 */
template <std::random_access_iterator RandomIt>
void sort_uint128(RandomIt first, RandomIt last)
    requires std::same_as<typename std::iterator_traits<RandomIt>::value_type, uint128_t>
{
    std::sort(first, last);
}

template <std::random_access_iterator RandomIt, typename Compare>
void sort_uint128(RandomIt first, RandomIt last, Compare comp)
    requires std::same_as<typename std::iterator_traits<RandomIt>::value_type, uint128_t>
{
    std::sort(first, last, comp);
}

// ===============================================================================
// ALGORITMOS ESPECIALIZADOS PARA uint128_t
// ===============================================================================

/**
 * @brief Encuentra el maximo comun divisor de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return GCD de todos los elementos (0 si el rango esta vacio)
 *
 * @test test_gcd_range
 * @code{.cpp}
 * // Calcula GCD de multiples numeros, verifica coprimos
 * std::vector<uint128_t> vec = {12, 18, 24};
 * auto gcd = gcd_range(vec.begin(), vec.end());
 * assert(gcd == uint128_t(6));
 * @endcode
 */
template <std::input_iterator InputIt>
uint128_t gcd_range(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    if (first == last)
        return uint128_t(0);

    uint128_t result = *first++;
    while (first != last) {
        result = std::gcd(result, *first++);
        if (result == uint128_t(1))
            break; // Optimizacion: si GCD es 1, no puede mejorar
    }
    return result;
}

/**
 * @brief Encuentra el minimo comun multiplo de todos los elementos en un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return LCM de todos los elementos (0 si algun elemento es 0)
 *
 * @test test_lcm_range
 * @code{.cpp}
 * // Calcula LCM de multiples numeros, verifica con cero
 * std::vector<uint128_t> vec = {4, 6, 8};
 * auto lcm = lcm_range(vec.begin(), vec.end());
 * assert(lcm == uint128_t(24));
 * @endcode
 */
template <std::input_iterator InputIt>
uint128_t lcm_range(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    if (first == last)
        return uint128_t(0);

    uint128_t result = *first++;
    while (first != last && result != uint128_t(0)) {
        result = std::lcm(result, *first++);
    }
    return result;
}

/**
 * @brief Genera una secuencia aritmetica de uint128_t
 *
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango de salida
 * @param count Numero de elementos a generar
 * @param start Valor inicial
 * @param step Paso de la secuencia
 *
 * @test test_generate_arithmetic_sequence
 * @code{.cpp}
 * // Genera secuencias ascendentes/descendentes (10,15,20,...)
 * generate_arithmetic_sequence(seq.begin(), 5, uint128_t(10), uint128_t(5));
 * assert(seq[0] == uint128_t(10) && seq[4] == uint128_t(30));
 * @endcode
 */
template <std::output_iterator<uint128_t> OutputIt>
void generate_arithmetic_sequence(OutputIt first, std::size_t count, const uint128_t& start,
                                  const uint128_t& step)
{
    uint128_t current = start;
    for (std::size_t i = 0; i < count; ++i) {
        *first++ = current;
        current += step;
    }
}

/**
 * @brief Genera una secuencia geometrica de uint128_t
 *
 * @tparam OutputIt Tipo de iterador de salida
 * @param first Iterador al inicio del rango de salida
 * @param count Numero de elementos a generar
 * @param start Valor inicial
 * @param ratio Razon de la secuencia
 *
 * @test test_generate_geometric_sequence
 * @code{.cpp}
 * // Genera progresiones geometricas (2,4,8,16,...)
 * generate_geometric_sequence(seq.begin(), 5, uint128_t(2), uint128_t(2));
 * assert(seq[0] == uint128_t(2) && seq[4] == uint128_t(32));
 * @endcode
 */
template <std::output_iterator<uint128_t> OutputIt>
void generate_geometric_sequence(OutputIt first, std::size_t count, const uint128_t& start,
                                 const uint128_t& ratio)
{
    uint128_t current = start;
    for (std::size_t i = 0; i < count; ++i) {
        *first++ = current;
        current *= ratio;
    }
}

// ===============================================================================
// UTILIDADES DE ANaLISIS
// ===============================================================================

/**
 * @brief Estadisticas basicas de un rango de uint128_t
 */
struct uint128_stats {
    uint128_t min_value;
    uint128_t max_value;
    uint128_t sum;
    std::size_t count;

    double mean() const
    {
        return count > 0 ? static_cast<double>(static_cast<uint64_t>(sum)) / count : 0.0;
    }
};

/**
 * @brief Calcula estadisticas basicas de un rango
 *
 * @tparam InputIt Tipo de iterador
 * @param first Iterador al inicio del rango
 * @param last Iterador al final del rango
 * @return Estructura con estadisticas basicas
 *
 * @test test_calculate_stats
 * @code{.cpp}
 * // Calcula min, max, sum, count y mean de un rango
 * auto stats = calculate_stats(vec.begin(), vec.end());
 * assert(stats.min_value == uint128_t(10) && stats.max_value == uint128_t(50));
 * assert(stats.sum == uint128_t(150) && stats.mean() == 30.0);
 * @endcode
 */
template <std::input_iterator InputIt>
uint128_stats calculate_stats(InputIt first, InputIt last)
    requires std::same_as<typename std::iterator_traits<InputIt>::value_type, uint128_t>
{
    if (first == last) {
        return {uint128_t(0), uint128_t(0), uint128_t(0), 0};
    }

    uint128_stats stats;
    stats.min_value = stats.max_value = stats.sum = *first;
    stats.count = 1;

    ++first;
    while (first != last) {
        const uint128_t& value = *first++;
        stats.min_value = std::min(stats.min_value, value);
        stats.max_value = std::max(stats.max_value, value);
        stats.sum += value;
        ++stats.count;
    }

    return stats;
}

} // namespace uint128_algorithm

#endif // UINT128_ALGORITHM_HPP