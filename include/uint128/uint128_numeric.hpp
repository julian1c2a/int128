/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef UINT128_NUMERIC_HPP
#define UINT128_NUMERIC_HPP

#include "../intrinsics/bit_operations.hpp"
#include "../intrinsics/byte_operations.hpp"
#include "uint128_t.hpp"

#include <algorithm>
#include <cstdint>

/**
 * @brief Funciones numéricas de C++20 especializadas para uint128_t
 *
 * Este archivo implementa funciones numéricas estándar de C++20 que no están
 * automáticamente disponibles para uint128_t, como std::midpoint, std::clamp,
 * y funciones de manipulación de bits.
 */

namespace nstd
{

// ===============================================================================
// FUNCIONES ARITMÉTICAS SEGURAS
// ===============================================================================

/**
 * @brief Calcula el punto medio entre dos valores uint128_t sin overflow
 *
 * @param a Primer valor
 * @param b Segundo valor
 * @return Punto medio entre a y b
 *
 * La implementación evita overflow calculando: a + (b - a) / 2 cuando b >= a,
 * o a - (a - b) / 2 cuando a > b.
 */
constexpr uint128_t midpoint(uint128_t a, uint128_t b) noexcept
{
    if (a <= b) {
        // a + (b - a) / 2
        return a + (b - a) / 2;
    } else {
        // a - (a - b) / 2
        return a - (a - b) / 2;
    }
}

/**
 * @brief Restringe un valor a un rango específico
 *
 * @param v Valor a restringir
 * @param lo Valor mínimo del rango
 * @param hi Valor máximo del rango
 * @return v restringido al rango [lo, hi]
 *
 * Precondición: lo <= hi
 */
constexpr uint128_t clamp(const uint128_t& v, const uint128_t& lo, const uint128_t& hi)
{
    return (v < lo) ? lo : (hi < v) ? hi : v;
}

// ===============================================================================
// FUNCIONES DE MANIPULACIÓN DE BITS
// ===============================================================================

/**
 * @brief Cuenta el número de bits establecidos (población de bits)
 *
 * @param x Valor a examinar
 * @return Número de bits establecidos en x
 */
constexpr int popcount(uint128_t x) noexcept
{
    // Usar la implementación eficiente para cada parte
    int count = 0;
    if (x.high() != 0) {
        count += intrinsics::popcount64(x.high());
    }
    if (x.low() != 0) {
        count += intrinsics::popcount64(x.low());
    }
    return count;
}

/**
 * @brief Cuenta los ceros a la izquierda (leading zeros)
 *
 * @param x Valor a examinar (debe ser != 0)
 * @return Número de ceros a la izquierda
 */
constexpr int countl_zero(uint128_t x) noexcept
{
    if (x == uint128_t(0)) {
        return 128;
    }

    if (x.high() != 0) {
        return intrinsics::clz64(x.high());
    } else {
        return 64 + intrinsics::clz64(x.low());
    }
}

/**
 * @brief Cuenta los unos a la izquierda (leading ones)
 *
 * @param x Valor a examinar
 * @return Número de unos a la izquierda
 */
constexpr int countl_one(uint128_t x) noexcept
{
    return countl_zero(~x);
}

/**
 * @brief Cuenta los ceros a la derecha (trailing zeros)
 *
 * @param x Valor a examinar (debe ser != 0)
 * @return Número de ceros a la derecha
 */
constexpr int countr_zero(uint128_t x) noexcept
{
    if (x == uint128_t(0)) {
        return 128;
    }

    if (x.low() != 0) {
        return intrinsics::ctz64(x.low());
    } else {
        return 64 + intrinsics::ctz64(x.high());
    }
}

/**
 * @brief Cuenta los unos a la derecha (trailing ones)
 *
 * @param x Valor a examinar
 * @return Número de unos a la derecha
 */
constexpr int countr_one(uint128_t x) noexcept
{
    return countr_zero(~x);
}

/**
 * @brief Encuentra el bit más significativo establecido
 *
 * @param x Valor a examinar (debe ser != 0)
 * @return Posición del bit más significativo (0-based), o 0 si x == 0
 */
constexpr int bit_width(uint128_t x) noexcept
{
    return x == uint128_t(0) ? 0 : 128 - countl_zero(x);
}

/**
 * @brief Verifica si un valor es una potencia de 2
 *
 * @param x Valor a verificar
 * @return true si x es una potencia de 2, false en caso contrario
 */
constexpr bool has_single_bit(uint128_t x) noexcept
{
    return x != uint128_t(0) && (x & (x - uint128_t(1))) == uint128_t(0);
}

/**
 * @brief Encuentra la potencia de 2 más pequeña >= x
 *
 * @param x Valor base
 * @return La potencia de 2 más pequeña >= x, o 0 si hay overflow
 */
constexpr uint128_t bit_ceil(uint128_t x) noexcept
{
    if (x <= uint128_t(1)) {
        return uint128_t(1);
    }

    // Si x es mayor que 2^127, hay overflow
    if (x > (uint128_t(1) << 127)) {
        return uint128_t(0); // Indica overflow
    }

    // Encontrar la potencia de 2 más pequeña >= x
    int width = bit_width(x - uint128_t(1));
    return uint128_t(1) << width;
}

/**
 * @brief Encuentra la potencia de 2 más grande <= x
 *
 * @param x Valor base (debe ser > 0)
 * @return La potencia de 2 más grande <= x
 */
constexpr uint128_t bit_floor(uint128_t x) noexcept
{
    if (x == uint128_t(0)) {
        return uint128_t(0);
    }

    int width = bit_width(x);
    return uint128_t(1) << (width - 1);
}

// ===============================================================================
// FUNCIONES DE ROTACIÓN DE BITS
// ===============================================================================

/**
 * @brief Rotación a la izquierda
 *
 * @param x Valor a rotar
 * @param s Número de posiciones a rotar
 * @return x rotado s posiciones a la izquierda
 */
constexpr uint128_t rotl(uint128_t x, int s) noexcept
{
    s &= 127; // s %= 128
    if (s == 0)
        return x;

    return (x << s) | (x >> (128 - s));
}

/**
 * @brief Rotación a la derecha
 *
 * @param x Valor a rotar
 * @param s Número de posiciones a rotar
 * @return x rotado s posiciones a la derecha
 */
constexpr uint128_t rotr(uint128_t x, int s) noexcept
{
    s &= 127; // s %= 128
    if (s == 0)
        return x;

    return (x >> s) | (x << (128 - s));
}

// ===============================================================================
// FUNCIONES DE BYTESWAP
// ===============================================================================

/**
 * @brief Intercambia el orden de bytes (little-endian ↔ big-endian)
 *
 * @param x Valor cuyos bytes se van a intercambiar
 * @return x con bytes en orden inverso
 */
constexpr uint128_t byteswap(uint128_t x) noexcept
{
    // Intercambiar bytes de cada parte y luego intercambiar las partes
    uint64_t high_swapped = intrinsics::bswap64(x.low());
    uint64_t low_swapped = intrinsics::bswap64(x.high());
    return uint128_t(high_swapped, low_swapped);
}

// ===============================================================================
// FUNCIONES DE INTERPOLACIÓN
// ===============================================================================

// ===============================================================================
// FUNCIONES DE UTILIDAD ADICIONALES
// ===============================================================================

/**
 * @brief Calcula el logaritmo base 2 (piso)
 *
 * @param x Valor (debe ser > 0)
 * @return floor(log2(x))
 */
constexpr int ilog2(uint128_t x) noexcept
{
    return x == uint128_t(0) ? -1 : bit_width(x) - 1;
}

/**
 * @brief Verifica si un número es par
 *
 * @param x Valor a verificar
 * @return true si x es par
 */
constexpr bool is_even(uint128_t x) noexcept
{
    return (x & uint128_t(1)) == uint128_t(0);
}

/**
 * @brief Verifica si un número es impar
 *
 * @param x Valor a verificar
 * @return true si x es impar
 */
constexpr bool is_odd(uint128_t x) noexcept
{
    return (x & uint128_t(1)) == uint128_t(1);
}

/**
 * @brief Calcula el valor absoluto de la diferencia entre dos valores
 *
 * @param a Primer valor
 * @param b Segundo valor
 * @return |a - b| sin riesgo de overflow
 */
constexpr uint128_t abs_diff(uint128_t a, uint128_t b) noexcept
{
    return (a >= b) ? (a - b) : (b - a);
}

// ===============================================================================
// FUNCIONES DE CONVENIENCIA NO-STD
// ===============================================================================

namespace uint128_numeric
{

using uint128_t = nstd::uint128_t;
using int128_t = nstd::int128_t;

/**
 * @brief Calcula x^n de manera eficiente
 *
 * @param base Base
 * @param exponent Exponente
 * @return base^exponent
 */
constexpr uint128_t power(uint128_t base, uint128_t exponent) noexcept
{
    uint128_t result(1);
    while (exponent > uint128_t(0)) {
        if (std::is_odd(exponent)) {
            result *= base;
        }
        base *= base;
        exponent >>= 1;
    }
    return result;
}

/**
 * @brief Calcula la raíz cuadrada entera (piso)
 *
 * @param x Valor
 * @return floor(sqrt(x))
 */
uint128_t isqrt(uint128_t x) noexcept
{
    if (x == uint128_t(0))
        return uint128_t(0);
    if (x == uint128_t(1))
        return uint128_t(1);

    // Usar método de Newton con estimación inicial optimizada
    uint128_t estimate = uint128_t(1) << ((std::bit_width(x) + 1) / 2);

    for (;;) {
        uint128_t new_estimate = (estimate + x / estimate) / uint128_t(2);
        if (new_estimate >= estimate) {
            return estimate;
        }
        estimate = new_estimate;
    }
}

/**
 * @brief Factorial de un número (cuidado con overflow)
 *
 * @param n Número
 * @return n! (0 si hay overflow)
 */
uint128_t factorial(unsigned int n) noexcept
{
    if (n > 34)
        return uint128_t(0); // Overflow para n > 34

    uint128_t result(1);
    for (unsigned int i = 2; i <= n; ++i) {
        result *= uint128_t(i);
    }
    return result;
}

// ===============================================================================
// GCD Y LCM (MÁXIMO COMÚN DIVISOR Y MÍNIMO COMÚN MÚLTIPLO)
// ===============================================================================

/**
 * @brief Máximo común divisor (algoritmo de Euclides)
 *
 * @param a Primer número
 * @param b Segundo número
 * @return GCD(a, b)
 */
uint128_t gcd(uint128_t a, uint128_t b) noexcept
{
    if (a == 0)
        return b;
    if (b == 0)
        return a;

    // Algoritmo de Euclides
    while (b != 0) {
        uint128_t temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

/**
 * @brief Mínimo común múltiplo
 *
 * @param a Primer número
 * @param b Segundo número
 * @return LCM(a, b) = (a * b) / GCD(a, b)
 */
uint128_t lcm(uint128_t a, uint128_t b) noexcept
{
    if (a == 0 || b == 0)
        return uint128_t(0);

    // lcm(a, b) = (a / gcd(a, b)) * b
    // Dividimos primero para evitar overflow
    uint128_t g = gcd(a, b);
    return (a / g) * b;
}

} // namespace uint128_numeric

} // namespace nstd
#endif // UINT128_NUMERIC_HPP