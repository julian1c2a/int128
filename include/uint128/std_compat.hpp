/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @file std_compat.hpp
 * @brief Polyfills y compatibilidad entre versiones de C++ (C++20/C++23/C++26)
 *
 * Este header proporciona implementaciones de funcionalidades de estándares más
 * recientes para compiladores que aún no las soportan completamente, permitiendo
 * portabilidad entre C++20, C++23 y futuras versiones.
 *
 * Características incluidas:
 * - std::byteswap (C++23) con polyfill para C++20
 * - std::abs constexpr (mejorado en C++23)
 * - std::rotl/rotr (C++20, verifica disponibilidad)
 * - Feature test macros propios para detectar capacidades
 *
 * Uso:
 * @code
 * #include "std_compat.hpp"
 *
 * // Usar std_compat::byteswap en lugar de std::byteswap
 * auto swapped = std_compat::byteswap(value);
 * @endcode
 */

#ifndef UINT128_STD_COMPAT_HPP
#define UINT128_STD_COMPAT_HPP

#include <bit>
#include <cmath>
#include <cstdint>
#include <limits>
#include <type_traits>

// ============================================================================
// FEATURE TEST MACROS
// ============================================================================

/**
 * @def UINT128_HAS_CPP23_BYTESWAP
 * @brief Detecta si std::byteswap está disponible (C++23)
 */
#if defined(__cpp_lib_byteswap) && __cpp_lib_byteswap >= 202110L
#define UINT128_HAS_CPP23_BYTESWAP 1
#else
#define UINT128_HAS_CPP23_BYTESWAP 0
#endif

/**
 * @def UINT128_HAS_CPP20_BITOPS
 * @brief Detecta si std::rotl/rotr están disponibles (C++20)
 */
#if defined(__cpp_lib_bitops) && __cpp_lib_bitops >= 201907L
#define UINT128_HAS_CPP20_BITOPS 1
#else
#define UINT128_HAS_CPP20_BITOPS 0
#endif

/**
 * @def UINT128_HAS_CPP23_CONSTEXPR_CMATH
 * @brief Detecta si std::abs es constexpr (C++23)
 */
#if defined(__cpp_lib_constexpr_cmath) && __cpp_lib_constexpr_cmath >= 202202L
#define UINT128_HAS_CPP23_CONSTEXPR_CMATH 1
#else
#define UINT128_HAS_CPP23_CONSTEXPR_CMATH 0
#endif

/**
 * @def UINT128_HAS_IS_CONSTANT_EVALUATED
 * @brief Detecta si std::is_constant_evaluated() está disponible (C++20)
 */
#if defined(__cpp_lib_is_constant_evaluated) && __cpp_lib_is_constant_evaluated >= 201811L
#define UINT128_HAS_IS_CONSTANT_EVALUATED 1
#else
#define UINT128_HAS_IS_CONSTANT_EVALUATED 0
#endif

namespace std_compat
{

// ============================================================================
// BYTESWAP (C++23 Polyfill)
// ============================================================================

/**
 * @brief Invierte el orden de bytes de un entero
 *
 * Polyfill de std::byteswap (C++23). Si std::byteswap está disponible,
 * lo usa directamente; de lo contrario, proporciona una implementación propia.
 *
 * @tparam T Tipo entero (uint8_t, uint16_t, uint32_t, uint64_t)
 * @param value Valor a intercambiar
 * @return Valor con bytes en orden inverso
 */
#if UINT128_HAS_CPP23_BYTESWAP
using std::byteswap;
#else
// Implementación propia para compiladores sin std::byteswap
template <typename T>
constexpr T byteswap(T value) noexcept
    requires std::is_integral_v<T>
{
    static_assert(std::has_unique_object_representations_v<T>,
                  "byteswap requiere tipos sin padding bits");

    if constexpr (sizeof(T) == 1) {
        return value;
    } else if constexpr (sizeof(T) == 2) {
        return static_cast<T>((value >> 8) | (value << 8));
    } else if constexpr (sizeof(T) == 4) {
        uint32_t v = static_cast<uint32_t>(value);
        v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);
        v = (v >> 16) | (v << 16);
        return static_cast<T>(v);
    } else if constexpr (sizeof(T) == 8) {
        uint64_t v = static_cast<uint64_t>(value);
        v = ((v & 0xFF00FF00FF00FF00ULL) >> 8) | ((v & 0x00FF00FF00FF00FFULL) << 8);
        v = ((v & 0xFFFF0000FFFF0000ULL) >> 16) | ((v & 0x0000FFFF0000FFFFULL) << 16);
        v = (v >> 32) | (v << 32);
        return static_cast<T>(v);
    } else {
        // Para tipos más grandes, usar manual byte-by-byte
        T result{};
        auto* src = reinterpret_cast<const unsigned char*>(&value);
        auto* dst = reinterpret_cast<unsigned char*>(&result);
        for (std::size_t i = 0; i < sizeof(T); ++i) {
            dst[i] = src[sizeof(T) - 1 - i];
        }
        return result;
    }
}
#endif

// ============================================================================
// ROTL/ROTR (C++20 Verification)
// ============================================================================

/**
 * @brief Verifica disponibilidad de std::rotl y std::rotr
 *
 * Estas funciones están disponibles en C++20, pero verificamos su presencia
 * para mayor seguridad. Si no están disponibles, el código debe usar
 * implementaciones propias (ya disponibles en uint128_numeric.hpp).
 */
#if UINT128_HAS_CPP20_BITOPS
using std::rotl;
using std::rotr;
#define UINT128_USE_STD_ROTL_ROTR 1
#else
#define UINT128_USE_STD_ROTL_ROTR 0
// Nota: Las implementaciones propias están en uint128_numeric.hpp
#endif

// ============================================================================
// CONSTEXPR ABS (C++23 Enhancement)
// ============================================================================

/**
 * @brief Valor absoluto constexpr
 *
 * En C++23, std::abs es constexpr. Para C++20, proporcionamos nuestra propia
 * versión constexpr. Útil para contextos de evaluación en tiempo de compilación.
 *
 * @tparam T Tipo aritmético
 * @param x Valor
 * @return |x|
 */
template <typename T>
constexpr T abs(T x) noexcept
    requires std::is_arithmetic_v<T>
{
#if UINT128_HAS_CPP23_CONSTEXPR_CMATH
    return std::abs(x);
#else
    // Implementación constexpr propia
    if constexpr (std::is_unsigned_v<T>) {
        return x;
    } else {
        return x < 0 ? -x : x;
    }
#endif
}

// ============================================================================
// IS_CONSTANT_EVALUATED (C++20 Verification)
// ============================================================================

/**
 * @brief Detecta si la evaluación es en tiempo de compilación
 *
 * Wrapper de std::is_constant_evaluated() (C++20). Si no está disponible,
 * proporciona un fallback conservador.
 */
#if UINT128_HAS_IS_CONSTANT_EVALUATED
using std::is_constant_evaluated;
#else
// Fallback: siempre retorna false en compiladores antiguos
// Esto es seguro pero puede resultar en código menos optimizado
constexpr bool is_constant_evaluated() noexcept
{
    return false;
}
#endif

// ============================================================================
// FUTURE EXTENSIONS (C++26 y posteriores)
// ============================================================================

// Aquí se pueden agregar polyfills futuros, como:
// - std::to_underlying (C++23)
// - std::unreachable (C++23)
// - std::expected (C++23)
// - std::mdspan (C++23)
// etc.

/**
 * @brief to_underlying - Convierte enum a tipo subyacente (C++23 Polyfill)
 */
#if defined(__cpp_lib_to_underlying) && __cpp_lib_to_underlying >= 202102L
using std::to_underlying;
#else
template <typename Enum> constexpr std::underlying_type_t<Enum> to_underlying(Enum e) noexcept
{
    return static_cast<std::underlying_type_t<Enum>>(e);
}
#endif

/**
 * @brief unreachable - Marca código como inalcanzable (C++23 Polyfill)
 *
 * Ayuda al compilador a optimizar y genera mejor código. Si el control
 * llega a un punto marcado como unreachable, el comportamiento es indefinido.
 */
#if defined(__cpp_lib_unreachable) && __cpp_lib_unreachable >= 202202L
using std::unreachable;
#else
[[noreturn]] inline void unreachable()
{
#if defined(__GNUC__) || defined(__clang__)
    __builtin_unreachable();
#elif defined(_MSC_VER)
    __assume(false);
#else
    // Fallback: lanzar excepción o abort
    std::abort();
#endif
}
#endif

} // namespace std_compat

// ============================================================================
// DOCUMENTACIÓN DE FEATURE TEST MACROS
// ============================================================================

/**
 * @page feature_macros Feature Test Macros de std_compat
 *
 * Este header define varios macros para detectar características del compilador:
 *
 * - UINT128_HAS_CPP23_BYTESWAP: std::byteswap disponible
 * - UINT128_HAS_CPP20_BITOPS: std::rotl/rotr disponibles
 * - UINT128_HAS_CPP23_CONSTEXPR_CMATH: std::abs constexpr
 * - UINT128_HAS_IS_CONSTANT_EVALUATED: std::is_constant_evaluated() disponible
 * - UINT128_USE_STD_ROTL_ROTR: Define si usar std::rotl/rotr o implementación propia
 *
 * Ejemplo de uso:
 * @code
 * #if UINT128_HAS_CPP23_BYTESWAP
 *     // Usar std::byteswap directamente
 * #else
 *     // Usar polyfill de std_compat::byteswap
 * #endif
 * @endcode
 */

#endif // UINT128_STD_COMPAT_HPP
