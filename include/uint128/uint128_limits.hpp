/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef UINT128_LIMITS_HPP
#define UINT128_LIMITS_HPP

#include "uint128_t.hpp"
#include <limits>

namespace nstd
{

// Declaración base del template numeric_limits (equivalente a std::numeric_limits)
template <typename T> class numeric_limits;

/**
 * @brief Especialización de nstd::numeric_limits para uint128_t
 *
 * Proporciona información sobre las propiedades numéricas del tipo uint128_t,
 * incluyendo rangos de valores, precisión y características especiales.
 *
 * NOTA: Esta especialización sigue el mismo patrón que std::numeric_limits.
 * Cuando C++ adopte oficialmente uint128_t, esta especialización podrá
 * moverse directamente a namespace std.
 */
template <> class numeric_limits<uint128_t>
{
  public:
    static constexpr bool is_specialized = true;
    static constexpr bool is_signed = false;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr bool has_denorm_loss = false;
    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = true;
    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;

    static constexpr int digits = 128;     // Número de bits significativos
    static constexpr int digits10 = 38;    // floor(128 * log10(2)) = 38
    static constexpr int max_digits10 = 0; // No aplicable para enteros
    static constexpr int radix = 2;        // Base binaria

    static constexpr int min_exponent = 0;   // No aplicable para enteros
    static constexpr int min_exponent10 = 0; // No aplicable para enteros
    static constexpr int max_exponent = 0;   // No aplicable para enteros
    static constexpr int max_exponent10 = 0; // No aplicable para enteros

    static constexpr std::float_denorm_style has_denorm = std::denorm_absent;
    static constexpr std::float_round_style round_style = std::round_toward_zero;

    // ===== MÉTODOS DE VALORES ESPECIALES =====

    /**
     * @brief Valor mínimo representable
     * @return uint128_t(0)
     */
    static constexpr uint128_t min() noexcept
    {
        return uint128_t(0, 0);
    }

    /**
     * @brief Valor más bajo representable (igual a min para enteros sin signo)
     * @return uint128_t(0)
     */
    static constexpr uint128_t lowest() noexcept
    {
        return min();
    }

    /**
     * @brief Valor máximo representable
     * @return 2^128 - 1
     */
    static constexpr uint128_t max() noexcept
    {
        return uint128_t(UINT64_MAX, UINT64_MAX);
    }

    /**
     * @brief Error de precisión de máquina (no aplicable para enteros)
     * @return uint128_t(0)
     */
    static constexpr uint128_t epsilon() noexcept
    {
        return uint128_t(0, 0);
    }

    /**
     * @brief Error de redondeo (no aplicable para enteros)
     * @return uint128_t(0)
     */
    static constexpr uint128_t round_error() noexcept
    {
        return uint128_t(0, 0);
    }

    /**
     * @brief Representación de infinito (no aplicable para enteros)
     * @return uint128_t(0)
     */
    static constexpr uint128_t infinity() noexcept
    {
        return uint128_t(0, 0);
    }

    /**
     * @brief Representación de NaN silencioso (no aplicable para enteros)
     * @return uint128_t(0)
     */
    static constexpr uint128_t quiet_NaN() noexcept
    {
        return uint128_t(0, 0);
    }

    /**
     * @brief Representación de NaN señalizante (no aplicable para enteros)
     * @return uint128_t(0)
     */
    static constexpr uint128_t signaling_NaN() noexcept
    {
        return uint128_t(0, 0);
    }

    /**
     * @brief Valor desnormalizado mínimo (igual a min para enteros)
     * @return uint128_t(0)
     */
    static constexpr uint128_t denorm_min() noexcept
    {
        return min();
    }
};

} // namespace nstd
#endif // UINT128_LIMITS_HPP