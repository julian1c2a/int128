/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @file compiler_intrinsics.hpp
 * @brief Wrappers multiplataforma para intrínsecos del compilador
 *
 * Este header proporciona una interfaz unificada para intrínsecos específicos del
 * compilador (GCC/Clang/MSVC/Intel), ocultando las diferencias de implementación.
 *
 * Todos los wrappers son constexpr-friendly y proporcionan fallbacks manuales
 * para contextos de evaluación en tiempo de compilación.
 *
 * Intrínsecos soportados:
 * - popcount64: Cuenta bits establecidos (population count)
 * - clz64: Count leading zeros (ceros a la izquierda)
 * - ctz64: Count trailing zeros (ceros a la derecha)
 * - bswap64: Byte swap (invertir orden de bytes)
 */

#ifndef UINT128_COMPILER_INTRINSICS_HPP
#define UINT128_COMPILER_INTRINSICS_HPP

#include <cstdint>
#include <type_traits>

// Incluir headers específicos del compilador
#ifdef _MSC_VER
#include <intrin.h>
#endif

namespace uint128
{
namespace intrinsics
{

// ============================================================================
// POPCOUNT - Cuenta el número de bits establecidos
// ============================================================================

/**
 * @brief Cuenta el número de bits establecidos en un uint64_t
 *
 * @param x Valor a examinar
 * @return Número de bits establecidos (0-64)
 *
 * Implementación:
 * - MSVC: __popcnt64 (runtime) o bucle manual (constexpr)
 * - GCC/Clang: __builtin_popcountll (constexpr desde GCC 5/Clang 3.4)
 */
inline constexpr int popcount64(uint64_t x) noexcept
{
#ifdef _MSC_VER
    if (std::is_constant_evaluated()) {
        // Implementación constexpr manual
        int count = 0;
        while (x) {
            count += static_cast<int>(x & 1);
            x >>= 1;
        }
        return count;
    } else {
        return static_cast<int>(__popcnt64(x));
    }
#else
    // GCC/Clang/Intel: usar builtin (constexpr en versiones modernas)
    return __builtin_popcountll(x);
#endif
}

// ============================================================================
// CLZ - Count Leading Zeros (ceros a la izquierda)
// ============================================================================

/**
 * @brief Cuenta los ceros a la izquierda (leading zeros) en un uint64_t
 *
 * @param x Valor a examinar (debe ser != 0)
 * @return Número de ceros a la izquierda (0-63)
 *
 * @warning Comportamiento indefinido si x == 0
 *
 * Implementación:
 * - MSVC: _BitScanReverse64 (runtime) o bucle manual (constexpr)
 * - GCC/Clang: __builtin_clzll
 */
inline constexpr int clz64(uint64_t x) noexcept
{
#ifdef _MSC_VER
    if (std::is_constant_evaluated()) {
        // Implementación constexpr manual
        if (x == 0)
            return 64;
        int count = 0;
        uint64_t mask = 1ULL << 63;
        while ((x & mask) == 0) {
            count++;
            mask >>= 1;
        }
        return count;
    } else {
        unsigned long index;
        _BitScanReverse64(&index, x);
        return 63 - static_cast<int>(index);
    }
#else
    // GCC/Clang/Intel: usar builtin
    return __builtin_clzll(x);
#endif
}

// ============================================================================
// CTZ - Count Trailing Zeros (ceros a la derecha)
// ============================================================================

/**
 * @brief Cuenta los ceros a la derecha (trailing zeros) en un uint64_t
 *
 * @param x Valor a examinar (debe ser != 0)
 * @return Número de ceros a la derecha (0-63)
 *
 * @warning Comportamiento indefinido si x == 0
 *
 * Implementación:
 * - MSVC: _BitScanForward64 (runtime) o bucle manual (constexpr)
 * - GCC/Clang: __builtin_ctzll
 */
inline constexpr int ctz64(uint64_t x) noexcept
{
#ifdef _MSC_VER
    if (std::is_constant_evaluated()) {
        // Implementación constexpr manual
        if (x == 0)
            return 64;
        int count = 0;
        while ((x & 1) == 0) {
            count++;
            x >>= 1;
        }
        return count;
    } else {
        unsigned long index;
        _BitScanForward64(&index, x);
        return static_cast<int>(index);
    }
#else
    // GCC/Clang/Intel: usar builtin
    return __builtin_ctzll(x);
#endif
}

// ============================================================================
// BSWAP - Byte Swap (invertir orden de bytes)
// ============================================================================

/**
 * @brief Invierte el orden de los bytes en un uint64_t
 *
 * @param x Valor cuyos bytes se van a intercambiar
 * @return x con bytes en orden inverso
 *
 * Útil para conversiones big-endian/little-endian.
 *
 * Implementación:
 * - MSVC: _byteswap_uint64 (runtime) o manual (constexpr)
 * - GCC/Clang: __builtin_bswap64
 */
inline constexpr uint64_t bswap64(uint64_t x) noexcept
{
#ifdef _MSC_VER
    if (std::is_constant_evaluated()) {
        // Implementación constexpr manual
        return ((x & 0xFF00000000000000ULL) >> 56) | ((x & 0x00FF000000000000ULL) >> 40) |
               ((x & 0x0000FF0000000000ULL) >> 24) | ((x & 0x000000FF00000000ULL) >> 8) |
               ((x & 0x00000000FF000000ULL) << 8) | ((x & 0x0000000000FF0000ULL) << 24) |
               ((x & 0x000000000000FF00ULL) << 40) | ((x & 0x00000000000000FFULL) << 56);
    } else {
        return _byteswap_uint64(x);
    }
#else
    // GCC/Clang/Intel: usar builtin
    return __builtin_bswap64(x);
#endif
}

// ============================================================================
// EXTENSIONES FUTURAS
// ============================================================================

// Aquí se pueden agregar más intrínsecos en el futuro:
// - rotl64/rotr64: Rotate left/right
// - parity64: Paridad (XOR de todos los bits)
// - ffs64: Find first set (similar a ctz pero 1-indexed)
// - bit_ceil/bit_floor: Potencia de 2 más cercana
// etc.

} // namespace intrinsics
} // namespace uint128

#endif // UINT128_COMPILER_INTRINSICS_HPP
