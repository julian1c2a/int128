/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @file fallback_portable.hpp
 * @brief Implementaciones portables C++ puro sin intrínsecos
 *
 * Este header proporciona implementaciones completamente portables de
 * operaciones de bits usando solo C++ estándar, sin depender de intrínsecos
 * específicos del compilador. Son más lentas pero funcionan en cualquier plataforma.
 *
 * @author Julián Calderón Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-05
 * @copyright Boost Software License 1.0
 */

#ifndef INTRINSICS_FALLBACK_PORTABLE_HPP
#define INTRINSICS_FALLBACK_PORTABLE_HPP

#include <cstdint>
#include <type_traits>

namespace intrinsics
{
    namespace fallback
    {

        // ============================================================================
        // POPCOUNT - Implementación portable
        // ============================================================================

        /**
         * @brief Cuenta bits establecidos (implementación C++ puro)
         *
         * Algoritmo de Brian Kernighan: O(k) donde k = número de bits establecidos
         */
        inline constexpr int popcount64_portable(uint64_t x) noexcept
        {
            int count = 0;
            while (x)
            {
                x &= x - 1; // Limpia el bit menos significativo establecido
                ++count;
            }
            return count;
        }

        /**
         * @brief Popcount usando tabla lookup (más rápido en runtime, no constexpr)
         */
        inline int popcount64_table(uint64_t x) noexcept
        {
            // Tabla de popcount para bytes (0-255)
            static constexpr uint8_t table[256] = {
                0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3,
                4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4,
                4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4,
                5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5,
                4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2,
                3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5,
                5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4,
                5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6,
                4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};

            return table[x & 0xFF] + table[(x >> 8) & 0xFF] + table[(x >> 16) & 0xFF] +
                   table[(x >> 24) & 0xFF] + table[(x >> 32) & 0xFF] + table[(x >> 40) & 0xFF] +
                   table[(x >> 48) & 0xFF] + table[(x >> 56) & 0xFF];
        }

        // ============================================================================
        // CLZ - Count Leading Zeros (implementación portable)
        // ============================================================================

        /**
         * @brief Cuenta ceros a la izquierda (implementación C++ puro)
         *
         * Búsqueda binaria: O(log n) = O(6) para uint64_t
         */
        inline constexpr int clz64_portable(uint64_t x) noexcept
        {
            if (x == 0)
                return 64;

            int count = 0;

            // Búsqueda binaria
            if ((x & 0xFFFFFFFF00000000ULL) == 0)
            {
                count += 32;
                x <<= 32;
            }
            if ((x & 0xFFFF000000000000ULL) == 0)
            {
                count += 16;
                x <<= 16;
            }
            if ((x & 0xFF00000000000000ULL) == 0)
            {
                count += 8;
                x <<= 8;
            }
            if ((x & 0xF000000000000000ULL) == 0)
            {
                count += 4;
                x <<= 4;
            }
            if ((x & 0xC000000000000000ULL) == 0)
            {
                count += 2;
                x <<= 2;
            }
            if ((x & 0x8000000000000000ULL) == 0)
            {
                count += 1;
            }

            return count;
        }

        // ============================================================================
        // CTZ - Count Trailing Zeros (implementación portable)
        // ============================================================================

        /**
         * @brief Cuenta ceros a la derecha (implementación C++ puro)
         *
         * Búsqueda binaria: O(log n) = O(6) para uint64_t
         */
        inline constexpr int ctz64_portable(uint64_t x) noexcept
        {
            if (x == 0)
                return 64;

            int count = 0;

            // Búsqueda binaria
            if ((x & 0x00000000FFFFFFFFULL) == 0)
            {
                count += 32;
                x >>= 32;
            }
            if ((x & 0x000000000000FFFFULL) == 0)
            {
                count += 16;
                x >>= 16;
            }
            if ((x & 0x00000000000000FFULL) == 0)
            {
                count += 8;
                x >>= 8;
            }
            if ((x & 0x000000000000000FULL) == 0)
            {
                count += 4;
                x >>= 4;
            }
            if ((x & 0x0000000000000003ULL) == 0)
            {
                count += 2;
                x >>= 2;
            }
            if ((x & 0x0000000000000001ULL) == 0)
            {
                count += 1;
            }

            return count;
        }

        // ============================================================================
        // BSWAP - Byte Swap (implementación portable)
        // ============================================================================

        /**
         * @brief Invierte orden de bytes (implementación C++ puro)
         */
        inline constexpr uint64_t bswap64_portable(uint64_t x) noexcept
        {
            return ((x & 0xFF00000000000000ULL) >> 56) | ((x & 0x00FF000000000000ULL) >> 40) |
                   ((x & 0x0000FF0000000000ULL) >> 24) | ((x & 0x000000FF00000000ULL) >> 8) |
                   ((x & 0x00000000FF000000ULL) << 8) | ((x & 0x0000000000FF0000ULL) << 24) |
                   ((x & 0x000000000000FF00ULL) << 40) | ((x & 0x00000000000000FFULL) << 56);
        }

        /**
         * @brief Bswap usando shifts y masks (alternativa)
         */
        inline constexpr uint64_t bswap64_shifts(uint64_t x) noexcept
        {
            x = ((x & 0xFF00FF00FF00FF00ULL) >> 8) | ((x & 0x00FF00FF00FF00FFULL) << 8);
            x = ((x & 0xFFFF0000FFFF0000ULL) >> 16) | ((x & 0x0000FFFF0000FFFFULL) << 16);
            x = (x >> 32) | (x << 32);
            return x;
        }

        // ============================================================================
        // ROTL/ROTR - Rotaciones (implementación portable)
        // ============================================================================

        /**
         * @brief Rotación a la izquierda (implementación C++ puro)
         */
        inline constexpr uint64_t rotl64_portable(uint64_t x, int s) noexcept
        {
            s &= 63; // s %= 64
            if (s == 0)
                return x;
            return (x << s) | (x >> (64 - s));
        }

        /**
         * @brief Rotación a la derecha (implementación C++ puro)
         */
        inline constexpr uint64_t rotr64_portable(uint64_t x, int s) noexcept
        {
            s &= 63; // s %= 64
            if (s == 0)
                return x;
            return (x >> s) | (x << (64 - s));
        }

        // ============================================================================
        // ADDC/SUBC - Suma/resta con carry (implementación portable)
        // ============================================================================

        /**
         * @brief Suma con carry (implementación C++ puro)
         *
         * @param a Primer operando
         * @param b Segundo operando
         * @param carry_in Carry de entrada
         * @param carry_out Carry de salida (puntero)
         * @return a + b + carry_in
         */
        inline constexpr uint64_t addc64_portable(uint64_t a, uint64_t b, uint64_t carry_in,
                                                  uint64_t *carry_out) noexcept
        {
            uint64_t sum = a + b;
            uint64_t sum_with_carry = sum + carry_in;

            // Detectar overflow
            *carry_out = (sum < a) || (sum_with_carry < sum) ? 1 : 0;

            return sum_with_carry;
        }

        /**
         * @brief Resta con borrow (implementación C++ puro)
         *
         * @param a Minuendo
         * @param b Sustraendo
         * @param borrow_in Borrow de entrada
         * @param borrow_out Borrow de salida (puntero)
         * @return a - b - borrow_in
         */
        inline constexpr uint64_t subc64_portable(uint64_t a, uint64_t b, uint64_t borrow_in,
                                                  uint64_t *borrow_out) noexcept
        {
            uint64_t diff = a - b;
            uint64_t diff_with_borrow = diff - borrow_in;

            // Detectar underflow
            *borrow_out = (diff > a) || (diff_with_borrow > diff) ? 1 : 0;

            return diff_with_borrow;
        }

    } // namespace fallback
} // namespace intrinsics

#endif // INTRINSICS_FALLBACK_PORTABLE_HPP
