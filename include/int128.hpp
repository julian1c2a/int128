/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_HPP
#define INT128_HPP

/**
 * @file int128.hpp
 * @brief Header unificado para tipos enteros de 128 bits con balance óptimo
 *
 * Este header proporciona acceso a los tipos uint128_t e int128_t con:
 * - ✅ trivially_copyable + standard_layout (optimizaciones del compilador)
 * - ✅ Constructores convenientes (conversiones implícitas)
 * - ✅ Factory functions (estilo funcional)
 * - ✅ Assign functions (modificación in-place)
 * - ✅ std::min/max cross-type (compatibilidad STL)
 * - ✅ Traits completos (integración STL)
 *
 * @example Uso básico:
 * ```cpp
 * #include "int128.hpp"
 *
 * // Tres formas equivalentes de crear valores:
 *
 * // 1. Constructores directos (conveniente)
 * uint128_t u1 = 42;
 * int128_t i1{0xDEADBEEF, 0xCAFEBABE};
 *
 * // 2. Factory functions (funcional)
 * auto u2 = make_uint128(0xDEADBEEF, 0xCAFEBABE);
 * auto i2 = make_int128(-42);
 *
 * // 3. Assign functions (modificación in-place)
 * uint128_t u3{};
 * assign_uint128(u3, 0xDEADBEEF, 0xCAFEBABE);
 *
 * // std::min/max cross-type
 * auto result = std::min(u1, 100);      // uint128_t con int
 * auto mixed = std::max(42LL, i1);      // long long con int128_t
 * ```
 */

// =============================================================================
// HEADERS FUNDAMENTALES (CORE)
// =============================================================================

// Tipos fundamentales
#include "int128/int128_t.hpp"   // Tipo int128_t con propiedades optimales
#include "uint128/uint128_t.hpp" // Tipo uint128_t con propiedades optimales

// Traits para integración STL
#include "int128/int128_traits.hpp"   // std::is_integral, is_trivially_copyable, etc.
#include "uint128/uint128_traits.hpp" // std::is_integral, is_trivially_copyable, etc.

// =============================================================================
// EXTENSIONES CLAVE (BALANCE ÓPTIMO)
// =============================================================================

// Factory functions (estilo funcional)
#include "int128/int128_factory.hpp" // make_uint128(), make_int128()

// Assign functions (modificación in-place)
#include "int128/int128_assign.hpp" // assign_uint128(), assign_int128()

// Cross-type std::min/max (compatibilidad STL)
#include "int128/int128_cmath.hpp"   // std::min/max(int128_t, IntegralType)
#include "uint128/uint128_cmath.hpp" // std::min/max(uint128_t, IntegralType)

// =============================================================================
// VERIFICACIONES DE PROPIEDADES
// =============================================================================

namespace int128_verification
{

// Verificar propiedades clave en tiempo de compilación
static_assert(std::is_trivially_copyable_v<uint128_t>,
              "uint128_t debe ser trivialmente copiable para optimizaciones");
static_assert(std::is_standard_layout_v<uint128_t>,
              "uint128_t debe tener layout estándar para predicibilidad");

static_assert(std::is_trivially_copyable_v<int128_t>,
              "int128_t debe ser trivialmente copiable para optimizaciones");
static_assert(std::is_standard_layout_v<int128_t>,
              "int128_t debe tener layout estándar para predicibilidad");

static_assert(sizeof(uint128_t) == 16, "uint128_t debe ocupar exactamente 16 bytes");
static_assert(sizeof(int128_t) == 16, "int128_t debe ocupar exactamente 16 bytes");

static_assert(alignof(uint128_t) == 8, "uint128_t debe estar alineado a 8 bytes");
static_assert(alignof(int128_t) == 8, "int128_t debe estar alineado a 8 bytes");

// Verificar integración STL
static_assert(std::is_integral_v<uint128_t>, "uint128_t debe ser reconocido como integral");
static_assert(std::is_integral_v<int128_t>, "int128_t debe ser reconocido como integral");
static_assert(std::is_unsigned_v<uint128_t>, "uint128_t debe ser reconocido como unsigned");
static_assert(std::is_signed_v<int128_t>, "int128_t debe ser reconocido como signed");

} // namespace int128_verification

// =============================================================================
// EXTENSIONES OPCIONALES
// =============================================================================

/**
 * Para funcionalidades adicionales, incluir headers específicos:
 *
 * #include "uint128/uint128_algorithm.hpp"  // std::clamp, std::swap especializados
 * #include "uint128/uint128_numeric.hpp"    // std::gcd, std::lcm, std::midpoint
 * #include "uint128/uint128_bits.hpp"       // std::popcount, std::bit_width
 * #include "uint128/uint128_limits.hpp"     // std::numeric_limits especializados
 * #include "uint128/uint128_format.hpp"     // Formateo avanzado
 * #include "uint128/uint128_iostreams.hpp"  // operator<<, operator>>
 * #include "uint128/uint128_ranges.hpp"     // std::iota, accumulate especializados
 * #include "uint128/uint128_concepts.hpp"   // C++20 concepts
 * #include "uint128/uint128_safe.hpp"       // Operaciones con verificación de overflow
 *
 * Y equivalentes para int128:
 * #include "int128/int128_*.hpp"
 */

#endif // INT128_HPP