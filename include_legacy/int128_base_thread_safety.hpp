/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_BASE_THREAD_SAFETY_HPP
#define INT128_BASE_THREAD_SAFETY_HPP

/**
 * @file int128_base_thread_safety.hpp
 * @brief Thread-safe wrappers para int128_base_t<S>
 *
 * Proporciona wrappers thread-safe para operaciones concurrentes:
 *
 * 1. ThreadSafe<S>         - Mutex-based (propósito general)
 * 2. ThreadSafeRW<S>       - Read-Write lock (optimizado para lecturas)
 * 3. ThreadSafeAtomic<S>   - std::atomic wrapper (usa locks internamente)
 * 4. ThreadSafeSpinLock<S> - Spin-lock based (bajo overhead)
 *
 * @author Julián Calderón Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-08
 * @copyright Boost Software License 1.0
 */

#include "int128_base_tt.hpp"
#include <atomic>
#include <mutex>
#include <shared_mutex>

namespace nstd
{

namespace int128_threadsafe
{

// =============================================================================
// OPTION 1: MUTEX-BASED (RECOMMENDED)
// =============================================================================

/**
 * @class ThreadSafe
 * @brief Thread-safe wrapper usando std::mutex
 *
 * Wrapper general recomendado para la mayoría de casos.
 * Todas las operaciones se serializan usando un mutex.
 *
 * @tparam S signedness del tipo (unsigned_type o signed_type)
 *
 * @example
 * ThreadSafe<signedness::unsigned_type> counter(uint128_t(0));
 * counter.add(uint128_t(1));        // Thread-safe increment
 * uint128_t val = counter.get();    // Thread-safe read
 */
template <signedness S> class ThreadSafe
{
  private:
    int128_base_t<S> value_;
    mutable std::mutex mutex_;

  public:
    using value_type = int128_base_t<S>;

    /// @brief Constructor con valor inicial
    explicit ThreadSafe(value_type val = value_type(0)) : value_(val) {}

    // No copiable ni movible (contiene mutex)
    ThreadSafe(const ThreadSafe&) = delete;
    ThreadSafe& operator=(const ThreadSafe&) = delete;
    ThreadSafe(ThreadSafe&&) = delete;
    ThreadSafe& operator=(ThreadSafe&&) = delete;

    /// @brief Obtener valor actual (thread-safe)
    value_type get() const
    {
        std::lock_guard<std::mutex> lock(mutex_);
        return value_;
    }

    /// @brief Establecer nuevo valor (thread-safe)
    void set(value_type val)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_ = val;
    }

    /// @brief Sumar valor (thread-safe)
    void add(value_type val)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_ += val;
    }

    /// @brief Restar valor (thread-safe)
    void subtract(value_type val)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_ -= val;
    }

    /// @brief Multiplicar por valor (thread-safe)
    void multiply(value_type val)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_ *= val;
    }

    /// @brief Dividir por valor (thread-safe)
    void divide(value_type val)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_ /= val;
    }

    /// @brief Fetch-and-add: retorna valor anterior, luego suma
    value_type fetch_add(value_type val)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_type old = value_;
        value_ += val;
        return old;
    }

    /// @brief Fetch-and-subtract: retorna valor anterior, luego resta
    value_type fetch_sub(value_type val)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_type old = value_;
        value_ -= val;
        return old;
    }

    /// @brief Compare-and-swap
    bool compare_exchange(value_type& expected, value_type desired)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        if (value_ == expected) {
            value_ = desired;
            return true;
        }
        expected = value_;
        return false;
    }

    /// @brief Pre-incremento (thread-safe)
    value_type operator++()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        ++value_;
        return value_;
    }

    /// @brief Post-incremento (thread-safe)
    value_type operator++(int)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_type old = value_;
        ++value_;
        return old;
    }

    /// @brief Pre-decremento (thread-safe)
    value_type operator--()
    {
        std::lock_guard<std::mutex> lock(mutex_);
        --value_;
        return value_;
    }

    /// @brief Post-decremento (thread-safe)
    value_type operator--(int)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_type old = value_;
        --value_;
        return old;
    }

    /// @brief Aplicar operación arbitraria atómicamente
    template <typename Func> value_type apply(Func func)
    {
        std::lock_guard<std::mutex> lock(mutex_);
        value_ = func(value_);
        return value_;
    }
};

// =============================================================================
// OPTION 2: READ-WRITE LOCK
// =============================================================================

/**
 * @class ThreadSafeRW
 * @brief Thread-safe wrapper usando read-write lock (std::shared_mutex)
 *
 * Optimizado para cargas de trabajo con muchas lecturas.
 * Múltiples lectores pueden acceder simultáneamente.
 *
 * @tparam S signedness del tipo
 */
template <signedness S> class ThreadSafeRW
{
  private:
    int128_base_t<S> value_;
    mutable std::shared_mutex mutex_;

  public:
    using value_type = int128_base_t<S>;

    explicit ThreadSafeRW(value_type val = value_type(0)) : value_(val) {}

    ThreadSafeRW(const ThreadSafeRW&) = delete;
    ThreadSafeRW& operator=(const ThreadSafeRW&) = delete;
    ThreadSafeRW(ThreadSafeRW&&) = delete;
    ThreadSafeRW& operator=(ThreadSafeRW&&) = delete;

    /// @brief Obtener valor (permite lecturas concurrentes)
    value_type get() const
    {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return value_;
    }

    /// @brief Establecer valor (acceso exclusivo)
    void set(value_type val)
    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        value_ = val;
    }

    /// @brief Sumar valor (acceso exclusivo)
    void add(value_type val)
    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        value_ += val;
    }

    /// @brief Restar valor (acceso exclusivo)
    void subtract(value_type val)
    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        value_ -= val;
    }

    /// @brief Multiplicar (acceso exclusivo)
    void multiply(value_type val)
    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        value_ *= val;
    }

    /// @brief Dividir (acceso exclusivo)
    void divide(value_type val)
    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        value_ /= val;
    }

    /// @brief Fetch-and-add (acceso exclusivo)
    value_type fetch_add(value_type val)
    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        value_type old = value_;
        value_ += val;
        return old;
    }

    /// @brief Fetch-and-subtract (acceso exclusivo)
    value_type fetch_sub(value_type val)
    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        value_type old = value_;
        value_ -= val;
        return old;
    }

    /// @brief Compare-and-swap (acceso exclusivo)
    bool compare_exchange(value_type& expected, value_type desired)
    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        if (value_ == expected) {
            value_ = desired;
            return true;
        }
        expected = value_;
        return false;
    }

    /// @brief Aplicar operación de lectura (shared lock)
    template <typename Func> auto read(Func func) const -> decltype(func(value_))
    {
        std::shared_lock<std::shared_mutex> lock(mutex_);
        return func(value_);
    }

    /// @brief Aplicar operación de escritura (unique lock)
    template <typename Func> void modify(Func func)
    {
        std::unique_lock<std::shared_mutex> lock(mutex_);
        func(value_);
    }
};

// =============================================================================
// OPTION 3: ATOMIC WRAPPER
// =============================================================================

/**
 * @class ThreadSafeAtomic
 * @brief Thread-safe wrapper usando std::atomic
 *
 * Usa std::atomic para thread-safety. Nota: std::atomic<int128_base_t<S>>
 * típicamente NO es lock-free y usa locks internamente.
 *
 * @tparam S signedness del tipo
 */
template <signedness S> class ThreadSafeAtomic
{
  private:
    std::atomic<int128_base_t<S>> value_;

  public:
    using value_type = int128_base_t<S>;

    explicit ThreadSafeAtomic(value_type val = value_type(0)) : value_(val) {}

    /// @brief Verificar si las operaciones son lock-free
    bool is_lock_free() const noexcept
    {
        return value_.is_lock_free();
    }

    /// @brief Cargar valor atómicamente
    value_type load(std::memory_order order = std::memory_order_seq_cst) const noexcept
    {
        return value_.load(order);
    }

    /// @brief Almacenar valor atómicamente
    void store(value_type val, std::memory_order order = std::memory_order_seq_cst) noexcept
    {
        value_.store(val, order);
    }

    /// @brief Intercambiar valor atómicamente
    value_type exchange(value_type val,
                        std::memory_order order = std::memory_order_seq_cst) noexcept
    {
        return value_.exchange(val, order);
    }

    /// @brief Compare-and-exchange weak
    bool compare_exchange_weak(value_type& expected, value_type desired,
                               std::memory_order order = std::memory_order_seq_cst) noexcept
    {
        return value_.compare_exchange_weak(expected, desired, order);
    }

    /// @brief Compare-and-exchange strong
    bool compare_exchange_strong(value_type& expected, value_type desired,
                                 std::memory_order order = std::memory_order_seq_cst) noexcept
    {
        return value_.compare_exchange_strong(expected, desired, order);
    }

    /// @brief Obtener valor (convenience)
    value_type get() const
    {
        return load();
    }

    /// @brief Establecer valor (convenience)
    void set(value_type val)
    {
        store(val);
    }
};

// =============================================================================
// OPTION 4: SPIN-LOCK
// =============================================================================

/**
 * @class ThreadSafeSpinLock
 * @brief Thread-safe wrapper usando spin-lock
 *
 * Usa std::atomic_flag para un spin-lock simple. Mejor para secciones
 * críticas muy cortas donde la contención es baja.
 *
 * @tparam S signedness del tipo
 *
 * @warning Puede desperdiciar ciclos CPU si la contención es alta
 */
template <signedness S> class ThreadSafeSpinLock
{
  private:
    int128_base_t<S> value_;
    mutable std::atomic_flag lock_ = ATOMIC_FLAG_INIT;

    void acquire() const
    {
        while (lock_.test_and_set(std::memory_order_acquire)) {
            // Spin-wait con pausa para reducir consumo
#if defined(__x86_64__) || defined(_M_X64)
#if defined(__GNUC__) || defined(__clang__)
            __builtin_ia32_pause();
#elif defined(_MSC_VER)
            _mm_pause();
#endif
#endif
        }
    }

    void release() const
    {
        lock_.clear(std::memory_order_release);
    }

  public:
    using value_type = int128_base_t<S>;

    explicit ThreadSafeSpinLock(value_type val = value_type(0)) : value_(val) {}

    ThreadSafeSpinLock(const ThreadSafeSpinLock&) = delete;
    ThreadSafeSpinLock& operator=(const ThreadSafeSpinLock&) = delete;
    ThreadSafeSpinLock(ThreadSafeSpinLock&&) = delete;
    ThreadSafeSpinLock& operator=(ThreadSafeSpinLock&&) = delete;

    value_type get() const
    {
        acquire();
        value_type result = value_;
        release();
        return result;
    }

    void set(value_type val)
    {
        acquire();
        value_ = val;
        release();
    }

    void add(value_type val)
    {
        acquire();
        value_ += val;
        release();
    }

    void subtract(value_type val)
    {
        acquire();
        value_ -= val;
        release();
    }

    void multiply(value_type val)
    {
        acquire();
        value_ *= val;
        release();
    }

    void divide(value_type val)
    {
        acquire();
        value_ /= val;
        release();
    }

    value_type fetch_add(value_type val)
    {
        acquire();
        value_type old = value_;
        value_ += val;
        release();
        return old;
    }

    value_type fetch_sub(value_type val)
    {
        acquire();
        value_type old = value_;
        value_ -= val;
        release();
        return old;
    }

    bool compare_exchange(value_type& expected, value_type desired)
    {
        acquire();
        bool success = false;
        if (value_ == expected) {
            value_ = desired;
            success = true;
        } else {
            expected = value_;
        }
        release();
        return success;
    }
};

// =============================================================================
// TYPE ALIASES FOR CONVENIENCE
// =============================================================================

// Unsigned wrappers
using ThreadSafeUint128 = ThreadSafe<signedness::unsigned_type>;
using ThreadSafeUint128RW = ThreadSafeRW<signedness::unsigned_type>;
using ThreadSafeUint128Atomic = ThreadSafeAtomic<signedness::unsigned_type>;
using ThreadSafeUint128SpinLock = ThreadSafeSpinLock<signedness::unsigned_type>;

// Signed wrappers
using ThreadSafeInt128 = ThreadSafe<signedness::signed_type>;
using ThreadSafeInt128RW = ThreadSafeRW<signedness::signed_type>;
using ThreadSafeInt128Atomic = ThreadSafeAtomic<signedness::signed_type>;
using ThreadSafeInt128SpinLock = ThreadSafeSpinLock<signedness::signed_type>;

} // namespace int128_threadsafe

} // namespace nstd

#endif // INT128_BASE_THREAD_SAFETY_HPP
