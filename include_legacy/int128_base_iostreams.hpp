/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_BASE_IOSTREAMS_HPP
#define INT128_BASE_IOSTREAMS_HPP

/**
 * @file int128_base_iostreams.hpp
 * @brief Funciones de formateo iostream para int128_base_t<S>
 * @author Julian Calderon Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-08
 * @copyright Boost Software License 1.0
 *
 * Este header proporciona funciones de conveniencia para formateo.
 *
 * NOTA: Los operadores operator<< y operator>> estan definidos como friend
 * functions dentro de int128_base_t en int128_base_tt.hpp y ya soportan
 * todos los manipuladores estandar (hex, oct, dec, setw, setfill, etc.)
 *
 * Funciones de conveniencia:
 * - int128_iostream::format() - formateo completo con todas las opciones
 * - int128_iostream::hex() - formateo hexadecimal
 * - int128_iostream::oct() - formateo octal
 * - int128_iostream::dec() - formateo decimal
 * - int128_iostream::dec_signed() - decimal con signo visible
 */

// Feature test macro
#define INT128_BASE_IOSTREAMS_AVAILABLE 1

#include "int128_base_tt.hpp"
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>

namespace nstd
{

// =============================================================================
// FUNCIONES DE FORMATEO DE CONVENIENCIA
// =============================================================================

namespace int128_iostream
{

/**
 * @brief Formatea un valor con opciones especificas
 * @tparam S signedness del tipo
 * @param value Valor a formatear
 * @param base Base numerica (10, 16, 8)
 * @param width Ancho minimo
 * @param fill Caracter de relleno
 * @param show_base Mostrar prefijo de base (0x, 0)
 * @param show_pos Mostrar signo + para positivos
 * @param uppercase Usar mayusculas (hex)
 * @param left_align Alinear a la izquierda
 * @param internal_align Relleno interno (despues de signo/prefijo)
 * @return String formateado
 */
template <signedness S>
inline std::string format(const int128_base_t<S>& value, int base = 10, int width = 0,
                          char fill = ' ', bool show_base = false, bool show_pos = false,
                          bool uppercase = false, bool left_align = false,
                          bool internal_align = false)
{
    std::ostringstream oss;

    // Configurar base
    switch (base) {
    case 16:
        oss << std::hex;
        break;
    case 8:
        oss << std::oct;
        break;
    default:
        oss << std::dec;
        break;
    }

    // Configurar opciones
    if (show_base)
        oss << std::showbase;
    if (show_pos)
        oss << std::showpos;
    if (uppercase)
        oss << std::uppercase;
    if (width > 0)
        oss << std::setw(width);
    if (fill != ' ')
        oss << std::setfill(fill);

    // Configurar alineacion
    if (left_align) {
        oss << std::left;
    } else if (internal_align) {
        oss << std::internal;
    } else {
        oss << std::right;
    }

    oss << value;
    return oss.str();
}

/**
 * @brief Formateo hexadecimal
 */
template <signedness S>
inline std::string hex(const int128_base_t<S>& value, int width = 0, bool show_base = false,
                       bool uppercase = false, char fill = '0')
{
    return format(value, 16, width, fill, show_base, false, uppercase, false, false);
}

/**
 * @brief Formateo octal
 */
template <signedness S>
inline std::string oct(const int128_base_t<S>& value, int width = 0, bool show_base = false,
                       char fill = '0')
{
    return format(value, 8, width, fill, show_base, false, false, false, false);
}

/**
 * @brief Formateo decimal
 */
template <signedness S>
inline std::string dec(const int128_base_t<S>& value, int width = 0, char fill = ' ',
                       bool left_align = false)
{
    return format(value, 10, width, fill, false, false, false, left_align, false);
}

/**
 * @brief Formateo decimal con signo siempre visible
 */
template <signedness S>
inline std::string dec_signed(const int128_base_t<S>& value, int width = 0, char fill = ' ',
                              bool left_align = false)
{
    return format(value, 10, width, fill, false, true, false, left_align, false);
}

} // namespace int128_iostream

} // namespace nstd

#endif // INT128_BASE_IOSTREAMS_HPP
