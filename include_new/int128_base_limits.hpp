/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @file int128_base_limits.hpp
 * @brief Especialización de nstd::numeric_limits para int128_base_t<S>
 *
 * Proporciona información sobre las propiedades numéricas de los tipos
 * uint128_t e int128_t usando un template unificado.
 *
 * @note Fase 1.5: Template unificado para signed/unsigned
 */

#ifndef INT128_BASE_LIMITS_HPP
#define INT128_BASE_LIMITS_HPP

#include "int128_base_tt.hpp"
#include <limits>

namespace nstd
{

// Forward declaration del template base
template <typename T> class numeric_limits;

/**
 * @brief Especialización genérica de nstd::numeric_limits para int128_base_t<S>
 *
 * Este template especializado maneja automáticamente las diferencias entre
 * tipos signed y unsigned usando `if constexpr`.
 *
 * @tparam S signedness::unsigned_type o signedness::signed_type
 */
template <signedness S> class numeric_limits<int128_base_t<S>>
{
  private:
    static constexpr bool is_signed_type = (S == signedness::signed_type);
    using value_type = int128_base_t<S>;

  public:
    // ===== PROPIEDADES DEL TIPO =====
    static constexpr bool is_specialized = true;
    static constexpr bool is_signed = is_signed_type;
    static constexpr bool is_integer = true;
    static constexpr bool is_exact = true;
    static constexpr bool has_infinity = false;
    static constexpr bool has_quiet_NaN = false;
    static constexpr bool has_signaling_NaN = false;
    static constexpr bool has_denorm_loss = false;
    static constexpr bool is_iec559 = false;
    static constexpr bool is_bounded = true;
    static constexpr bool is_modulo = !is_signed_type; // unsigned es modulo, signed no
    static constexpr bool traps = false;
    static constexpr bool tinyness_before = false;

    // Bits significativos: 128 para unsigned, 127 para signed (1 bit de signo)
    static constexpr int digits = is_signed_type ? 127 : 128;
    static constexpr int digits10 = 38;    // floor(digits * log10(2)) ~ 38
    static constexpr int max_digits10 = 0; // No aplicable para enteros
    static constexpr int radix = 2;        // Base binaria

    static constexpr int min_exponent = 0;   // No aplicable para enteros
    static constexpr int min_exponent10 = 0; // No aplicable para enteros
    static constexpr int max_exponent = 0;   // No aplicable para enteros
    static constexpr int max_exponent10 = 0; // No aplicable para enteros

    static constexpr std::float_denorm_style has_denorm = std::denorm_absent;
    static constexpr std::float_round_style round_style = std::round_toward_zero;

    // ===== METODOS DE VALORES ESPECIALES =====

    /**
     * @brief Valor minimo representable
     * @return Para unsigned: 0, Para signed: -2^127
     */
    static constexpr value_type min() noexcept
    {
        if constexpr (is_signed_type) {
            // -2^127: high = 0x8000000000000000, low = 0
            return value_type(
                static_cast<uint64_t>(std::numeric_limits<int64_t>::min()), // high = 0x8000...
                0ULL                                                        // low = 0
            );
        } else {
            return value_type(0ULL, 0ULL);
        }
    }

    /**
     * @brief Valor mas bajo representable (igual a min para enteros)
     */
    static constexpr value_type lowest() noexcept
    {
        return min();
    }

    /**
     * @brief Valor maximo representable
     * @return Para unsigned: 2^128 - 1, Para signed: 2^127 - 1
     */
    static constexpr value_type max() noexcept
    {
        if constexpr (is_signed_type) {
            // 2^127 - 1: high = 0x7FFFFFFFFFFFFFFF, low = 0xFFFFFFFFFFFFFFFF
            return value_type(std::numeric_limits<int64_t>::max(), // high = 0x7FFF...
                              std::numeric_limits<uint64_t>::max() // low = 0xFFFF...
            );
        } else {
            // 2^128 - 1: high = low = 0xFFFFFFFFFFFFFFFF
            return value_type(std::numeric_limits<uint64_t>::max(),
                              std::numeric_limits<uint64_t>::max());
        }
    }

    /**
     * @brief Error de precision de maquina (no aplicable para enteros)
     */
    static constexpr value_type epsilon() noexcept
    {
        return value_type(0ULL, 0ULL);
    }

    /**
     * @brief Error de redondeo (no aplicable para enteros)
     */
    static constexpr value_type round_error() noexcept
    {
        return value_type(0ULL, 0ULL);
    }

    /**
     * @brief Representacion de infinito (no aplicable para enteros)
     */
    static constexpr value_type infinity() noexcept
    {
        return value_type(0ULL, 0ULL);
    }

    /**
     * @brief Representacion de NaN silencioso (no aplicable para enteros)
     */
    static constexpr value_type quiet_NaN() noexcept
    {
        return value_type(0ULL, 0ULL);
    }

    /**
     * @brief Representacion de NaN senalizante (no aplicable para enteros)
     */
    static constexpr value_type signaling_NaN() noexcept
    {
        return value_type(0ULL, 0ULL);
    }

    /**
     * @brief Valor desnormalizado minimo (igual a min para enteros)
     */
    static constexpr value_type denorm_min() noexcept
    {
        return min();
    }
};

// ===== VERIFICACIONES ESTATICAS =====
static_assert(numeric_limits<uint128_t>::is_signed == false, "uint128_t debe ser unsigned");
static_assert(numeric_limits<int128_t>::is_signed == true, "int128_t debe ser signed");
static_assert(numeric_limits<uint128_t>::digits == 128, "uint128_t debe tener 128 bits");
static_assert(numeric_limits<int128_t>::digits == 127,
              "int128_t debe tener 127 bits significativos");
static_assert(numeric_limits<uint128_t>::is_modulo == true, "uint128_t debe ser modulo");
static_assert(numeric_limits<int128_t>::is_modulo == false, "int128_t no debe ser modulo");

} // namespace nstd

#endif // INT128_BASE_LIMITS_HPP
