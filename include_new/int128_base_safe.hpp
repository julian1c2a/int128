/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_BASE_SAFE_HPP
#define INT128_BASE_SAFE_HPP

/**
 * @file int128_base_safe.hpp
 * @brief Operaciones seguras con deteccion de overflow/underflow para int128_base_t<S>
 *
 * Este header proporciona:
 * - safe_result<T>: Tipo de resultado con estado de conversion
 * - safe_cast<T>(): Conversion segura a tipos mas pequenos
 * - safe_add/sub/mul/div/mod(): Aritmetica con deteccion de overflow
 * - saturating_add/sub/mul(): Aritmetica con saturacion
 * - checked_cast<T>(): Conversion que lanza excepcion
 * - try_cast<T>(): Conversion con std::optional
 *
 * @note Fase 1.5: Template unificado para signed/unsigned
 *
 * @author Julian Calderon Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-08
 * @copyright Boost Software License 1.0
 */

// Feature test macro
#define INT128_BASE_SAFE_AVAILABLE 1

#include "int128_base_tt.hpp"
#include <cmath>
#include <limits>
#include <optional>
#include <stdexcept>
#include <type_traits>

namespace nstd
{

namespace int128_safe
{

// =============================================================================
// Result types
// =============================================================================

/**
 * @brief Resultado de conversion/operacion segura
 */
enum class conversion_result {
    success,      ///< Operacion exitosa
    overflow,     ///< Valor demasiado grande
    underflow,    ///< Valor demasiado pequeno (o negativo para unsigned)
    invalid_input ///< Entrada invalida (NaN, Inf, division por cero)
};

/**
 * @brief Resultado seguro con valor y estado
 */
template <typename T> struct safe_result {
    T value;
    conversion_result status;

    constexpr bool is_valid() const noexcept
    {
        return status == conversion_result::success;
    }

    constexpr explicit operator bool() const noexcept
    {
        return is_valid();
    }

    constexpr T value_or(const T& default_value) const noexcept
    {
        return is_valid() ? value : default_value;
    }
};

// =============================================================================
// Safe conversions FROM int128_base_t<S> to other types
// =============================================================================

/**
 * @brief Conversion segura de int128_base_t<S> a tipos integrales
 */
template <signedness S, typename T>
constexpr safe_result<T> safe_cast(const int128_base_t<S>& value) noexcept
{
    static_assert(std::is_integral_v<T>, "Target type must be integral");

    if constexpr (S == signedness::unsigned_type) {
        // Conversion desde unsigned
        if constexpr (std::is_signed_v<T>) {
            // A signed: verificar que cabe en el rango positivo
            constexpr auto max_val = static_cast<uint64_t>(std::numeric_limits<T>::max());
            if (value.high() > 0 || value.low() > max_val) {
                return {T(0), conversion_result::overflow};
            }
            return {static_cast<T>(value.low()), conversion_result::success};
        } else {
            // A unsigned
            if constexpr (sizeof(T) >= 8) {
                if (value.high() > 0) {
                    return {T(0), conversion_result::overflow};
                }
                return {static_cast<T>(value.low()), conversion_result::success};
            } else {
                constexpr auto max_val = static_cast<uint64_t>(std::numeric_limits<T>::max());
                if (value.high() > 0 || value.low() > max_val) {
                    return {T(0), conversion_result::overflow};
                }
                return {static_cast<T>(value.low()), conversion_result::success};
            }
        }
    } else {
        // Conversion desde signed
        bool is_negative = value.is_negative();
        auto abs_value = value.abs();

        if constexpr (std::is_signed_v<T>) {
            // A signed
            constexpr auto min_val = static_cast<int64_t>(std::numeric_limits<T>::min());
            constexpr auto max_val = static_cast<int64_t>(std::numeric_limits<T>::max());

            if (abs_value.high() > 0) {
                return {T(0),
                        is_negative ? conversion_result::underflow : conversion_result::overflow};
            }

            int64_t int64_val = is_negative ? -static_cast<int64_t>(abs_value.low())
                                            : static_cast<int64_t>(abs_value.low());

            if (int64_val < min_val) {
                return {T(0), conversion_result::underflow};
            }
            if (int64_val > max_val) {
                return {T(0), conversion_result::overflow};
            }

            return {static_cast<T>(int64_val), conversion_result::success};
        } else {
            // A unsigned: negativos causan underflow
            if (is_negative) {
                return {T(0), conversion_result::underflow};
            }

            if constexpr (sizeof(T) >= 8) {
                if (abs_value.high() > 0) {
                    return {T(0), conversion_result::overflow};
                }
                return {static_cast<T>(abs_value.low()), conversion_result::success};
            } else {
                constexpr auto max_val = static_cast<uint64_t>(std::numeric_limits<T>::max());
                if (abs_value.high() > 0 || abs_value.low() > max_val) {
                    return {T(0), conversion_result::overflow};
                }
                return {static_cast<T>(abs_value.low()), conversion_result::success};
            }
        }
    }
}

/**
 * @brief Conversion segura a tipos de punto flotante
 */
template <signedness S, typename T>
constexpr safe_result<T> safe_cast_float(const int128_base_t<S>& value) noexcept
{
    static_assert(std::is_floating_point_v<T>, "Target type must be floating point");

    T result;

    if constexpr (S == signedness::unsigned_type) {
        T high_part = static_cast<T>(value.high());
        T low_part = static_cast<T>(value.low());
        result = high_part * static_cast<T>(18446744073709551616.0) + low_part;
    } else {
        bool is_negative = value.is_negative();
        auto abs_value = value.abs();

        T high_part = static_cast<T>(abs_value.high());
        T low_part = static_cast<T>(abs_value.low());
        result = high_part * static_cast<T>(18446744073709551616.0) + low_part;

        if (is_negative) {
            result = -result;
        }
    }

    if (!std::isfinite(result)) {
        return {T(0), conversion_result::overflow};
    }

    return {result, conversion_result::success};
}

/**
 * @brief Conversion que lanza excepcion en caso de fallo
 */
template <signedness S, typename T> constexpr T checked_cast(const int128_base_t<S>& value)
{
    if constexpr (std::is_floating_point_v<T>) {
        auto result = safe_cast_float<S, T>(value);
        if (!result.is_valid()) {
            throw std::overflow_error("int128 value too large for target floating point type");
        }
        return result.value;
    } else {
        auto result = safe_cast<S, T>(value);
        if (result.status == conversion_result::overflow) {
            throw std::overflow_error("int128 value too large for target type");
        } else if (result.status == conversion_result::underflow) {
            throw std::underflow_error("int128 value too small for target type");
        }
        return result.value;
    }
}

/**
 * @brief Conversion basada en std::optional
 */
template <signedness S, typename T>
constexpr std::optional<T> try_cast(const int128_base_t<S>& value) noexcept
{
    if constexpr (std::is_floating_point_v<T>) {
        auto result = safe_cast_float<S, T>(value);
        return result.is_valid() ? std::make_optional(result.value) : std::nullopt;
    } else {
        auto result = safe_cast<S, T>(value);
        return result.is_valid() ? std::make_optional(result.value) : std::nullopt;
    }
}

// =============================================================================
// Safe arithmetic operations
// =============================================================================

/**
 * @brief Suma segura con deteccion de overflow
 */
template <signedness S>
constexpr safe_result<int128_base_t<S>> safe_add(const int128_base_t<S>& a,
                                                 const int128_base_t<S>& b) noexcept
{
    int128_base_t<S> result = a + b;

    if constexpr (S == signedness::unsigned_type) {
        // Unsigned: overflow si result < a
        if (result < a) {
            return {int128_base_t<S>(0), conversion_result::overflow};
        }
    } else {
        // Signed: overflow si signos iguales pero resultado tiene signo diferente
        bool a_positive = !a.is_negative();
        bool b_positive = !b.is_negative();
        bool result_positive = !result.is_negative();

        if (a_positive && b_positive && !result_positive) {
            return {int128_base_t<S>(0), conversion_result::overflow};
        }
        if (!a_positive && !b_positive && result_positive) {
            return {int128_base_t<S>(0), conversion_result::underflow};
        }
    }

    return {result, conversion_result::success};
}

/**
 * @brief Resta segura con deteccion de underflow
 */
template <signedness S>
constexpr safe_result<int128_base_t<S>> safe_sub(const int128_base_t<S>& a,
                                                 const int128_base_t<S>& b) noexcept
{
    if constexpr (S == signedness::unsigned_type) {
        if (a < b) {
            return {int128_base_t<S>(0), conversion_result::underflow};
        }
        return {a - b, conversion_result::success};
    } else {
        int128_base_t<S> result = a - b;

        bool a_positive = !a.is_negative();
        bool b_positive = !b.is_negative();
        bool result_positive = !result.is_negative();

        if (a_positive && !b_positive && !result_positive) {
            return {int128_base_t<S>(0), conversion_result::overflow};
        }
        if (!a_positive && b_positive && result_positive) {
            return {int128_base_t<S>(0), conversion_result::underflow};
        }

        return {result, conversion_result::success};
    }
}

/**
 * @brief Multiplicacion segura con deteccion de overflow
 */
template <signedness S>
constexpr safe_result<int128_base_t<S>> safe_mul(const int128_base_t<S>& a,
                                                 const int128_base_t<S>& b) noexcept
{
    if (a == int128_base_t<S>(0) || b == int128_base_t<S>(0)) {
        return {int128_base_t<S>(0), conversion_result::success};
    }

    // Check preliminar: ambas partes altas no-cero = overflow seguro
    if (a.high() != 0 && b.high() != 0) {
        if constexpr (S == signedness::unsigned_type) {
            return {int128_base_t<S>(0), conversion_result::overflow};
        } else {
            // Para signed, determinar signo del resultado
            bool should_be_positive = (a.is_negative() == b.is_negative());
            return {int128_base_t<S>(0), should_be_positive ? conversion_result::overflow
                                                            : conversion_result::underflow};
        }
    }

    int128_base_t<S> result = a * b;

    // Verificar dividiendo de vuelta
    if (result / a != b) {
        if constexpr (S == signedness::unsigned_type) {
            return {int128_base_t<S>(0), conversion_result::overflow};
        } else {
            bool should_be_positive = (a.is_negative() == b.is_negative());
            return {int128_base_t<S>(0), should_be_positive ? conversion_result::overflow
                                                            : conversion_result::underflow};
        }
    }

    return {result, conversion_result::success};
}

/**
 * @brief Division segura con deteccion de division por cero
 */
template <signedness S>
constexpr safe_result<int128_base_t<S>> safe_div(const int128_base_t<S>& a,
                                                 const int128_base_t<S>& b) noexcept
{
    if (b == int128_base_t<S>(0)) {
        return {int128_base_t<S>(0), conversion_result::invalid_input};
    }

    // Caso especial signed: min() / -1 = overflow
    if constexpr (S == signedness::signed_type) {
        if (a == std::numeric_limits<int128_t>::min() && b == int128_base_t<S>(-1)) {
            return {int128_base_t<S>(0), conversion_result::overflow};
        }
    }

    return {a / b, conversion_result::success};
}

/**
 * @brief Modulo seguro con deteccion de division por cero
 */
template <signedness S>
constexpr safe_result<int128_base_t<S>> safe_mod(const int128_base_t<S>& a,
                                                 const int128_base_t<S>& b) noexcept
{
    if (b == int128_base_t<S>(0)) {
        return {int128_base_t<S>(0), conversion_result::invalid_input};
    }

    // Caso especial signed: min() % -1 = 0 (no overflow, resultado valido)
    if constexpr (S == signedness::signed_type) {
        if (a == std::numeric_limits<int128_t>::min() && b == int128_base_t<S>(-1)) {
            return {int128_base_t<S>(0), conversion_result::success};
        }
    }

    return {a % b, conversion_result::success};
}

/**
 * @brief Shift izquierdo seguro
 */
template <signedness S>
constexpr safe_result<int128_base_t<S>> safe_shl(const int128_base_t<S>& value, int shift) noexcept
{
    if (shift < 0 || shift >= 128) {
        return {int128_base_t<S>(0), conversion_result::invalid_input};
    }

    if (shift == 0) {
        return {value, conversion_result::success};
    }

    int128_base_t<S> result = value << shift;

    // Verificar que no se perdieron bits
    if ((result >> shift) != value) {
        if constexpr (S == signedness::unsigned_type) {
            return {int128_base_t<S>(0), conversion_result::overflow};
        } else {
            return {int128_base_t<S>(0), value.is_negative() ? conversion_result::underflow
                                                             : conversion_result::overflow};
        }
    }

    return {result, conversion_result::success};
}

/**
 * @brief Shift derecho seguro
 */
template <signedness S>
constexpr safe_result<int128_base_t<S>> safe_shr(const int128_base_t<S>& value, int shift) noexcept
{
    if (shift < 0 || shift >= 128) {
        return {int128_base_t<S>(0), conversion_result::invalid_input};
    }

    return {value >> shift, conversion_result::success};
}

// =============================================================================
// Saturating arithmetic
// =============================================================================

/**
 * @brief Suma con saturacion (clamp en max/min en overflow)
 */
template <signedness S>
constexpr int128_base_t<S> saturating_add(const int128_base_t<S>& a,
                                          const int128_base_t<S>& b) noexcept
{
    auto result = safe_add(a, b);
    if (result.is_valid()) {
        return result.value;
    }

    if constexpr (S == signedness::unsigned_type) {
        return std::numeric_limits<uint128_t>::max();
    } else {
        return (result.status == conversion_result::overflow)
                   ? std::numeric_limits<int128_t>::max()
                   : std::numeric_limits<int128_t>::min();
    }
}

/**
 * @brief Resta con saturacion
 */
template <signedness S>
constexpr int128_base_t<S> saturating_sub(const int128_base_t<S>& a,
                                          const int128_base_t<S>& b) noexcept
{
    auto result = safe_sub(a, b);
    if (result.is_valid()) {
        return result.value;
    }

    if constexpr (S == signedness::unsigned_type) {
        return int128_base_t<S>(0);
    } else {
        return (result.status == conversion_result::overflow)
                   ? std::numeric_limits<int128_t>::max()
                   : std::numeric_limits<int128_t>::min();
    }
}

/**
 * @brief Multiplicacion con saturacion
 */
template <signedness S>
constexpr int128_base_t<S> saturating_mul(const int128_base_t<S>& a,
                                          const int128_base_t<S>& b) noexcept
{
    auto result = safe_mul(a, b);
    if (result.is_valid()) {
        return result.value;
    }

    if constexpr (S == signedness::unsigned_type) {
        return std::numeric_limits<uint128_t>::max();
    } else {
        return (result.status == conversion_result::overflow)
                   ? std::numeric_limits<int128_t>::max()
                   : std::numeric_limits<int128_t>::min();
    }
}

// =============================================================================
// Additional safe operations (signed only)
// =============================================================================

/**
 * @brief Valor absoluto seguro (solo para signed)
 */
template <signedness S>
constexpr safe_result<int128_base_t<S>> safe_abs(const int128_base_t<S>& value) noexcept
    requires(S == signedness::signed_type)
{
    // abs(min()) overflow porque -(-2^127) = 2^127 no cabe en int128_t
    if (value == std::numeric_limits<int128_t>::min()) {
        return {int128_base_t<S>(0), conversion_result::overflow};
    }

    return {value.abs(), conversion_result::success};
}

/**
 * @brief Valor absoluto con saturacion (solo para signed)
 */
template <signedness S>
constexpr int128_base_t<S> saturating_abs(const int128_base_t<S>& value) noexcept
    requires(S == signedness::signed_type)
{
    auto result = safe_abs<S>(value);
    return result.is_valid() ? result.value : std::numeric_limits<int128_t>::max();
}

// =============================================================================
// Range checking utilities
// =============================================================================

/**
 * @brief Verifica si el valor esta en el rango [min, max]
 */
template <signedness S>
constexpr bool in_range(const int128_base_t<S>& value, const int128_base_t<S>& min_val,
                        const int128_base_t<S>& max_val) noexcept
{
    return value >= min_val && value <= max_val;
}

/**
 * @brief Clamp al rango [min, max]
 */
template <signedness S>
constexpr int128_base_t<S> clamp(const int128_base_t<S>& value, const int128_base_t<S>& min_val,
                                 const int128_base_t<S>& max_val) noexcept
{
    if (value < min_val)
        return min_val;
    if (value > max_val)
        return max_val;
    return value;
}

} // namespace int128_safe

} // namespace nstd

#endif // INT128_BASE_SAFE_HPP
