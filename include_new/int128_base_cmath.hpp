/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @file int128_base_cmath.hpp
 * @brief Funciones matematicas para int128_base_t<S> unificado
 *
 * Proporciona: gcd, lcm, pow, sqrt, abs, min, max, clamp, midpoint, sign
 * Funciona para uint128_t e int128_t usando el template unificado.
 *
 * @note Fase 1.5: Template unificado para signed/unsigned
 */

#ifndef INT128_BASE_CMATH_HPP
#define INT128_BASE_CMATH_HPP

#include "int128_base_tt.hpp"
#include <cmath>
#include <limits>
#include <numeric>
#include <type_traits>
#include <utility>

namespace nstd
{

// =============================================================================
// abs - Valor absoluto
// =============================================================================

/**
 * @brief Valor absoluto para cualquier int128_base_t<S>
 * @note Para unsigned, retorna el mismo valor (identidad)
 * @note Para signed, retorna -x si x < 0
 */
template <signedness S> constexpr int128_base_t<S> abs(const int128_base_t<S>& x) noexcept
{
    return x.abs();
}

// =============================================================================
// gcd - Greatest Common Divisor (Algoritmo binario de Stein)
// =============================================================================

/**
 * @brief Greatest Common Divisor usando algoritmo binario (Stein)
 * Mas eficiente que Euclides para numeros grandes
 */
template <signedness S>
constexpr int128_base_t<S> gcd(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    // Para signed, trabajar con valores absolutos
    int128_base_t<S> u, v;
    if constexpr (S == signedness::signed_type) {
        u = abs(a);
        v = abs(b);
    } else {
        u = a;
        v = b;
    }

    if (u == int128_base_t<S>(0))
        return v;
    if (v == int128_base_t<S>(0))
        return u;

    // Fast path: ambos caben en 64 bits
    if (u.high() == 0 && v.high() == 0) {
        return int128_base_t<S>(std::gcd(u.low(), v.low()));
    }

    // Algoritmo binario GCD (Stein)
    int shift = 0;

    // Encontrar factor comun de 2
    while (((u | v) & int128_base_t<S>(1)) == int128_base_t<S>(0)) {
        u >>= 1;
        v >>= 1;
        ++shift;
    }

    // Eliminar factores de 2 restantes de u
    while ((u & int128_base_t<S>(1)) == int128_base_t<S>(0)) {
        u >>= 1;
    }

    do {
        // Eliminar factores de 2 de v
        while ((v & int128_base_t<S>(1)) == int128_base_t<S>(0)) {
            v >>= 1;
        }

        // Asegurar u <= v
        if (u > v) {
            int128_base_t<S> temp = u;
            u = v;
            v = temp;
        }

        v -= u;
    } while (v != int128_base_t<S>(0));

    return u << shift;
}

// Overloads para tipos integrales
template <signedness S, integral_builtin T>
constexpr int128_base_t<S> gcd(const int128_base_t<S>& a, T b) noexcept
{
    return gcd(a, int128_base_t<S>(b));
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> gcd(T a, const int128_base_t<S>& b) noexcept
{
    return gcd(int128_base_t<S>(a), b);
}

// =============================================================================
// lcm - Least Common Multiple
// =============================================================================

/**
 * @brief Minimo comun multiplo
 * @note Usa formula: lcm(a,b) = (a / gcd(a,b)) * b para evitar overflow
 */
template <signedness S>
constexpr int128_base_t<S> lcm(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    int128_base_t<S> abs_a, abs_b;
    if constexpr (S == signedness::signed_type) {
        abs_a = abs(a);
        abs_b = abs(b);
    } else {
        abs_a = a;
        abs_b = b;
    }

    if (abs_a == int128_base_t<S>(0) || abs_b == int128_base_t<S>(0))
        return int128_base_t<S>(0);

    int128_base_t<S> gcd_val = gcd(abs_a, abs_b);
    return (abs_a / gcd_val) * abs_b;
}

// Overloads para tipos integrales
template <signedness S, integral_builtin T>
constexpr int128_base_t<S> lcm(const int128_base_t<S>& a, T b) noexcept
{
    return lcm(a, int128_base_t<S>(b));
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> lcm(T a, const int128_base_t<S>& b) noexcept
{
    return lcm(int128_base_t<S>(a), b);
}

// =============================================================================
// pow - Exponenciacion binaria
// =============================================================================

/**
 * @brief Potencia usando exponenciacion binaria (fast exponentiation)
 * @note Para signed: exponentes negativos retornan 0
 * @note Caso especial: (-1)^n alterna entre 1 y -1
 */
template <signedness S>
constexpr int128_base_t<S> pow(const int128_base_t<S>& base, const int128_base_t<S>& exp) noexcept
{
    // Para signed, exponentes negativos -> 0 (division entera)
    if constexpr (S == signedness::signed_type) {
        if (exp.is_negative())
            return int128_base_t<S>(0);
    }

    if (exp == int128_base_t<S>(0))
        return int128_base_t<S>(1);
    if (exp == int128_base_t<S>(1))
        return base;
    if (base == int128_base_t<S>(0))
        return int128_base_t<S>(0);
    if (base == int128_base_t<S>(1))
        return int128_base_t<S>(1);

    // Caso especial para signed: (-1)^n
    if constexpr (S == signedness::signed_type) {
        if (base == int128_base_t<S>(-1)) {
            return ((exp.low() & 1) == 0) ? int128_base_t<S>(1) : int128_base_t<S>(-1);
        }
    }

    // Exponenciacion binaria
    int128_base_t<S> result(1);
    int128_base_t<S> base_power = base;
    int128_base_t<S> exponent = exp;

    while (exponent > int128_base_t<S>(0)) {
        if ((exponent & int128_base_t<S>(1)) != int128_base_t<S>(0)) {
            result *= base_power;
        }
        base_power *= base_power;
        exponent >>= 1;
    }

    return result;
}

// Overload para exponente integral
template <signedness S, integral_builtin T>
constexpr int128_base_t<S> pow(const int128_base_t<S>& base, T exp) noexcept
{
    return pow(base, int128_base_t<S>(exp));
}

// =============================================================================
// sqrt - Raiz cuadrada (metodo Newton-Raphson)
// =============================================================================

/**
 * @brief Raiz cuadrada entera usando metodo Newton-Raphson
 * @note Para signed negativos, retorna 0
 */
template <signedness S> constexpr int128_base_t<S> sqrt(const int128_base_t<S>& n) noexcept
{
    // Para signed negativos, no hay raiz real
    if constexpr (S == signedness::signed_type) {
        if (n.is_negative())
            return int128_base_t<S>(0);
    }

    if (n == int128_base_t<S>(0))
        return int128_base_t<S>(0);
    if (n == int128_base_t<S>(1))
        return int128_base_t<S>(1);

    // Encontrar aproximacion inicial usando MSB
    int128_base_t<S> x = n;
    int128_base_t<S> x_prev;

    unsigned msb = 0;
    int128_base_t<S> temp = n;
    while (temp > int128_base_t<S>(0)) {
        temp >>= 1;
        ++msb;
    }
    x = int128_base_t<S>(1) << static_cast<int>((msb + 1) / 2);

    // Metodo de Newton: x_{n+1} = (x_n + n/x_n) / 2
    do {
        x_prev = x;
        x = (x + n / x) / int128_base_t<S>(2);
    } while (x < x_prev);

    return x_prev;
}

// =============================================================================
// min / max
// =============================================================================

/**
 * @brief Valor minimo entre dos numeros
 */
template <signedness S>
constexpr int128_base_t<S> min(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    return (a < b) ? a : b;
}

/**
 * @brief Valor maximo entre dos numeros
 */
template <signedness S>
constexpr int128_base_t<S> max(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    return (a > b) ? a : b;
}

// Overloads para tipos integrales
template <signedness S, integral_builtin T>
constexpr int128_base_t<S> min(const int128_base_t<S>& a, T b) noexcept
{
    return min(a, int128_base_t<S>(b));
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> min(T a, const int128_base_t<S>& b) noexcept
{
    return min(int128_base_t<S>(a), b);
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> max(const int128_base_t<S>& a, T b) noexcept
{
    return max(a, int128_base_t<S>(b));
}

template <signedness S, integral_builtin T>
constexpr int128_base_t<S> max(T a, const int128_base_t<S>& b) noexcept
{
    return max(int128_base_t<S>(a), b);
}

// =============================================================================
// clamp - Restringir valor a rango
// =============================================================================

/**
 * @brief Restringe un valor al rango [min_val, max_val]
 */
template <signedness S>
constexpr int128_base_t<S> clamp(const int128_base_t<S>& value, const int128_base_t<S>& min_val,
                                 const int128_base_t<S>& max_val) noexcept
{
    return (value < min_val) ? min_val : (value > max_val) ? max_val : value;
}

// =============================================================================
// sign - Funcion signo (solo para signed)
// =============================================================================

/**
 * @brief Signo de un numero
 * @return -1 si negativo, 0 si cero, 1 si positivo
 * @note Solo disponible para int128_t (signed)
 */
template <signedness S> constexpr int128_base_t<S> sign(const int128_base_t<S>& x) noexcept
{
    if (x == int128_base_t<S>(0))
        return int128_base_t<S>(0);

    if constexpr (S == signedness::signed_type) {
        return x.is_negative() ? int128_base_t<S>(-1) : int128_base_t<S>(1);
    } else {
        // Para unsigned, siempre es positivo (1) si no es cero
        return int128_base_t<S>(1);
    }
}

// =============================================================================
// midpoint - Punto medio sin overflow
// =============================================================================

/**
 * @brief Calcula el punto medio evitando overflow
 * @note Usa formula: a + (b - a) / 2
 */
template <signedness S>
constexpr int128_base_t<S> midpoint(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    if (a <= b) {
        int128_base_t<S> diff = b - a;
        return a + diff / int128_base_t<S>(2);
    } else {
        int128_base_t<S> diff = a - b;
        return a - diff / int128_base_t<S>(2);
    }
}

// =============================================================================
// divmod - Division y modulo simultaneos
// =============================================================================

/**
 * @brief Division y modulo en una sola operacion
 * @return Par (cociente, resto)
 * @note Si divisor == 0, retorna {0, 0} (comportamiento indefinido)
 */
template <signedness S>
constexpr std::pair<int128_base_t<S>, int128_base_t<S>>
divmod(const int128_base_t<S>& dividend, const int128_base_t<S>& divisor) noexcept
{
    // divrem() retorna std::pair directamente
    return dividend.divrem(divisor);
}

// =============================================================================
// Static asserts para validar compilacion
// =============================================================================

// Validar que las funciones compilan para ambos tipos
static_assert(gcd(uint128_t(48), uint128_t(18)) == uint128_t(6), "gcd(48, 18) debe ser 6");
static_assert(lcm(uint128_t(4), uint128_t(6)) == uint128_t(12), "lcm(4, 6) debe ser 12");
static_assert(pow(uint128_t(2), uint128_t(10)) == uint128_t(1024), "2^10 debe ser 1024");
static_assert(sqrt(uint128_t(100)) == uint128_t(10), "sqrt(100) debe ser 10");
static_assert(min(uint128_t(5), uint128_t(10)) == uint128_t(5), "min(5, 10) debe ser 5");
static_assert(max(uint128_t(5), uint128_t(10)) == uint128_t(10), "max(5, 10) debe ser 10");

} // namespace nstd

#endif // INT128_BASE_CMATH_HPP
