/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * @file divrem_helpers.hpp
 * @brief Helpers para división de 128 bits: división por 64 bits y algoritmo D de Knuth
 *
 * Proporciona implementaciones optimizadas para operaciones de división:
 * - div128_64: División de 128 bits por 64 bits
 * - div128_64_composed: División compuesta (r_hi:data[0]) / divisor
 * - knuth_division_step: Paso del algoritmo D de Knuth
 *
 * @author Julián Calderón Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-08
 * @copyright Boost Software License 1.0
 */

#ifndef INTRINSICS_DIVREM_HELPERS_HPP
#define INTRINSICS_DIVREM_HELPERS_HPP

#include "arithmetic_operations.hpp"
#include "bit_operations.hpp"
#include "compiler_detection.hpp"
#include <cstdint>
#include <optional>
#include <utility>

namespace intrinsics
{

// ============================================================================
// DIV128_64 - División de 128 bits por 64 bits
// ============================================================================

/**
 * @brief División de 128 bits (high:low) por divisor de 64 bits
 *
 * Realiza: quotient = (high:low) / divisor, *remainder = (high:low) % divisor
 *
 * @param high Parte alta del dividendo (64 bits superiores)
 * @param low Parte baja del dividendo (64 bits inferiores)
 * @param divisor Divisor de 64 bits (debe ser != 0)
 * @param remainder Puntero donde almacenar el resto
 * @return Cociente de 64 bits
 *
 * @pre divisor != 0
 * @pre high < divisor (para evitar overflow en el cociente)
 *
 * @note En plataformas con __uint128_t, usa división nativa.
 *       En otras plataformas, usa fallback portable.
 */
inline constexpr uint64_t div128_64(uint64_t high, uint64_t low, uint64_t divisor,
                                    uint64_t* remainder) noexcept
{
#if defined(__SIZEOF_INT128__) && !defined(_MSC_VER)
    // GCC/Clang/Intel con __uint128_t
    __uint128_t dividend = (static_cast<__uint128_t>(high) << 64) | low;
    *remainder = static_cast<uint64_t>(dividend % divisor);
    return static_cast<uint64_t>(dividend / divisor);
#else
    // Fallback portable: división larga
    // Si high >= divisor, el cociente no cabe en 64 bits
    if (high >= divisor) {
        *remainder = 0;
        return 0; // Indicar overflow/error
    }

    // División de (high:low) / divisor usando división larga de 32 bits
    // Esto es una aproximación; para exactitud usar algoritmo de Knuth
    if (high == 0) {
        *remainder = low % divisor;
        return low / divisor;
    }

    // Aproximación: usar división de punto flotante para estimar
    // y luego ajustar. Para máxima precisión, implementar Knuth D.
    // Por ahora, devolvemos 0 para indicar que necesita fallback.
    *remainder = 0;
    return 0;
#endif
}

/**
 * @brief División compuesta para algoritmo de división optimizada
 *
 * Realiza la división (r_hi << 64 | data_lo) / divisor
 * Usado en el algoritmo de división 128/64 bits.
 *
 * @param r_hi Resto alto de división previa
 * @param data_lo Parte baja del dividendo original
 * @param divisor Divisor de 64 bits
 * @param remainder_final Puntero donde almacenar el resto final
 * @return Cociente bajo (q_lo)
 */
inline constexpr uint64_t div128_64_composed(uint64_t r_hi, uint64_t data_lo, uint64_t divisor,
                                             uint64_t* remainder_final) noexcept
{
#if defined(__SIZEOF_INT128__)
    // Usar __uint128_t para cálculo preciso
    __uint128_t dividend = (static_cast<__uint128_t>(r_hi) << 64) | data_lo;
    *remainder_final = static_cast<uint64_t>(dividend % divisor);
    return static_cast<uint64_t>(dividend / divisor);
#else
    // Fallback: indicar que no está disponible (caller debe usar divrem genérico)
    *remainder_final = 0;
    return 0;
#endif
}

// ============================================================================
// KNUTH DIVISION STEP - Paso del algoritmo D de Knuth
// ============================================================================

/**
 * @brief Ejecuta un paso del algoritmo D de Knuth para división
 *
 * Este es el núcleo del algoritmo de división de Knuth para números
 * de precisión arbitraria. Calcula un dígito del cociente.
 *
 * @param u_extension Dígito extra del dividendo (bits que se salieron del shift)
 * @param u_shifted_hi Parte alta del dividendo normalizado
 * @param u_shifted_lo Parte baja del dividendo normalizado
 * @param v_hi Parte alta del divisor normalizado
 * @param v_lo Parte baja del divisor normalizado
 * @param s Cantidad de bits de normalización
 * @param remainder_hi Puntero para parte alta del resto
 * @param remainder_lo Puntero para parte baja del resto
 * @return Dígito del cociente (q)
 *
 * @note Este método usa __uint128_t cuando está disponible.
 *       Sin __uint128_t, retorna 0 para indicar fallback necesario.
 */
inline constexpr uint64_t knuth_division_step(uint64_t u_extension, uint64_t u_shifted_hi,
                                              uint64_t u_shifted_lo, uint64_t v_hi, uint64_t v_lo,
                                              int s, uint64_t* remainder_hi,
                                              uint64_t* remainder_lo) noexcept
{
#if defined(__SIZEOF_INT128__) && !defined(_MSC_VER)
    // Reconstruir dividendo de 192 bits (u_extension:u_shifted)
    // Nota: solo usamos los 128 bits más significativos para estimar q

    // Paso D3: Estimar cociente
    // q_hat = (u_extension * 2^64 + u_shifted_hi) / v_hi
    __uint128_t u_top =
        (static_cast<__uint128_t>(u_extension) << 64) | static_cast<__uint128_t>(u_shifted_hi);
    uint64_t q_hat = static_cast<uint64_t>(u_top / v_hi);
    uint64_t r_hat = static_cast<uint64_t>(u_top % v_hi);

    // Paso D3 (refinamiento): Ajustar q_hat si es demasiado grande
    // while (q_hat >= 2^64 || q_hat * v_lo > 2^64 * r_hat + u_shifted_lo)
    __uint128_t v = (static_cast<__uint128_t>(v_hi) << 64) | v_lo;

    // Verificar y ajustar q_hat
    while (true) {
        __uint128_t product = static_cast<__uint128_t>(q_hat) * v_lo;
        __uint128_t threshold = (static_cast<__uint128_t>(r_hat) << 64) | u_shifted_lo;

        if (product <= threshold) {
            break;
        }

        --q_hat;
        r_hat += v_hi;

        // Si r_hat overflow, salir del loop
        if (r_hat < v_hi) {
            break;
        }
    }

    // Paso D4: Multiplicar y restar
    // u = u - q_hat * v
    __uint128_t u_full = (static_cast<__uint128_t>(u_shifted_hi) << 64) | u_shifted_lo;
    __uint128_t q_times_v = static_cast<__uint128_t>(q_hat) * v;

    // Manejar el caso donde necesitamos el dígito extra
    if (u_extension > 0) {
        // El dividendo real es mayor, pero para 128/128 bits, q <= 1
        // Si u_extension > 0, q_hat debería ser ajustado
    }

    __uint128_t remainder;
    if (u_full >= q_times_v) {
        remainder = u_full - q_times_v;
    } else {
        // Paso D6: Add back (q_hat era 1 demasiado grande)
        --q_hat;
        remainder = u_full + v - q_times_v + v; // Esto simplifica a: u_full - (q_hat-1)*v
        remainder = u_full - static_cast<__uint128_t>(q_hat) * v;
    }

    // Paso D8: Des-normalizar el resto
    *remainder_hi = static_cast<uint64_t>(remainder >> 64);
    *remainder_lo = static_cast<uint64_t>(remainder);

    // Desnormalizar (shift right by s)
    if (s > 0) {
        __uint128_t r_shifted = remainder >> s;
        *remainder_hi = static_cast<uint64_t>(r_shifted >> 64);
        *remainder_lo = static_cast<uint64_t>(r_shifted);
    }

    return q_hat;
#else
    // Sin __uint128_t, indicar que se necesita fallback
    (void)u_extension;
    (void)u_shifted_hi;
    (void)u_shifted_lo;
    (void)v_hi;
    (void)v_lo;
    (void)s;
    *remainder_hi = 0;
    *remainder_lo = 0;
    return 0;
#endif
}

// ============================================================================
// HELPER: Normalización para división de Knuth
// ============================================================================

/**
 * @brief Calcula el factor de normalización para división de Knuth
 *
 * El algoritmo D de Knuth requiere que el MSB del divisor sea 1.
 * Esta función calcula cuántos bits hay que desplazar.
 *
 * @param divisor_hi Parte alta del divisor
 * @return Número de bits a desplazar (0-63)
 */
inline constexpr int knuth_normalization_shift(uint64_t divisor_hi) noexcept
{
    if (divisor_hi == 0) {
        return 64; // Todo el divisor está en la parte baja
    }
    return clz64(divisor_hi);
}

/**
 * @brief Verifica si un número de 128 bits es potencia de 2
 *
 * @param high Parte alta
 * @param low Parte baja
 * @return true si es potencia de 2, false en caso contrario
 */
inline constexpr bool is_power_of_2_128(uint64_t high, uint64_t low) noexcept
{
    // Un número es potencia de 2 si tiene exactamente un bit en 1
    // y es > 0
    if (high == 0 && low == 0) {
        return false;
    }
    if (high == 0) {
        return (low & (low - 1)) == 0;
    }
    if (low == 0) {
        return (high & (high - 1)) == 0;
    }
    return false; // Ambos tienen bits, no es potencia de 2
}

/**
 * @brief Cuenta trailing zeros en número de 128 bits
 *
 * @param high Parte alta
 * @param low Parte baja
 * @return Número de zeros desde el LSB (0-128)
 */
inline constexpr int ctz128(uint64_t high, uint64_t low) noexcept
{
    if (low != 0) {
        return ctz64(low);
    } else if (high != 0) {
        return 64 + ctz64(high);
    } else {
        return 128;
    }
}

} // namespace intrinsics

#endif // INTRINSICS_DIVREM_HELPERS_HPP
