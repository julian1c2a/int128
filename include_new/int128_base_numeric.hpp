/*
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef INT128_BASE_NUMERIC_HPP
#define INT128_BASE_NUMERIC_HPP

/**
 * @file int128_base_numeric.hpp
 * @brief Funciones numéricas para int128_base_t<S>
 * @author Julián Calderón Almendros <julian.calderon.almendros@gmail.com>
 * @version 1.0.0
 * @date 2026-01-07
 * @copyright Boost Software License 1.0
 *
 * Proporciona funciones numéricas compatibles con C++20 que funcionan
 * con el template unificado int128_base_t<signedness S>:
 * - midpoint, clamp, abs, sign
 * - gcd, lcm
 * - power, isqrt, factorial
 * - is_even, is_odd, abs_diff
 * - ilog2
 */

#include "int128_base_bits.hpp"
#include "int128_base_tt.hpp"
#include <type_traits>

namespace nstd
{

// =============================================================================
// FUNCIONES ARITMÉTICAS SEGURAS
// =============================================================================

/**
 * @brief Calcula el punto medio entre dos valores sin overflow
 * @tparam S signedness del tipo
 * @param a Primer valor
 * @param b Segundo valor
 * @return Punto medio entre a y b
 */
template <signedness S>
inline constexpr int128_base_t<S> midpoint(const int128_base_t<S>& a,
                                           const int128_base_t<S>& b) noexcept
{
    // Fórmula segura: a + (b - a) / 2
    return a + (b - a) / int128_base_t<S>(2);
}

/**
 * @brief Restringe un valor a un rango específico
 * @tparam S signedness del tipo
 * @param v Valor a restringir
 * @param lo Valor mínimo del rango
 * @param hi Valor máximo del rango
 * @return v restringido al rango [lo, hi]
 *
 * @pre lo <= hi
 */
template <signedness S>
inline constexpr int128_base_t<S> clamp(const int128_base_t<S>& v, const int128_base_t<S>& lo,
                                        const int128_base_t<S>& hi) noexcept
{
    return (v < lo) ? lo : (hi < v) ? hi : v;
}

/**
 * @brief Valor absoluto
 * @tparam S signedness del tipo
 * @param x Valor del cual obtener el valor absoluto
 * @return |x|
 *
 * @note Para tipos unsigned, retorna el mismo valor
 * @note abs(INT128_MIN) == INT128_MIN debido a overflow en complemento a 2
 */
template <signedness S> inline constexpr int128_base_t<S> abs(const int128_base_t<S>& x) noexcept
{
    if constexpr (S == signedness::unsigned_type) {
        return x; // Unsigned: valor absoluto es el mismo valor
    } else {
        return x.abs(); // Signed: usar método de la clase
    }
}

/**
 * @brief Función signo (compatible con C++23 std::sign)
 * @tparam S signedness del tipo
 * @param x Valor a examinar
 * @return -1 si x < 0, 0 si x == 0, 1 si x > 0
 *
 * @note Para tipos unsigned: retorna 0 o 1
 */
template <signedness S> inline constexpr int sign(const int128_base_t<S>& x) noexcept
{
    if constexpr (S == signedness::unsigned_type) {
        return x.is_zero() ? 0 : 1;
    } else {
        if (x.is_negative())
            return -1;
        if (x.is_zero())
            return 0;
        return 1;
    }
}

// =============================================================================
// GCD Y LCM
// =============================================================================

/**
 * @brief Máximo común divisor (algoritmo binario de Stein)
 * @tparam S signedness del tipo
 * @param a Primer número
 * @param b Segundo número
 * @return GCD(|a|, |b|)
 *
 * @note Para tipos signed, trabaja con valores absolutos
 */
template <signedness S>
inline constexpr int128_base_t<S> gcd(int128_base_t<S> a, int128_base_t<S> b) noexcept
{
    // Para tipos signed, trabajar con valores absolutos
    if constexpr (S == signedness::signed_type) {
        a = abs(a);
        b = abs(b);
    }

    if (a.is_zero())
        return b;
    if (b.is_zero())
        return a;

    // Algoritmo binario de Stein (más eficiente que Euclides para 128 bits)
    int shift = 0;

    // Encontrar factor común de potencias de 2
    while (((a | b) & int128_base_t<S>(1)).is_zero()) {
        a >>= 1;
        b >>= 1;
        ++shift;
    }

    // Eliminar factores de 2 de a
    while ((a & int128_base_t<S>(1)).is_zero()) {
        a >>= 1;
    }

    do {
        // Eliminar factores de 2 de b
        while ((b & int128_base_t<S>(1)).is_zero()) {
            b >>= 1;
        }

        // Asegurar a <= b
        if (a > b) {
            auto temp = a;
            a = b;
            b = temp;
        }

        b = b - a;
    } while (!b.is_zero());

    return a << shift;
}

/**
 * @brief Mínimo común múltiplo
 * @tparam S signedness del tipo
 * @param a Primer número
 * @param b Segundo número
 * @return LCM(|a|, |b|) = (|a| / GCD(|a|, |b|)) * |b|
 *
 * @note Divide primero para evitar overflow
 */
template <signedness S>
inline constexpr int128_base_t<S> lcm(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    if (a.is_zero() || b.is_zero())
        return int128_base_t<S>(0);

    // Trabajar con valores absolutos
    int128_base_t<S> abs_a = abs(a);
    int128_base_t<S> abs_b = abs(b);

    // lcm(a, b) = (a / gcd(a, b)) * b
    // Dividir primero para evitar overflow
    int128_base_t<S> g = gcd(abs_a, abs_b);
    return (abs_a / g) * abs_b;
}

// =============================================================================
// FUNCIONES DE POTENCIA Y RAÍCES
// =============================================================================

/**
 * @brief Exponenciación por cuadrados (fast exponentiation)
 * @tparam S signedness del tipo
 * @param base Base
 * @param exponent Exponente (debe ser >= 0 para signed)
 * @return base^exponent
 */
template <signedness S>
inline constexpr int128_base_t<S> power(int128_base_t<S> base, unsigned int exponent) noexcept
{
    int128_base_t<S> result(1);

    while (exponent > 0) {
        if (exponent & 1) {
            result *= base;
        }
        base *= base;
        exponent >>= 1;
    }

    return result;
}

/**
 * @brief Alias de power para compatibilidad
 */
template <signedness S>
inline constexpr int128_base_t<S> pow(const int128_base_t<S>& base, unsigned int exponent) noexcept
{
    return power(base, exponent);
}

/**
 * @brief Raíz cuadrada entera (piso)
 * @tparam S signedness del tipo
 * @param x Valor (debe ser >= 0)
 * @return floor(sqrt(x))
 *
 * @note Para valores negativos retorna 0
 */
template <signedness S> inline int128_base_t<S> isqrt(const int128_base_t<S>& x) noexcept
{
    if constexpr (S == signedness::signed_type) {
        if (x.is_negative())
            return int128_base_t<S>(0);
    }

    if (x.is_zero())
        return int128_base_t<S>(0);
    if (x == int128_base_t<S>(1))
        return int128_base_t<S>(1);

    // Método de Newton con estimación inicial optimizada
    int width = bit_width(x);
    int128_base_t<S> estimate = int128_base_t<S>(1) << ((width + 1) / 2);

    for (;;) {
        int128_base_t<S> new_estimate = (estimate + x / estimate) / int128_base_t<S>(2);
        if (new_estimate >= estimate) {
            return estimate;
        }
        estimate = new_estimate;
    }
}

/**
 * @brief Alias de isqrt para compatibilidad
 */
template <signedness S> inline int128_base_t<S> sqrt(const int128_base_t<S>& x) noexcept
{
    return isqrt(x);
}

// =============================================================================
// FUNCIONES DE UTILIDAD
// =============================================================================

/**
 * @brief Logaritmo base 2 (piso)
 * @tparam S signedness del tipo
 * @param x Valor (debe ser > 0)
 * @return floor(log2(x)), o -1 si x <= 0
 */
template <signedness S> inline constexpr int ilog2(const int128_base_t<S>& x) noexcept
{
    if constexpr (S == signedness::signed_type) {
        if (x.is_negative() || x.is_zero())
            return -1;
    } else {
        if (x.is_zero())
            return -1;
    }
    return bit_width(x) - 1;
}

/**
 * @brief Verifica si un número es par
 * @tparam S signedness del tipo
 * @param x Valor a verificar
 * @return true si x es par
 */
template <signedness S> inline constexpr bool is_even(const int128_base_t<S>& x) noexcept
{
    return (x & int128_base_t<S>(1)).is_zero();
}

/**
 * @brief Verifica si un número es impar
 * @tparam S signedness del tipo
 * @param x Valor a verificar
 * @return true si x es impar
 */
template <signedness S> inline constexpr bool is_odd(const int128_base_t<S>& x) noexcept
{
    return !is_even(x);
}

/**
 * @brief Diferencia absoluta entre dos valores (sin overflow)
 * @tparam S signedness del tipo
 * @param a Primer valor
 * @param b Segundo valor
 * @return |a - b|
 */
template <signedness S>
inline constexpr int128_base_t<S> abs_diff(const int128_base_t<S>& a,
                                           const int128_base_t<S>& b) noexcept
{
    return (a >= b) ? (a - b) : (b - a);
}

/**
 * @brief Factorial (con protección de overflow)
 * @param n Número (n <= 34 para evitar overflow en 128 bits)
 * @return n!, o 0 si overflow
 */
template <signedness S> inline int128_base_t<S> factorial(unsigned int n) noexcept
{
    if (n > 34)
        return int128_base_t<S>(0); // Overflow para n > 34

    int128_base_t<S> result(1);
    for (unsigned int i = 2; i <= n; ++i) {
        result *= int128_base_t<S>(i);
    }
    return result;
}

/**
 * @brief División y módulo simultáneos
 * @tparam S signedness del tipo
 * @param dividend Dividendo
 * @param divisor Divisor (debe ser != 0)
 * @return Par {cociente, resto}
 */
template <signedness S>
inline constexpr std::pair<int128_base_t<S>, int128_base_t<S>>
divmod(const int128_base_t<S>& dividend, const int128_base_t<S>& divisor) noexcept
{
    // divrem retorna directamente std::pair (no optional en el template unificado)
    return dividend.divrem(divisor);
}

// =============================================================================
// MIN / MAX
// =============================================================================

/**
 * @brief Mínimo de dos valores
 */
template <signedness S>
inline constexpr int128_base_t<S> min(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    return (a < b) ? a : b;
}

/**
 * @brief Máximo de dos valores
 */
template <signedness S>
inline constexpr int128_base_t<S> max(const int128_base_t<S>& a, const int128_base_t<S>& b) noexcept
{
    return (a > b) ? a : b;
}

/**
 * @brief Mínimo de una lista de valores
 */
template <signedness S, typename... Args>
inline constexpr int128_base_t<S> min(const int128_base_t<S>& first, const int128_base_t<S>& second,
                                      const Args&... rest) noexcept
{
    return min(min(first, second), rest...);
}

/**
 * @brief Máximo de una lista de valores
 */
template <signedness S, typename... Args>
inline constexpr int128_base_t<S> max(const int128_base_t<S>& first, const int128_base_t<S>& second,
                                      const Args&... rest) noexcept
{
    return max(max(first, second), rest...);
}

// =============================================================================
// NAMESPACES DE COMPATIBILIDAD
// =============================================================================

namespace uint128_numeric
{
using nstd::abs;
using nstd::abs_diff;
using nstd::clamp;
using nstd::divmod;
using nstd::factorial;
using nstd::gcd;
using nstd::ilog2;
using nstd::is_even;
using nstd::is_odd;
using nstd::isqrt;
using nstd::lcm;
using nstd::max;
using nstd::midpoint;
using nstd::min;
using nstd::pow;
using nstd::power;
using nstd::sign;
using nstd::sqrt;
} // namespace uint128_numeric

namespace int128_numeric
{
using nstd::abs;
using nstd::abs_diff;
using nstd::clamp;
using nstd::divmod;
using nstd::factorial;
using nstd::gcd;
using nstd::ilog2;
using nstd::is_even;
using nstd::is_odd;
using nstd::isqrt;
using nstd::lcm;
using nstd::max;
using nstd::midpoint;
using nstd::min;
using nstd::pow;
using nstd::power;
using nstd::sign;
using nstd::sqrt;
} // namespace int128_numeric

} // namespace nstd

#endif // INT128_BASE_NUMERIC_HPP
